
CONTROL_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000283c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000066  00800060  0000283c  000028d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008e  008000c6  008000c6  00002936  2**0
                  ALLOC
  3 .stab         00003210  00000000  00000000  00002938  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001554  00000000  00000000  00005b48  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000709c  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000070b0  2**2
                  CONTENTS, READONLY
  7 .debug_info   0000052e  00000000  00000000  000070ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004e7  00000000  00000000  0000761a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00007b01  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001af  00000000  00000000  00007b1b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 f9 08 	jmp	0x11f2	; 0x11f2 <__vector_3>
      10:	0c 94 30 09 	jmp	0x1260	; 0x1260 <__vector_4>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 c2 08 	jmp	0x1184	; 0x1184 <__vector_6>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 8b 08 	jmp	0x1116	; 0x1116 <__vector_8>
      24:	0c 94 54 08 	jmp	0x10a8	; 0x10a8 <__vector_9>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 1d 08 	jmp	0x103a	; 0x103a <__vector_19>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	std	Y+40, r29	; 0x28
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	std	Y+56, r1	; 0x38
      62:	ba ab       	std	Y+50, r27	; 0x32
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	std	Y+54, r27	; 0x36
      96:	aa aa       	std	Y+50, r10	; 0x32
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	ldd	r30, Z+49	; 0x31
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__stack+0x471>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d4 e0       	ldi	r29, 0x04	; 4
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	ec e3       	ldi	r30, 0x3C	; 60
      ea:	f8 e2       	ldi	r31, 0x28	; 40
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	a6 3c       	cpi	r26, 0xC6	; 198
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	21 e0       	ldi	r18, 0x01	; 1
      fa:	a6 ec       	ldi	r26, 0xC6	; 198
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	a4 35       	cpi	r26, 0x54	; 84
     104:	b2 07       	cpc	r27, r18
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 8a 00 	call	0x114	; 0x114 <main>
     10c:	0c 94 1c 14 	jmp	0x2838	; 0x2838 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <main>:
uint8 i=0;
uint8 data_temp;


int main(void)
{
     114:	0f 93       	push	r16
     116:	1f 93       	push	r17
     118:	cf 93       	push	r28
     11a:	df 93       	push	r29
     11c:	cd b7       	in	r28, 0x3d	; 61
     11e:	de b7       	in	r29, 0x3e	; 62
     120:	cd 56       	subi	r28, 0x6D	; 109
     122:	d1 09       	sbc	r29, r1
     124:	0f b6       	in	r0, 0x3f	; 63
     126:	f8 94       	cli
     128:	de bf       	out	0x3e, r29	; 62
     12a:	0f be       	out	0x3f, r0	; 63
     12c:	cd bf       	out	0x3d, r28	; 61
/*	initialize peripheral  */

	/* UART initialization */
		UART_configurationType UART_config ;
		UART_config.buadRate=9600;
     12e:	9e 01       	movw	r18, r28
     130:	2b 5a       	subi	r18, 0xAB	; 171
     132:	3f 4f       	sbci	r19, 0xFF	; 255
     134:	80 e8       	ldi	r24, 0x80	; 128
     136:	95 e2       	ldi	r25, 0x25	; 37
     138:	a0 e0       	ldi	r26, 0x00	; 0
     13a:	b0 e0       	ldi	r27, 0x00	; 0
     13c:	f9 01       	movw	r30, r18
     13e:	81 83       	std	Z+1, r24	; 0x01
     140:	92 83       	std	Z+2, r25	; 0x02
     142:	a3 83       	std	Z+3, r26	; 0x03
     144:	b4 83       	std	Z+4, r27	; 0x04
		UART_config.character_size=8;
     146:	ce 01       	movw	r24, r28
     148:	8b 5a       	subi	r24, 0xAB	; 171
     14a:	9f 4f       	sbci	r25, 0xFF	; 255
     14c:	28 e0       	ldi	r18, 0x08	; 8
     14e:	fc 01       	movw	r30, r24
     150:	20 83       	st	Z, r18
		strcpy(UART_config.mode,"double speed");
     152:	ce 01       	movw	r24, r28
     154:	8b 5a       	subi	r24, 0xAB	; 171
     156:	9f 4f       	sbci	r25, 0xFF	; 255
     158:	05 96       	adiw	r24, 0x05	; 5
     15a:	2d e0       	ldi	r18, 0x0D	; 13
     15c:	e0 e6       	ldi	r30, 0x60	; 96
     15e:	f0 e0       	ldi	r31, 0x00	; 0
     160:	dc 01       	movw	r26, r24
     162:	01 90       	ld	r0, Z+
     164:	0d 92       	st	X+, r0
     166:	2a 95       	dec	r18
     168:	e1 f7       	brne	.-8      	; 0x162 <main+0x4e>
		UART_init(&UART_config);
     16a:	ce 01       	movw	r24, r28
     16c:	8b 5a       	subi	r24, 0xAB	; 171
     16e:	9f 4f       	sbci	r25, 0xFF	; 255
     170:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <UART_init>

	/*EEPROM initialization */
		EEPROM_init();
     174:	0e 94 62 05 	call	0xac4	; 0xac4 <EEPROM_init>

	/* TIMER configuration which set in acturators module */
		timer_set();
     178:	0e 94 92 04 	call	0x924	; 0x924 <timer_set>
     17c:	80 e0       	ldi	r24, 0x00	; 0
     17e:	90 e0       	ldi	r25, 0x00	; 0
     180:	a8 ec       	ldi	r26, 0xC8	; 200
     182:	b2 e4       	ldi	r27, 0x42	; 66
     184:	8d 8b       	std	Y+21, r24	; 0x15
     186:	9e 8b       	std	Y+22, r25	; 0x16
     188:	af 8b       	std	Y+23, r26	; 0x17
     18a:	b8 8f       	std	Y+24, r27	; 0x18

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     18c:	20 e0       	ldi	r18, 0x00	; 0
     18e:	30 e0       	ldi	r19, 0x00	; 0
     190:	4a ef       	ldi	r20, 0xFA	; 250
     192:	54 e4       	ldi	r21, 0x44	; 68
     194:	6d 89       	ldd	r22, Y+21	; 0x15
     196:	7e 89       	ldd	r23, Y+22	; 0x16
     198:	8f 89       	ldd	r24, Y+23	; 0x17
     19a:	98 8d       	ldd	r25, Y+24	; 0x18
     19c:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     1a0:	dc 01       	movw	r26, r24
     1a2:	cb 01       	movw	r24, r22
     1a4:	89 8f       	std	Y+25, r24	; 0x19
     1a6:	9a 8f       	std	Y+26, r25	; 0x1a
     1a8:	ab 8f       	std	Y+27, r26	; 0x1b
     1aa:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	40 e8       	ldi	r20, 0x80	; 128
     1b2:	5f e3       	ldi	r21, 0x3F	; 63
     1b4:	69 8d       	ldd	r22, Y+25	; 0x19
     1b6:	7a 8d       	ldd	r23, Y+26	; 0x1a
     1b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     1ba:	9c 8d       	ldd	r25, Y+28	; 0x1c
     1bc:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     1c0:	88 23       	and	r24, r24
     1c2:	2c f4       	brge	.+10     	; 0x1ce <main+0xba>
		__ticks = 1;
     1c4:	81 e0       	ldi	r24, 0x01	; 1
     1c6:	90 e0       	ldi	r25, 0x00	; 0
     1c8:	9e 8f       	std	Y+30, r25	; 0x1e
     1ca:	8d 8f       	std	Y+29, r24	; 0x1d
     1cc:	3f c0       	rjmp	.+126    	; 0x24c <main+0x138>
	else if (__tmp > 65535)
     1ce:	20 e0       	ldi	r18, 0x00	; 0
     1d0:	3f ef       	ldi	r19, 0xFF	; 255
     1d2:	4f e7       	ldi	r20, 0x7F	; 127
     1d4:	57 e4       	ldi	r21, 0x47	; 71
     1d6:	69 8d       	ldd	r22, Y+25	; 0x19
     1d8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     1da:	8b 8d       	ldd	r24, Y+27	; 0x1b
     1dc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     1de:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     1e2:	18 16       	cp	r1, r24
     1e4:	4c f5       	brge	.+82     	; 0x238 <main+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     1e6:	20 e0       	ldi	r18, 0x00	; 0
     1e8:	30 e0       	ldi	r19, 0x00	; 0
     1ea:	40 e2       	ldi	r20, 0x20	; 32
     1ec:	51 e4       	ldi	r21, 0x41	; 65
     1ee:	6d 89       	ldd	r22, Y+21	; 0x15
     1f0:	7e 89       	ldd	r23, Y+22	; 0x16
     1f2:	8f 89       	ldd	r24, Y+23	; 0x17
     1f4:	98 8d       	ldd	r25, Y+24	; 0x18
     1f6:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     1fa:	dc 01       	movw	r26, r24
     1fc:	cb 01       	movw	r24, r22
     1fe:	bc 01       	movw	r22, r24
     200:	cd 01       	movw	r24, r26
     202:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     206:	dc 01       	movw	r26, r24
     208:	cb 01       	movw	r24, r22
     20a:	9e 8f       	std	Y+30, r25	; 0x1e
     20c:	8d 8f       	std	Y+29, r24	; 0x1d
     20e:	0f c0       	rjmp	.+30     	; 0x22e <main+0x11a>
     210:	88 ec       	ldi	r24, 0xC8	; 200
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	98 a3       	std	Y+32, r25	; 0x20
     216:	8f 8f       	std	Y+31, r24	; 0x1f
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     218:	8f 8d       	ldd	r24, Y+31	; 0x1f
     21a:	98 a1       	ldd	r25, Y+32	; 0x20
     21c:	01 97       	sbiw	r24, 0x01	; 1
     21e:	f1 f7       	brne	.-4      	; 0x21c <main+0x108>
     220:	98 a3       	std	Y+32, r25	; 0x20
     222:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     224:	8d 8d       	ldd	r24, Y+29	; 0x1d
     226:	9e 8d       	ldd	r25, Y+30	; 0x1e
     228:	01 97       	sbiw	r24, 0x01	; 1
     22a:	9e 8f       	std	Y+30, r25	; 0x1e
     22c:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     22e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     230:	9e 8d       	ldd	r25, Y+30	; 0x1e
     232:	89 2b       	or	r24, r25
     234:	69 f7       	brne	.-38     	; 0x210 <main+0xfc>
     236:	14 c0       	rjmp	.+40     	; 0x260 <main+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     238:	69 8d       	ldd	r22, Y+25	; 0x19
     23a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     23c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     23e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     240:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     244:	dc 01       	movw	r26, r24
     246:	cb 01       	movw	r24, r22
     248:	9e 8f       	std	Y+30, r25	; 0x1e
     24a:	8d 8f       	std	Y+29, r24	; 0x1d
     24c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     24e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     250:	9a a3       	std	Y+34, r25	; 0x22
     252:	89 a3       	std	Y+33, r24	; 0x21
     254:	89 a1       	ldd	r24, Y+33	; 0x21
     256:	9a a1       	ldd	r25, Y+34	; 0x22
     258:	01 97       	sbiw	r24, 0x01	; 1
     25a:	f1 f7       	brne	.-4      	; 0x258 <main+0x144>
     25c:	9a a3       	std	Y+34, r25	; 0x22
     25e:	89 a3       	std	Y+33, r24	; 0x21
 	   	_delay_ms(100); /* delay to force UART in control_ECU synchronize with HMI_ECU */


 	   	/*check on a password stored flag if it equal predefine pattern=0xAA in specified address 0x0011
 	  */
    	EEPROM_readByte(0x0011,&password_stored_flag);
     260:	6e ee       	ldi	r22, 0xEE	; 238
     262:	70 e0       	ldi	r23, 0x00	; 0
     264:	81 e1       	ldi	r24, 0x11	; 17
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	0e 94 bd 05 	call	0xb7a	; 0xb7a <EEPROM_readByte>

/***************************************************************
* 		CASE 0 : password already set	*
* *************************************************************
*/
    	if(((password_stored_flag ==0xAA)&&(i<3)&&(set_password_now_flag==0))||buzzer_flag)
     26c:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     270:	8a 3a       	cpi	r24, 0xAA	; 170
     272:	41 f4       	brne	.+16     	; 0x284 <main+0x170>
     274:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <i>
     278:	83 30       	cpi	r24, 0x03	; 3
     27a:	20 f4       	brcc	.+8      	; 0x284 <main+0x170>
     27c:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     280:	88 23       	and	r24, r24
     282:	29 f0       	breq	.+10     	; 0x28e <main+0x17a>
     284:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <buzzer_flag>
     288:	88 23       	and	r24, r24
     28a:	09 f4       	brne	.+2      	; 0x28e <main+0x17a>
     28c:	94 c1       	rjmp	.+808    	; 0x5b6 <__stack+0x157>
    		 {
    		UART_sendByte('d');
     28e:	84 e6       	ldi	r24, 0x64	; 100
     290:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
     294:	80 e0       	ldi	r24, 0x00	; 0
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	a0 e2       	ldi	r26, 0x20	; 32
     29a:	b1 e4       	ldi	r27, 0x41	; 65
     29c:	89 87       	std	Y+9, r24	; 0x09
     29e:	9a 87       	std	Y+10, r25	; 0x0a
     2a0:	ab 87       	std	Y+11, r26	; 0x0b
     2a2:	bc 87       	std	Y+12, r27	; 0x0c

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     2a4:	20 e0       	ldi	r18, 0x00	; 0
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	4a ef       	ldi	r20, 0xFA	; 250
     2aa:	54 e4       	ldi	r21, 0x44	; 68
     2ac:	69 85       	ldd	r22, Y+9	; 0x09
     2ae:	7a 85       	ldd	r23, Y+10	; 0x0a
     2b0:	8b 85       	ldd	r24, Y+11	; 0x0b
     2b2:	9c 85       	ldd	r25, Y+12	; 0x0c
     2b4:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     2b8:	dc 01       	movw	r26, r24
     2ba:	cb 01       	movw	r24, r22
     2bc:	8f ab       	std	Y+55, r24	; 0x37
     2be:	98 af       	std	Y+56, r25	; 0x38
     2c0:	a9 af       	std	Y+57, r26	; 0x39
     2c2:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
     2c4:	20 e0       	ldi	r18, 0x00	; 0
     2c6:	30 e0       	ldi	r19, 0x00	; 0
     2c8:	40 e8       	ldi	r20, 0x80	; 128
     2ca:	5f e3       	ldi	r21, 0x3F	; 63
     2cc:	6f a9       	ldd	r22, Y+55	; 0x37
     2ce:	78 ad       	ldd	r23, Y+56	; 0x38
     2d0:	89 ad       	ldd	r24, Y+57	; 0x39
     2d2:	9a ad       	ldd	r25, Y+58	; 0x3a
     2d4:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     2d8:	88 23       	and	r24, r24
     2da:	2c f4       	brge	.+10     	; 0x2e6 <main+0x1d2>
		__ticks = 1;
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	90 e0       	ldi	r25, 0x00	; 0
     2e0:	9c af       	std	Y+60, r25	; 0x3c
     2e2:	8b af       	std	Y+59, r24	; 0x3b
     2e4:	3f c0       	rjmp	.+126    	; 0x364 <main+0x250>
	else if (__tmp > 65535)
     2e6:	20 e0       	ldi	r18, 0x00	; 0
     2e8:	3f ef       	ldi	r19, 0xFF	; 255
     2ea:	4f e7       	ldi	r20, 0x7F	; 127
     2ec:	57 e4       	ldi	r21, 0x47	; 71
     2ee:	6f a9       	ldd	r22, Y+55	; 0x37
     2f0:	78 ad       	ldd	r23, Y+56	; 0x38
     2f2:	89 ad       	ldd	r24, Y+57	; 0x39
     2f4:	9a ad       	ldd	r25, Y+58	; 0x3a
     2f6:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     2fa:	18 16       	cp	r1, r24
     2fc:	4c f5       	brge	.+82     	; 0x350 <main+0x23c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	30 e0       	ldi	r19, 0x00	; 0
     302:	40 e2       	ldi	r20, 0x20	; 32
     304:	51 e4       	ldi	r21, 0x41	; 65
     306:	69 85       	ldd	r22, Y+9	; 0x09
     308:	7a 85       	ldd	r23, Y+10	; 0x0a
     30a:	8b 85       	ldd	r24, Y+11	; 0x0b
     30c:	9c 85       	ldd	r25, Y+12	; 0x0c
     30e:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     312:	dc 01       	movw	r26, r24
     314:	cb 01       	movw	r24, r22
     316:	bc 01       	movw	r22, r24
     318:	cd 01       	movw	r24, r26
     31a:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     31e:	dc 01       	movw	r26, r24
     320:	cb 01       	movw	r24, r22
     322:	9c af       	std	Y+60, r25	; 0x3c
     324:	8b af       	std	Y+59, r24	; 0x3b
     326:	0f c0       	rjmp	.+30     	; 0x346 <main+0x232>
     328:	88 ec       	ldi	r24, 0xC8	; 200
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	9e af       	std	Y+62, r25	; 0x3e
     32e:	8d af       	std	Y+61, r24	; 0x3d
     330:	8d ad       	ldd	r24, Y+61	; 0x3d
     332:	9e ad       	ldd	r25, Y+62	; 0x3e
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	f1 f7       	brne	.-4      	; 0x334 <main+0x220>
     338:	9e af       	std	Y+62, r25	; 0x3e
     33a:	8d af       	std	Y+61, r24	; 0x3d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     33c:	8b ad       	ldd	r24, Y+59	; 0x3b
     33e:	9c ad       	ldd	r25, Y+60	; 0x3c
     340:	01 97       	sbiw	r24, 0x01	; 1
     342:	9c af       	std	Y+60, r25	; 0x3c
     344:	8b af       	std	Y+59, r24	; 0x3b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     346:	8b ad       	ldd	r24, Y+59	; 0x3b
     348:	9c ad       	ldd	r25, Y+60	; 0x3c
     34a:	89 2b       	or	r24, r25
     34c:	69 f7       	brne	.-38     	; 0x328 <main+0x214>
     34e:	1e c0       	rjmp	.+60     	; 0x38c <main+0x278>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     350:	6f a9       	ldd	r22, Y+55	; 0x37
     352:	78 ad       	ldd	r23, Y+56	; 0x38
     354:	89 ad       	ldd	r24, Y+57	; 0x39
     356:	9a ad       	ldd	r25, Y+58	; 0x3a
     358:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     35c:	dc 01       	movw	r26, r24
     35e:	cb 01       	movw	r24, r22
     360:	9c af       	std	Y+60, r25	; 0x3c
     362:	8b af       	std	Y+59, r24	; 0x3b
     364:	2b ad       	ldd	r18, Y+59	; 0x3b
     366:	3c ad       	ldd	r19, Y+60	; 0x3c
     368:	ce 01       	movw	r24, r28
     36a:	cf 96       	adiw	r24, 0x3f	; 63
     36c:	fc 01       	movw	r30, r24
     36e:	31 83       	std	Z+1, r19	; 0x01
     370:	20 83       	st	Z, r18
     372:	ce 01       	movw	r24, r28
     374:	cf 96       	adiw	r24, 0x3f	; 63
     376:	fc 01       	movw	r30, r24
     378:	80 81       	ld	r24, Z
     37a:	91 81       	ldd	r25, Z+1	; 0x01
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <main+0x268>
     380:	9e 01       	movw	r18, r28
     382:	21 5c       	subi	r18, 0xC1	; 193
     384:	3f 4f       	sbci	r19, 0xFF	; 255
     386:	f9 01       	movw	r30, r18
     388:	91 83       	std	Z+1, r25	; 0x01
     38a:	80 83       	st	Z, r24
     	   	_delay_ms(10);

    	    	UART_receiveString(enter_password_stored);
     38c:	8a ed       	ldi	r24, 0xDA	; 218
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <UART_receiveString>
     394:	80 e0       	ldi	r24, 0x00	; 0
     396:	90 e0       	ldi	r25, 0x00	; 0
     398:	a0 e2       	ldi	r26, 0x20	; 32
     39a:	b1 e4       	ldi	r27, 0x41	; 65
     39c:	8d 87       	std	Y+13, r24	; 0x0d
     39e:	9e 87       	std	Y+14, r25	; 0x0e
     3a0:	af 87       	std	Y+15, r26	; 0x0f
     3a2:	b8 8b       	std	Y+16, r27	; 0x10

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     3a4:	20 e0       	ldi	r18, 0x00	; 0
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	4a ef       	ldi	r20, 0xFA	; 250
     3aa:	54 e4       	ldi	r21, 0x44	; 68
     3ac:	6d 85       	ldd	r22, Y+13	; 0x0d
     3ae:	7e 85       	ldd	r23, Y+14	; 0x0e
     3b0:	8f 85       	ldd	r24, Y+15	; 0x0f
     3b2:	98 89       	ldd	r25, Y+16	; 0x10
     3b4:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     3b8:	dc 01       	movw	r26, r24
     3ba:	cb 01       	movw	r24, r22
     3bc:	8d a7       	std	Y+45, r24	; 0x2d
     3be:	9e a7       	std	Y+46, r25	; 0x2e
     3c0:	af a7       	std	Y+47, r26	; 0x2f
     3c2:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
     3c4:	20 e0       	ldi	r18, 0x00	; 0
     3c6:	30 e0       	ldi	r19, 0x00	; 0
     3c8:	40 e8       	ldi	r20, 0x80	; 128
     3ca:	5f e3       	ldi	r21, 0x3F	; 63
     3cc:	6d a5       	ldd	r22, Y+45	; 0x2d
     3ce:	7e a5       	ldd	r23, Y+46	; 0x2e
     3d0:	8f a5       	ldd	r24, Y+47	; 0x2f
     3d2:	98 a9       	ldd	r25, Y+48	; 0x30
     3d4:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     3d8:	88 23       	and	r24, r24
     3da:	2c f4       	brge	.+10     	; 0x3e6 <main+0x2d2>
		__ticks = 1;
     3dc:	81 e0       	ldi	r24, 0x01	; 1
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	9a ab       	std	Y+50, r25	; 0x32
     3e2:	89 ab       	std	Y+49, r24	; 0x31
     3e4:	3f c0       	rjmp	.+126    	; 0x464 <__stack+0x5>
	else if (__tmp > 65535)
     3e6:	20 e0       	ldi	r18, 0x00	; 0
     3e8:	3f ef       	ldi	r19, 0xFF	; 255
     3ea:	4f e7       	ldi	r20, 0x7F	; 127
     3ec:	57 e4       	ldi	r21, 0x47	; 71
     3ee:	6d a5       	ldd	r22, Y+45	; 0x2d
     3f0:	7e a5       	ldd	r23, Y+46	; 0x2e
     3f2:	8f a5       	ldd	r24, Y+47	; 0x2f
     3f4:	98 a9       	ldd	r25, Y+48	; 0x30
     3f6:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     3fa:	18 16       	cp	r1, r24
     3fc:	4c f5       	brge	.+82     	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     3fe:	20 e0       	ldi	r18, 0x00	; 0
     400:	30 e0       	ldi	r19, 0x00	; 0
     402:	40 e2       	ldi	r20, 0x20	; 32
     404:	51 e4       	ldi	r21, 0x41	; 65
     406:	6d 85       	ldd	r22, Y+13	; 0x0d
     408:	7e 85       	ldd	r23, Y+14	; 0x0e
     40a:	8f 85       	ldd	r24, Y+15	; 0x0f
     40c:	98 89       	ldd	r25, Y+16	; 0x10
     40e:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     412:	dc 01       	movw	r26, r24
     414:	cb 01       	movw	r24, r22
     416:	bc 01       	movw	r22, r24
     418:	cd 01       	movw	r24, r26
     41a:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     41e:	dc 01       	movw	r26, r24
     420:	cb 01       	movw	r24, r22
     422:	9a ab       	std	Y+50, r25	; 0x32
     424:	89 ab       	std	Y+49, r24	; 0x31
     426:	0f c0       	rjmp	.+30     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     428:	88 ec       	ldi	r24, 0xC8	; 200
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	9c ab       	std	Y+52, r25	; 0x34
     42e:	8b ab       	std	Y+51, r24	; 0x33
     430:	8b a9       	ldd	r24, Y+51	; 0x33
     432:	9c a9       	ldd	r25, Y+52	; 0x34
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	f1 f7       	brne	.-4      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
     438:	9c ab       	std	Y+52, r25	; 0x34
     43a:	8b ab       	std	Y+51, r24	; 0x33
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     43c:	89 a9       	ldd	r24, Y+49	; 0x31
     43e:	9a a9       	ldd	r25, Y+50	; 0x32
     440:	01 97       	sbiw	r24, 0x01	; 1
     442:	9a ab       	std	Y+50, r25	; 0x32
     444:	89 ab       	std	Y+49, r24	; 0x31
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     446:	89 a9       	ldd	r24, Y+49	; 0x31
     448:	9a a9       	ldd	r25, Y+50	; 0x32
     44a:	89 2b       	or	r24, r25
     44c:	69 f7       	brne	.-38     	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     44e:	14 c0       	rjmp	.+40     	; 0x478 <__stack+0x19>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     450:	6d a5       	ldd	r22, Y+45	; 0x2d
     452:	7e a5       	ldd	r23, Y+46	; 0x2e
     454:	8f a5       	ldd	r24, Y+47	; 0x2f
     456:	98 a9       	ldd	r25, Y+48	; 0x30
     458:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     45c:	dc 01       	movw	r26, r24
     45e:	cb 01       	movw	r24, r22
     460:	9a ab       	std	Y+50, r25	; 0x32
     462:	89 ab       	std	Y+49, r24	; 0x31
     464:	89 a9       	ldd	r24, Y+49	; 0x31
     466:	9a a9       	ldd	r25, Y+50	; 0x32
     468:	9e ab       	std	Y+54, r25	; 0x36
     46a:	8d ab       	std	Y+53, r24	; 0x35
     46c:	8d a9       	ldd	r24, Y+53	; 0x35
     46e:	9e a9       	ldd	r25, Y+54	; 0x36
     470:	01 97       	sbiw	r24, 0x01	; 1
     472:	f1 f7       	brne	.-4      	; 0x470 <__stack+0x11>
     474:	9e ab       	std	Y+54, r25	; 0x36
     476:	8d ab       	std	Y+53, r24	; 0x35
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
     478:	66 ec       	ldi	r22, 0xC6	; 198
     47a:	70 e0       	ldi	r23, 0x00	; 0
     47c:	82 e1       	ldi	r24, 0x12	; 18
     47e:	95 e0       	ldi	r25, 0x05	; 5
     480:	0e 94 d4 06 	call	0xda8	; 0xda8 <EEPROM_readString>
     484:	80 e0       	ldi	r24, 0x00	; 0
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	a0 e2       	ldi	r26, 0x20	; 32
     48a:	b1 e4       	ldi	r27, 0x41	; 65
     48c:	89 83       	std	Y+1, r24	; 0x01
     48e:	9a 83       	std	Y+2, r25	; 0x02
     490:	ab 83       	std	Y+3, r26	; 0x03
     492:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     494:	20 e0       	ldi	r18, 0x00	; 0
     496:	30 e0       	ldi	r19, 0x00	; 0
     498:	4a ef       	ldi	r20, 0xFA	; 250
     49a:	54 e4       	ldi	r21, 0x44	; 68
     49c:	69 81       	ldd	r22, Y+1	; 0x01
     49e:	7a 81       	ldd	r23, Y+2	; 0x02
     4a0:	8b 81       	ldd	r24, Y+3	; 0x03
     4a2:	9c 81       	ldd	r25, Y+4	; 0x04
     4a4:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     4a8:	dc 01       	movw	r26, r24
     4aa:	cb 01       	movw	r24, r22
     4ac:	8b a3       	std	Y+35, r24	; 0x23
     4ae:	9c a3       	std	Y+36, r25	; 0x24
     4b0:	ad a3       	std	Y+37, r26	; 0x25
     4b2:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	30 e0       	ldi	r19, 0x00	; 0
     4b8:	40 e8       	ldi	r20, 0x80	; 128
     4ba:	5f e3       	ldi	r21, 0x3F	; 63
     4bc:	6b a1       	ldd	r22, Y+35	; 0x23
     4be:	7c a1       	ldd	r23, Y+36	; 0x24
     4c0:	8d a1       	ldd	r24, Y+37	; 0x25
     4c2:	9e a1       	ldd	r25, Y+38	; 0x26
     4c4:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     4c8:	88 23       	and	r24, r24
     4ca:	2c f4       	brge	.+10     	; 0x4d6 <__stack+0x77>
		__ticks = 1;
     4cc:	81 e0       	ldi	r24, 0x01	; 1
     4ce:	90 e0       	ldi	r25, 0x00	; 0
     4d0:	98 a7       	std	Y+40, r25	; 0x28
     4d2:	8f a3       	std	Y+39, r24	; 0x27
     4d4:	3f c0       	rjmp	.+126    	; 0x554 <__stack+0xf5>
	else if (__tmp > 65535)
     4d6:	20 e0       	ldi	r18, 0x00	; 0
     4d8:	3f ef       	ldi	r19, 0xFF	; 255
     4da:	4f e7       	ldi	r20, 0x7F	; 127
     4dc:	57 e4       	ldi	r21, 0x47	; 71
     4de:	6b a1       	ldd	r22, Y+35	; 0x23
     4e0:	7c a1       	ldd	r23, Y+36	; 0x24
     4e2:	8d a1       	ldd	r24, Y+37	; 0x25
     4e4:	9e a1       	ldd	r25, Y+38	; 0x26
     4e6:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     4ea:	18 16       	cp	r1, r24
     4ec:	4c f5       	brge	.+82     	; 0x540 <__stack+0xe1>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     4ee:	20 e0       	ldi	r18, 0x00	; 0
     4f0:	30 e0       	ldi	r19, 0x00	; 0
     4f2:	40 e2       	ldi	r20, 0x20	; 32
     4f4:	51 e4       	ldi	r21, 0x41	; 65
     4f6:	69 81       	ldd	r22, Y+1	; 0x01
     4f8:	7a 81       	ldd	r23, Y+2	; 0x02
     4fa:	8b 81       	ldd	r24, Y+3	; 0x03
     4fc:	9c 81       	ldd	r25, Y+4	; 0x04
     4fe:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     502:	dc 01       	movw	r26, r24
     504:	cb 01       	movw	r24, r22
     506:	bc 01       	movw	r22, r24
     508:	cd 01       	movw	r24, r26
     50a:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     50e:	dc 01       	movw	r26, r24
     510:	cb 01       	movw	r24, r22
     512:	98 a7       	std	Y+40, r25	; 0x28
     514:	8f a3       	std	Y+39, r24	; 0x27
     516:	0f c0       	rjmp	.+30     	; 0x536 <__stack+0xd7>
     518:	88 ec       	ldi	r24, 0xC8	; 200
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	9a a7       	std	Y+42, r25	; 0x2a
     51e:	89 a7       	std	Y+41, r24	; 0x29
     520:	89 a5       	ldd	r24, Y+41	; 0x29
     522:	9a a5       	ldd	r25, Y+42	; 0x2a
     524:	01 97       	sbiw	r24, 0x01	; 1
     526:	f1 f7       	brne	.-4      	; 0x524 <__stack+0xc5>
     528:	9a a7       	std	Y+42, r25	; 0x2a
     52a:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     52c:	8f a1       	ldd	r24, Y+39	; 0x27
     52e:	98 a5       	ldd	r25, Y+40	; 0x28
     530:	01 97       	sbiw	r24, 0x01	; 1
     532:	98 a7       	std	Y+40, r25	; 0x28
     534:	8f a3       	std	Y+39, r24	; 0x27
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     536:	8f a1       	ldd	r24, Y+39	; 0x27
     538:	98 a5       	ldd	r25, Y+40	; 0x28
     53a:	89 2b       	or	r24, r25
     53c:	69 f7       	brne	.-38     	; 0x518 <__stack+0xb9>
     53e:	14 c0       	rjmp	.+40     	; 0x568 <__stack+0x109>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     540:	6b a1       	ldd	r22, Y+35	; 0x23
     542:	7c a1       	ldd	r23, Y+36	; 0x24
     544:	8d a1       	ldd	r24, Y+37	; 0x25
     546:	9e a1       	ldd	r25, Y+38	; 0x26
     548:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     54c:	dc 01       	movw	r26, r24
     54e:	cb 01       	movw	r24, r22
     550:	98 a7       	std	Y+40, r25	; 0x28
     552:	8f a3       	std	Y+39, r24	; 0x27
     554:	8f a1       	ldd	r24, Y+39	; 0x27
     556:	98 a5       	ldd	r25, Y+40	; 0x28
     558:	9c a7       	std	Y+44, r25	; 0x2c
     55a:	8b a7       	std	Y+43, r24	; 0x2b
     55c:	8b a5       	ldd	r24, Y+43	; 0x2b
     55e:	9c a5       	ldd	r25, Y+44	; 0x2c
     560:	01 97       	sbiw	r24, 0x01	; 1
     562:	f1 f7       	brne	.-4      	; 0x560 <__stack+0x101>
     564:	9c a7       	std	Y+44, r25	; 0x2c
     566:	8b a7       	std	Y+43, r24	; 0x2b
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     568:	66 ec       	ldi	r22, 0xC6	; 198
     56a:	70 e0       	ldi	r23, 0x00	; 0
     56c:	8a ed       	ldi	r24, 0xDA	; 218
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
     574:	89 2b       	or	r24, r25
     576:	b1 f4       	brne	.+44     	; 0x5a4 <__stack+0x145>
    		{
        		UART_sendByte('w');
     578:	87 e7       	ldi	r24, 0x77	; 119
     57a:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
        		data_temp=UART_receiveByte();
     57e:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <UART_receiveByte>
     582:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <data_temp>
        		if(data_temp=='s')
     586:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_temp>
     58a:	83 37       	cpi	r24, 0x73	; 115
     58c:	21 f4       	brne	.+8      	; 0x596 <__stack+0x137>
        			force_set=1;
     58e:	81 e0       	ldi	r24, 0x01	; 1
     590:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <force_set>

    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     594:	29 c0       	rjmp	.+82     	; 0x5e8 <__stack+0x189>
    		{
        		UART_sendByte('w');
        		data_temp=UART_receiveByte();
        		if(data_temp=='s')
        			force_set=1;
        		else if(data_temp=='o')
     596:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_temp>
     59a:	8f 36       	cpi	r24, 0x6F	; 111
     59c:	29 f5       	brne	.+74     	; 0x5e8 <__stack+0x189>
        		{
        			 motor_run();
     59e:	0e 94 b0 04 	call	0x960	; 0x960 <motor_run>

    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5a2:	22 c0       	rjmp	.+68     	; 0x5e8 <__stack+0x189>
        			 motor_run();
        		}
    		 }
    		else
    		{
    			UART_sendByte('u');
     5a4:	85 e7       	ldi	r24, 0x75	; 117
     5a6:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
				i++;
     5aa:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <i>
     5ae:	8f 5f       	subi	r24, 0xFF	; 255
     5b0:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <i>

    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5b4:	19 c0       	rjmp	.+50     	; 0x5e8 <__stack+0x189>
/*******************************************************************************
* 		CASE 1 : password already set and user try enter password than 3 times	*
* ******************************************************************************
*/

    	else if((password_stored_flag ==0xAA)&&(i>=3)&&(set_password_now_flag==0)&&(!block_buzzer_scope))
     5b6:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     5ba:	8a 3a       	cpi	r24, 0xAA	; 170
     5bc:	b1 f4       	brne	.+44     	; 0x5ea <__stack+0x18b>
     5be:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <i>
     5c2:	83 30       	cpi	r24, 0x03	; 3
     5c4:	90 f0       	brcs	.+36     	; 0x5ea <__stack+0x18b>
     5c6:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     5ca:	88 23       	and	r24, r24
     5cc:	71 f4       	brne	.+28     	; 0x5ea <__stack+0x18b>
     5ce:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <block_buzzer_scope>
     5d2:	88 23       	and	r24, r24
     5d4:	51 f4       	brne	.+20     	; 0x5ea <__stack+0x18b>
    	{
    		UART_sendByte('B');
     5d6:	82 e4       	ldi	r24, 0x42	; 66
     5d8:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
    		buzzer();
     5dc:	0e 94 1a 05 	call	0xa34	; 0xa34 <buzzer>
    		block_buzzer_scope=1;
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <block_buzzer_scope>
     5e6:	01 c0       	rjmp	.+2      	; 0x5ea <__stack+0x18b>

    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5e8:	00 00       	nop
    	/***************************************************************
    	* 		CASE 0 : first time and user should set password	*
    	* *************************************************************
    	*/

    	if(((password_stored_flag !=0xAA)&&(set_password_now_flag==0))||force_set)
     5ea:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     5ee:	8a 3a       	cpi	r24, 0xAA	; 170
     5f0:	21 f0       	breq	.+8      	; 0x5fa <__stack+0x19b>
     5f2:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     5f6:	88 23       	and	r24, r24
     5f8:	29 f0       	breq	.+10     	; 0x604 <__stack+0x1a5>
     5fa:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <force_set>
     5fe:	88 23       	and	r24, r24
     600:	09 f4       	brne	.+2      	; 0x604 <__stack+0x1a5>
     602:	bc cd       	rjmp	.-1160   	; 0x17c <main+0x68>
    	{
        	UART_sendByte('s');
     604:	83 e7       	ldi	r24, 0x73	; 115
     606:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
    	UART_receiveString(password_stored);
     60a:	88 ef       	ldi	r24, 0xF8	; 248
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <UART_receiveString>
     612:	80 e0       	ldi	r24, 0x00	; 0
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	a8 ec       	ldi	r26, 0xC8	; 200
     618:	b2 e4       	ldi	r27, 0x42	; 66
     61a:	89 8b       	std	Y+17, r24	; 0x11
     61c:	9a 8b       	std	Y+18, r25	; 0x12
     61e:	ab 8b       	std	Y+19, r26	; 0x13
     620:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     622:	8e 01       	movw	r16, r28
     624:	05 5b       	subi	r16, 0xB5	; 181
     626:	1f 4f       	sbci	r17, 0xFF	; 255
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	4a ef       	ldi	r20, 0xFA	; 250
     62e:	54 e4       	ldi	r21, 0x44	; 68
     630:	69 89       	ldd	r22, Y+17	; 0x11
     632:	7a 89       	ldd	r23, Y+18	; 0x12
     634:	8b 89       	ldd	r24, Y+19	; 0x13
     636:	9c 89       	ldd	r25, Y+20	; 0x14
     638:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     63c:	dc 01       	movw	r26, r24
     63e:	cb 01       	movw	r24, r22
     640:	f8 01       	movw	r30, r16
     642:	80 83       	st	Z, r24
     644:	91 83       	std	Z+1, r25	; 0x01
     646:	a2 83       	std	Z+2, r26	; 0x02
     648:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     64a:	ce 01       	movw	r24, r28
     64c:	85 5b       	subi	r24, 0xB5	; 181
     64e:	9f 4f       	sbci	r25, 0xFF	; 255
     650:	20 e0       	ldi	r18, 0x00	; 0
     652:	30 e0       	ldi	r19, 0x00	; 0
     654:	40 e8       	ldi	r20, 0x80	; 128
     656:	5f e3       	ldi	r21, 0x3F	; 63
     658:	fc 01       	movw	r30, r24
     65a:	60 81       	ld	r22, Z
     65c:	71 81       	ldd	r23, Z+1	; 0x01
     65e:	82 81       	ldd	r24, Z+2	; 0x02
     660:	93 81       	ldd	r25, Z+3	; 0x03
     662:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     666:	88 23       	and	r24, r24
     668:	4c f4       	brge	.+18     	; 0x67c <__stack+0x21d>
		__ticks = 1;
     66a:	ce 01       	movw	r24, r28
     66c:	81 5b       	subi	r24, 0xB1	; 177
     66e:	9f 4f       	sbci	r25, 0xFF	; 255
     670:	21 e0       	ldi	r18, 0x01	; 1
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	fc 01       	movw	r30, r24
     676:	31 83       	std	Z+1, r19	; 0x01
     678:	20 83       	st	Z, r18
     67a:	69 c0       	rjmp	.+210    	; 0x74e <__stack+0x2ef>
	else if (__tmp > 65535)
     67c:	ce 01       	movw	r24, r28
     67e:	85 5b       	subi	r24, 0xB5	; 181
     680:	9f 4f       	sbci	r25, 0xFF	; 255
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	3f ef       	ldi	r19, 0xFF	; 255
     686:	4f e7       	ldi	r20, 0x7F	; 127
     688:	57 e4       	ldi	r21, 0x47	; 71
     68a:	fc 01       	movw	r30, r24
     68c:	60 81       	ld	r22, Z
     68e:	71 81       	ldd	r23, Z+1	; 0x01
     690:	82 81       	ldd	r24, Z+2	; 0x02
     692:	93 81       	ldd	r25, Z+3	; 0x03
     694:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     698:	18 16       	cp	r1, r24
     69a:	0c f0       	brlt	.+2      	; 0x69e <__stack+0x23f>
     69c:	46 c0       	rjmp	.+140    	; 0x72a <__stack+0x2cb>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     69e:	20 e0       	ldi	r18, 0x00	; 0
     6a0:	30 e0       	ldi	r19, 0x00	; 0
     6a2:	40 e2       	ldi	r20, 0x20	; 32
     6a4:	51 e4       	ldi	r21, 0x41	; 65
     6a6:	69 89       	ldd	r22, Y+17	; 0x11
     6a8:	7a 89       	ldd	r23, Y+18	; 0x12
     6aa:	8b 89       	ldd	r24, Y+19	; 0x13
     6ac:	9c 89       	ldd	r25, Y+20	; 0x14
     6ae:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     6b2:	dc 01       	movw	r26, r24
     6b4:	cb 01       	movw	r24, r22
     6b6:	8e 01       	movw	r16, r28
     6b8:	01 5b       	subi	r16, 0xB1	; 177
     6ba:	1f 4f       	sbci	r17, 0xFF	; 255
     6bc:	bc 01       	movw	r22, r24
     6be:	cd 01       	movw	r24, r26
     6c0:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     6c4:	dc 01       	movw	r26, r24
     6c6:	cb 01       	movw	r24, r22
     6c8:	f8 01       	movw	r30, r16
     6ca:	91 83       	std	Z+1, r25	; 0x01
     6cc:	80 83       	st	Z, r24
     6ce:	24 c0       	rjmp	.+72     	; 0x718 <__stack+0x2b9>
     6d0:	ce 01       	movw	r24, r28
     6d2:	8f 5a       	subi	r24, 0xAF	; 175
     6d4:	9f 4f       	sbci	r25, 0xFF	; 255
     6d6:	28 ec       	ldi	r18, 0xC8	; 200
     6d8:	30 e0       	ldi	r19, 0x00	; 0
     6da:	fc 01       	movw	r30, r24
     6dc:	31 83       	std	Z+1, r19	; 0x01
     6de:	20 83       	st	Z, r18
     6e0:	ce 01       	movw	r24, r28
     6e2:	8f 5a       	subi	r24, 0xAF	; 175
     6e4:	9f 4f       	sbci	r25, 0xFF	; 255
     6e6:	fc 01       	movw	r30, r24
     6e8:	80 81       	ld	r24, Z
     6ea:	91 81       	ldd	r25, Z+1	; 0x01
     6ec:	01 97       	sbiw	r24, 0x01	; 1
     6ee:	f1 f7       	brne	.-4      	; 0x6ec <__stack+0x28d>
     6f0:	9e 01       	movw	r18, r28
     6f2:	2f 5a       	subi	r18, 0xAF	; 175
     6f4:	3f 4f       	sbci	r19, 0xFF	; 255
     6f6:	f9 01       	movw	r30, r18
     6f8:	91 83       	std	Z+1, r25	; 0x01
     6fa:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6fc:	ce 01       	movw	r24, r28
     6fe:	81 5b       	subi	r24, 0xB1	; 177
     700:	9f 4f       	sbci	r25, 0xFF	; 255
     702:	9e 01       	movw	r18, r28
     704:	21 5b       	subi	r18, 0xB1	; 177
     706:	3f 4f       	sbci	r19, 0xFF	; 255
     708:	f9 01       	movw	r30, r18
     70a:	20 81       	ld	r18, Z
     70c:	31 81       	ldd	r19, Z+1	; 0x01
     70e:	21 50       	subi	r18, 0x01	; 1
     710:	31 09       	sbc	r19, r1
     712:	fc 01       	movw	r30, r24
     714:	31 83       	std	Z+1, r19	; 0x01
     716:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     718:	ce 01       	movw	r24, r28
     71a:	81 5b       	subi	r24, 0xB1	; 177
     71c:	9f 4f       	sbci	r25, 0xFF	; 255
     71e:	fc 01       	movw	r30, r24
     720:	80 81       	ld	r24, Z
     722:	91 81       	ldd	r25, Z+1	; 0x01
     724:	89 2b       	or	r24, r25
     726:	a1 f6       	brne	.-88     	; 0x6d0 <__stack+0x271>
     728:	2c c0       	rjmp	.+88     	; 0x782 <__stack+0x323>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     72a:	8e 01       	movw	r16, r28
     72c:	01 5b       	subi	r16, 0xB1	; 177
     72e:	1f 4f       	sbci	r17, 0xFF	; 255
     730:	ce 01       	movw	r24, r28
     732:	85 5b       	subi	r24, 0xB5	; 181
     734:	9f 4f       	sbci	r25, 0xFF	; 255
     736:	fc 01       	movw	r30, r24
     738:	60 81       	ld	r22, Z
     73a:	71 81       	ldd	r23, Z+1	; 0x01
     73c:	82 81       	ldd	r24, Z+2	; 0x02
     73e:	93 81       	ldd	r25, Z+3	; 0x03
     740:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     744:	dc 01       	movw	r26, r24
     746:	cb 01       	movw	r24, r22
     748:	f8 01       	movw	r30, r16
     74a:	91 83       	std	Z+1, r25	; 0x01
     74c:	80 83       	st	Z, r24
     74e:	ce 01       	movw	r24, r28
     750:	8d 5a       	subi	r24, 0xAD	; 173
     752:	9f 4f       	sbci	r25, 0xFF	; 255
     754:	9e 01       	movw	r18, r28
     756:	21 5b       	subi	r18, 0xB1	; 177
     758:	3f 4f       	sbci	r19, 0xFF	; 255
     75a:	f9 01       	movw	r30, r18
     75c:	20 81       	ld	r18, Z
     75e:	31 81       	ldd	r19, Z+1	; 0x01
     760:	fc 01       	movw	r30, r24
     762:	31 83       	std	Z+1, r19	; 0x01
     764:	20 83       	st	Z, r18
     766:	ce 01       	movw	r24, r28
     768:	8d 5a       	subi	r24, 0xAD	; 173
     76a:	9f 4f       	sbci	r25, 0xFF	; 255
     76c:	fc 01       	movw	r30, r24
     76e:	80 81       	ld	r24, Z
     770:	91 81       	ldd	r25, Z+1	; 0x01
     772:	01 97       	sbiw	r24, 0x01	; 1
     774:	f1 f7       	brne	.-4      	; 0x772 <__stack+0x313>
     776:	9e 01       	movw	r18, r28
     778:	2d 5a       	subi	r18, 0xAD	; 173
     77a:	3f 4f       	sbci	r19, 0xFF	; 255
     77c:	f9 01       	movw	r30, r18
     77e:	91 83       	std	Z+1, r25	; 0x01
     780:	80 83       	st	Z, r24
        	_delay_ms(100);
    	EEPROM_writeString(0x0512,password_stored);
     782:	68 ef       	ldi	r22, 0xF8	; 248
     784:	70 e0       	ldi	r23, 0x00	; 0
     786:	82 e1       	ldi	r24, 0x12	; 18
     788:	95 e0       	ldi	r25, 0x05	; 5
     78a:	0e 94 1b 06 	call	0xc36	; 0xc36 <EEPROM_writeString>
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	a0 e2       	ldi	r26, 0x20	; 32
     794:	b1 e4       	ldi	r27, 0x41	; 65
     796:	8d 83       	std	Y+5, r24	; 0x05
     798:	9e 83       	std	Y+6, r25	; 0x06
     79a:	af 83       	std	Y+7, r26	; 0x07
     79c:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     79e:	8e 01       	movw	r16, r28
     7a0:	0f 5b       	subi	r16, 0xBF	; 191
     7a2:	1f 4f       	sbci	r17, 0xFF	; 255
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	4a ef       	ldi	r20, 0xFA	; 250
     7aa:	54 e4       	ldi	r21, 0x44	; 68
     7ac:	6d 81       	ldd	r22, Y+5	; 0x05
     7ae:	7e 81       	ldd	r23, Y+6	; 0x06
     7b0:	8f 81       	ldd	r24, Y+7	; 0x07
     7b2:	98 85       	ldd	r25, Y+8	; 0x08
     7b4:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     7b8:	dc 01       	movw	r26, r24
     7ba:	cb 01       	movw	r24, r22
     7bc:	f8 01       	movw	r30, r16
     7be:	80 83       	st	Z, r24
     7c0:	91 83       	std	Z+1, r25	; 0x01
     7c2:	a2 83       	std	Z+2, r26	; 0x02
     7c4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     7c6:	ce 01       	movw	r24, r28
     7c8:	8f 5b       	subi	r24, 0xBF	; 191
     7ca:	9f 4f       	sbci	r25, 0xFF	; 255
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	30 e0       	ldi	r19, 0x00	; 0
     7d0:	40 e8       	ldi	r20, 0x80	; 128
     7d2:	5f e3       	ldi	r21, 0x3F	; 63
     7d4:	fc 01       	movw	r30, r24
     7d6:	60 81       	ld	r22, Z
     7d8:	71 81       	ldd	r23, Z+1	; 0x01
     7da:	82 81       	ldd	r24, Z+2	; 0x02
     7dc:	93 81       	ldd	r25, Z+3	; 0x03
     7de:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     7e2:	88 23       	and	r24, r24
     7e4:	4c f4       	brge	.+18     	; 0x7f8 <__stack+0x399>
		__ticks = 1;
     7e6:	ce 01       	movw	r24, r28
     7e8:	8b 5b       	subi	r24, 0xBB	; 187
     7ea:	9f 4f       	sbci	r25, 0xFF	; 255
     7ec:	21 e0       	ldi	r18, 0x01	; 1
     7ee:	30 e0       	ldi	r19, 0x00	; 0
     7f0:	fc 01       	movw	r30, r24
     7f2:	31 83       	std	Z+1, r19	; 0x01
     7f4:	20 83       	st	Z, r18
     7f6:	69 c0       	rjmp	.+210    	; 0x8ca <__stack+0x46b>
	else if (__tmp > 65535)
     7f8:	ce 01       	movw	r24, r28
     7fa:	8f 5b       	subi	r24, 0xBF	; 191
     7fc:	9f 4f       	sbci	r25, 0xFF	; 255
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	3f ef       	ldi	r19, 0xFF	; 255
     802:	4f e7       	ldi	r20, 0x7F	; 127
     804:	57 e4       	ldi	r21, 0x47	; 71
     806:	fc 01       	movw	r30, r24
     808:	60 81       	ld	r22, Z
     80a:	71 81       	ldd	r23, Z+1	; 0x01
     80c:	82 81       	ldd	r24, Z+2	; 0x02
     80e:	93 81       	ldd	r25, Z+3	; 0x03
     810:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     814:	18 16       	cp	r1, r24
     816:	0c f0       	brlt	.+2      	; 0x81a <__stack+0x3bb>
     818:	46 c0       	rjmp	.+140    	; 0x8a6 <__stack+0x447>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     81a:	20 e0       	ldi	r18, 0x00	; 0
     81c:	30 e0       	ldi	r19, 0x00	; 0
     81e:	40 e2       	ldi	r20, 0x20	; 32
     820:	51 e4       	ldi	r21, 0x41	; 65
     822:	6d 81       	ldd	r22, Y+5	; 0x05
     824:	7e 81       	ldd	r23, Y+6	; 0x06
     826:	8f 81       	ldd	r24, Y+7	; 0x07
     828:	98 85       	ldd	r25, Y+8	; 0x08
     82a:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     82e:	dc 01       	movw	r26, r24
     830:	cb 01       	movw	r24, r22
     832:	8e 01       	movw	r16, r28
     834:	0b 5b       	subi	r16, 0xBB	; 187
     836:	1f 4f       	sbci	r17, 0xFF	; 255
     838:	bc 01       	movw	r22, r24
     83a:	cd 01       	movw	r24, r26
     83c:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     840:	dc 01       	movw	r26, r24
     842:	cb 01       	movw	r24, r22
     844:	f8 01       	movw	r30, r16
     846:	91 83       	std	Z+1, r25	; 0x01
     848:	80 83       	st	Z, r24
     84a:	24 c0       	rjmp	.+72     	; 0x894 <__stack+0x435>
     84c:	ce 01       	movw	r24, r28
     84e:	89 5b       	subi	r24, 0xB9	; 185
     850:	9f 4f       	sbci	r25, 0xFF	; 255
     852:	28 ec       	ldi	r18, 0xC8	; 200
     854:	30 e0       	ldi	r19, 0x00	; 0
     856:	fc 01       	movw	r30, r24
     858:	31 83       	std	Z+1, r19	; 0x01
     85a:	20 83       	st	Z, r18
     85c:	ce 01       	movw	r24, r28
     85e:	89 5b       	subi	r24, 0xB9	; 185
     860:	9f 4f       	sbci	r25, 0xFF	; 255
     862:	fc 01       	movw	r30, r24
     864:	80 81       	ld	r24, Z
     866:	91 81       	ldd	r25, Z+1	; 0x01
     868:	01 97       	sbiw	r24, 0x01	; 1
     86a:	f1 f7       	brne	.-4      	; 0x868 <__stack+0x409>
     86c:	9e 01       	movw	r18, r28
     86e:	29 5b       	subi	r18, 0xB9	; 185
     870:	3f 4f       	sbci	r19, 0xFF	; 255
     872:	f9 01       	movw	r30, r18
     874:	91 83       	std	Z+1, r25	; 0x01
     876:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     878:	ce 01       	movw	r24, r28
     87a:	8b 5b       	subi	r24, 0xBB	; 187
     87c:	9f 4f       	sbci	r25, 0xFF	; 255
     87e:	9e 01       	movw	r18, r28
     880:	2b 5b       	subi	r18, 0xBB	; 187
     882:	3f 4f       	sbci	r19, 0xFF	; 255
     884:	f9 01       	movw	r30, r18
     886:	20 81       	ld	r18, Z
     888:	31 81       	ldd	r19, Z+1	; 0x01
     88a:	21 50       	subi	r18, 0x01	; 1
     88c:	31 09       	sbc	r19, r1
     88e:	fc 01       	movw	r30, r24
     890:	31 83       	std	Z+1, r19	; 0x01
     892:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     894:	ce 01       	movw	r24, r28
     896:	8b 5b       	subi	r24, 0xBB	; 187
     898:	9f 4f       	sbci	r25, 0xFF	; 255
     89a:	fc 01       	movw	r30, r24
     89c:	80 81       	ld	r24, Z
     89e:	91 81       	ldd	r25, Z+1	; 0x01
     8a0:	89 2b       	or	r24, r25
     8a2:	a1 f6       	brne	.-88     	; 0x84c <__stack+0x3ed>
     8a4:	2c c0       	rjmp	.+88     	; 0x8fe <__stack+0x49f>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8a6:	8e 01       	movw	r16, r28
     8a8:	0b 5b       	subi	r16, 0xBB	; 187
     8aa:	1f 4f       	sbci	r17, 0xFF	; 255
     8ac:	ce 01       	movw	r24, r28
     8ae:	8f 5b       	subi	r24, 0xBF	; 191
     8b0:	9f 4f       	sbci	r25, 0xFF	; 255
     8b2:	fc 01       	movw	r30, r24
     8b4:	60 81       	ld	r22, Z
     8b6:	71 81       	ldd	r23, Z+1	; 0x01
     8b8:	82 81       	ldd	r24, Z+2	; 0x02
     8ba:	93 81       	ldd	r25, Z+3	; 0x03
     8bc:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     8c0:	dc 01       	movw	r26, r24
     8c2:	cb 01       	movw	r24, r22
     8c4:	f8 01       	movw	r30, r16
     8c6:	91 83       	std	Z+1, r25	; 0x01
     8c8:	80 83       	st	Z, r24
     8ca:	ce 01       	movw	r24, r28
     8cc:	87 5b       	subi	r24, 0xB7	; 183
     8ce:	9f 4f       	sbci	r25, 0xFF	; 255
     8d0:	9e 01       	movw	r18, r28
     8d2:	2b 5b       	subi	r18, 0xBB	; 187
     8d4:	3f 4f       	sbci	r19, 0xFF	; 255
     8d6:	f9 01       	movw	r30, r18
     8d8:	20 81       	ld	r18, Z
     8da:	31 81       	ldd	r19, Z+1	; 0x01
     8dc:	fc 01       	movw	r30, r24
     8de:	31 83       	std	Z+1, r19	; 0x01
     8e0:	20 83       	st	Z, r18
     8e2:	ce 01       	movw	r24, r28
     8e4:	87 5b       	subi	r24, 0xB7	; 183
     8e6:	9f 4f       	sbci	r25, 0xFF	; 255
     8e8:	fc 01       	movw	r30, r24
     8ea:	80 81       	ld	r24, Z
     8ec:	91 81       	ldd	r25, Z+1	; 0x01
     8ee:	01 97       	sbiw	r24, 0x01	; 1
     8f0:	f1 f7       	brne	.-4      	; 0x8ee <__stack+0x48f>
     8f2:	9e 01       	movw	r18, r28
     8f4:	27 5b       	subi	r18, 0xB7	; 183
     8f6:	3f 4f       	sbci	r19, 0xFF	; 255
     8f8:	f9 01       	movw	r30, r18
     8fa:	91 83       	std	Z+1, r25	; 0x01
     8fc:	80 83       	st	Z, r24
    	_delay_ms(10);
    	EEPROM_writeByte(0X0011,0xAA);
     8fe:	6a ea       	ldi	r22, 0xAA	; 170
     900:	81 e1       	ldi	r24, 0x11	; 17
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	0e 94 7f 05 	call	0xafe	; 0xafe <EEPROM_writeByte>
    	password_stored_flag=0xAA;
     908:	8a ea       	ldi	r24, 0xAA	; 170
     90a:	80 93 ee 00 	sts	0x00EE, r24	; 0x8000ee <password_stored_flag>
    	set_password_now_flag=0xAA;
     90e:	8a ea       	ldi	r24, 0xAA	; 170
     910:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <set_password_now_flag>
    	if(UART_receiveByte()=='o')
     914:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <UART_receiveByte>
     918:	8f 36       	cpi	r24, 0x6F	; 111
     91a:	09 f0       	breq	.+2      	; 0x91e <__stack+0x4bf>
     91c:	2f cc       	rjmp	.-1954   	; 0x17c <main+0x68>
    		 motor_run();
     91e:	0e 94 b0 04 	call	0x960	; 0x960 <motor_run>

    	}

    }
     922:	2c cc       	rjmp	.-1960   	; 0x17c <main+0x68>

00000924 <timer_set>:
 *      Author: hesham
 */
#include"actuators.h"

void timer_set(void)
{
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
     928:	cd b7       	in	r28, 0x3d	; 61
     92a:	de b7       	in	r29, 0x3e	; 62
timer_config.timerNumber=1;
     92c:	81 e0       	ldi	r24, 0x01	; 1
     92e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <timer_config>
		strcpy(timer_config.mode,"compare");
     932:	88 e0       	ldi	r24, 0x08	; 8
     934:	ed e6       	ldi	r30, 0x6D	; 109
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	ad e0       	ldi	r26, 0x0D	; 13
     93a:	b1 e0       	ldi	r27, 0x01	; 1
     93c:	01 90       	ld	r0, Z+
     93e:	0d 92       	st	X+, r0
     940:	8a 95       	dec	r24
     942:	e1 f7       	brne	.-8      	; 0x93c <timer_set+0x18>
		timer_config.prescaler=1024;
     944:	80 e0       	ldi	r24, 0x00	; 0
     946:	94 e0       	ldi	r25, 0x04	; 4
     948:	90 93 22 01 	sts	0x0122, r25	; 0x800122 <timer_config+0x16>
     94c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <timer_config+0x15>
		TIMER_init(&timer_config);
     950:	8c e0       	ldi	r24, 0x0C	; 12
     952:	91 e0       	ldi	r25, 0x01	; 1
     954:	0e 94 67 09 	call	0x12ce	; 0x12ce <TIMER_init>
}
     958:	00 00       	nop
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	08 95       	ret

00000960 <motor_run>:


void motor_run(void)
{
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	cd b7       	in	r28, 0x3d	; 61
     966:	de b7       	in	r29, 0x3e	; 62

TIMER_setCompare(8000);
     968:	80 e4       	ldi	r24, 0x40	; 64
     96a:	9f e1       	ldi	r25, 0x1F	; 31
     96c:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <TIMER_setCompare>
TIMER_setCallBackPtr(change_motor_dirction);
     970:	80 ec       	ldi	r24, 0xC0	; 192
     972:	94 e0       	ldi	r25, 0x04	; 4
     974:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <TIMER_setCallBackPtr>


}
     978:	00 00       	nop
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	08 95       	ret

00000980 <change_motor_dirction>:
void change_motor_dirction(void)
{
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	cd b7       	in	r28, 0x3d	; 61
     986:	de b7       	in	r29, 0x3e	; 62

	static uint8 count=0;
	if(count==0)
     988:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     98c:	88 23       	and	r24, r24
     98e:	29 f5       	brne	.+74     	; 0x9da <change_motor_dirction+0x5a>
	{
		DDRB|=(1<<0)|(1<<1);
     990:	87 e3       	ldi	r24, 0x37	; 55
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	27 e3       	ldi	r18, 0x37	; 55
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	f9 01       	movw	r30, r18
     99a:	20 81       	ld	r18, Z
     99c:	23 60       	ori	r18, 0x03	; 3
     99e:	fc 01       	movw	r30, r24
     9a0:	20 83       	st	Z, r18
		PORTB&=~(1<<0)&~(1<<1);
     9a2:	88 e3       	ldi	r24, 0x38	; 56
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	28 e3       	ldi	r18, 0x38	; 56
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	f9 01       	movw	r30, r18
     9ac:	20 81       	ld	r18, Z
     9ae:	2c 7f       	andi	r18, 0xFC	; 252
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
		CLEAR_BIT(PORTB,1);
     9b4:	88 e3       	ldi	r24, 0x38	; 56
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	28 e3       	ldi	r18, 0x38	; 56
     9ba:	30 e0       	ldi	r19, 0x00	; 0
     9bc:	f9 01       	movw	r30, r18
     9be:	20 81       	ld	r18, Z
     9c0:	2d 7f       	andi	r18, 0xFD	; 253
     9c2:	fc 01       	movw	r30, r24
     9c4:	20 83       	st	Z, r18
		SET_BIT(PORTB,0);
     9c6:	88 e3       	ldi	r24, 0x38	; 56
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	28 e3       	ldi	r18, 0x38	; 56
     9cc:	30 e0       	ldi	r19, 0x00	; 0
     9ce:	f9 01       	movw	r30, r18
     9d0:	20 81       	ld	r18, Z
     9d2:	21 60       	ori	r18, 0x01	; 1
     9d4:	fc 01       	movw	r30, r24
     9d6:	20 83       	st	Z, r18
     9d8:	24 c0       	rjmp	.+72     	; 0xa22 <change_motor_dirction+0xa2>
	}
	else if(count>=2)
     9da:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     9de:	82 30       	cpi	r24, 0x02	; 2
     9e0:	60 f0       	brcs	.+24     	; 0x9fa <change_motor_dirction+0x7a>
{
	PORTB&=~(1<<0)&~(1<<1);
     9e2:	88 e3       	ldi	r24, 0x38	; 56
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	28 e3       	ldi	r18, 0x38	; 56
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	f9 01       	movw	r30, r18
     9ec:	20 81       	ld	r18, Z
     9ee:	2c 7f       	andi	r18, 0xFC	; 252
     9f0:	fc 01       	movw	r30, r24
     9f2:	20 83       	st	Z, r18

	TIMER_stop();
     9f4:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <TIMER_stop>
     9f8:	14 c0       	rjmp	.+40     	; 0xa22 <change_motor_dirction+0xa2>
}
else
{
	TOGGLE_BIT(PORTB,1);
     9fa:	88 e3       	ldi	r24, 0x38	; 56
     9fc:	90 e0       	ldi	r25, 0x00	; 0
     9fe:	28 e3       	ldi	r18, 0x38	; 56
     a00:	30 e0       	ldi	r19, 0x00	; 0
     a02:	f9 01       	movw	r30, r18
     a04:	30 81       	ld	r19, Z
     a06:	22 e0       	ldi	r18, 0x02	; 2
     a08:	23 27       	eor	r18, r19
     a0a:	fc 01       	movw	r30, r24
     a0c:	20 83       	st	Z, r18
	TOGGLE_BIT(PORTB,0);
     a0e:	88 e3       	ldi	r24, 0x38	; 56
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	28 e3       	ldi	r18, 0x38	; 56
     a14:	30 e0       	ldi	r19, 0x00	; 0
     a16:	f9 01       	movw	r30, r18
     a18:	30 81       	ld	r19, Z
     a1a:	21 e0       	ldi	r18, 0x01	; 1
     a1c:	23 27       	eor	r18, r19
     a1e:	fc 01       	movw	r30, r24
     a20:	20 83       	st	Z, r18
}
	count++;
     a22:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     a26:	8f 5f       	subi	r24, 0xFF	; 255
     a28:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <count.1911>

}
     a2c:	00 00       	nop
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	08 95       	ret

00000a34 <buzzer>:
void buzzer(void)
{
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	cd b7       	in	r28, 0x3d	; 61
     a3a:	de b7       	in	r29, 0x3e	; 62

	TIMER_setCompare(60000);
     a3c:	80 e6       	ldi	r24, 0x60	; 96
     a3e:	9a ee       	ldi	r25, 0xEA	; 234
     a40:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <TIMER_setCompare>
	TIMER_setCallBackPtr(buzzer_call);
     a44:	8a e2       	ldi	r24, 0x2A	; 42
     a46:	95 e0       	ldi	r25, 0x05	; 5
     a48:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <TIMER_setCallBackPtr>
}
     a4c:	00 00       	nop
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	08 95       	ret

00000a54 <buzzer_call>:
void buzzer_call(void)
{	static uint8 count=0;
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	cd b7       	in	r28, 0x3d	; 61
     a5a:	de b7       	in	r29, 0x3e	; 62
if(count==0)
     a5c:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     a60:	88 23       	and	r24, r24
     a62:	99 f4       	brne	.+38     	; 0xa8a <buzzer_call+0x36>
{
	SET_BIT(DDRC,5);
     a64:	84 e3       	ldi	r24, 0x34	; 52
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	24 e3       	ldi	r18, 0x34	; 52
     a6a:	30 e0       	ldi	r19, 0x00	; 0
     a6c:	f9 01       	movw	r30, r18
     a6e:	20 81       	ld	r18, Z
     a70:	20 62       	ori	r18, 0x20	; 32
     a72:	fc 01       	movw	r30, r24
     a74:	20 83       	st	Z, r18
		SET_BIT(PORTC,5);
     a76:	85 e3       	ldi	r24, 0x35	; 53
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	25 e3       	ldi	r18, 0x35	; 53
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	f9 01       	movw	r30, r18
     a80:	20 81       	ld	r18, Z
     a82:	20 62       	ori	r18, 0x20	; 32
     a84:	fc 01       	movw	r30, r24
     a86:	20 83       	st	Z, r18
     a88:	14 c0       	rjmp	.+40     	; 0xab2 <buzzer_call+0x5e>
}


else if(count==8)
     a8a:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     a8e:	88 30       	cpi	r24, 0x08	; 8
     a90:	81 f4       	brne	.+32     	; 0xab2 <buzzer_call+0x5e>
{
	CLEAR_BIT(PORTC,5);
     a92:	85 e3       	ldi	r24, 0x35	; 53
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	25 e3       	ldi	r18, 0x35	; 53
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	f9 01       	movw	r30, r18
     a9c:	20 81       	ld	r18, Z
     a9e:	2f 7d       	andi	r18, 0xDF	; 223
     aa0:	fc 01       	movw	r30, r24
     aa2:	20 83       	st	Z, r18
	buzzer_flag=1;
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <buzzer_flag>
	block_buzzer_scope=0;
     aaa:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <block_buzzer_scope>
	TIMER_stop();
     aae:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <TIMER_stop>
}
count++;
     ab2:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     ab6:	8f 5f       	subi	r24, 0xFF	; 255
     ab8:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <count.1918>


}
     abc:	00 00       	nop
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	08 95       	ret

00000ac4 <EEPROM_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void EEPROM_init(void)
{ /* determine the parameter which will pass to I2C driver to communicate with EEPROM */
     ac4:	cf 93       	push	r28
     ac6:	df 93       	push	r29
     ac8:	cd b7       	in	r28, 0x3d	; 61
     aca:	de b7       	in	r29, 0x3e	; 62
	TWI_config.baudRate=400000; /* baud rate which EEPROM work on */
     acc:	80 e8       	ldi	r24, 0x80	; 128
     ace:	9a e1       	ldi	r25, 0x1A	; 26
     ad0:	a6 e0       	ldi	r26, 0x06	; 6
     ad2:	b0 e0       	ldi	r27, 0x00	; 0
     ad4:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <TWI_config>
     ad8:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <TWI_config+0x1>
     adc:	a0 93 50 01 	sts	0x0150, r26	; 0x800150 <TWI_config+0x2>
     ae0:	b0 93 51 01 	sts	0x0151, r27	; 0x800151 <TWI_config+0x3>
	TWI_config.prescasler=0;
     ae4:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <TWI_config+0x4>
	TWI_config.slave_address=0b00001011; /* the address of master when receive data from (as slave) form other slaves */
     ae8:	8b e0       	ldi	r24, 0x0B	; 11
     aea:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <TWI_config+0x5>

	/* passing I2C configuration structure by reference to I2C initialization function */
TWI_init(&TWI_config);
     aee:	8e e4       	ldi	r24, 0x4E	; 78
     af0:	91 e0       	ldi	r25, 0x01	; 1
     af2:	0e 94 1e 07 	call	0xe3c	; 0xe3c <TWI_init>
}
     af6:	00 00       	nop
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <EEPROM_writeByte>:

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	00 d0       	rcall	.+0      	; 0xb04 <EEPROM_writeByte+0x6>
     b04:	1f 92       	push	r1
     b06:	cd b7       	in	r28, 0x3d	; 61
     b08:	de b7       	in	r29, 0x3e	; 62
     b0a:	9a 83       	std	Y+2, r25	; 0x02
     b0c:	89 83       	std	Y+1, r24	; 0x01
     b0e:	6b 83       	std	Y+3, r22	; 0x03
/* send start bit */
	TWI_start();
     b10:	0e 94 a6 07 	call	0xf4c	; 0xf4c <TWI_start>
	if(TWI_getStatus()!=TW_START) /* check the start done */
     b14:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     b18:	88 30       	cpi	r24, 0x08	; 8
     b1a:	11 f0       	breq	.+4      	; 0xb20 <EEPROM_writeByte+0x22>
	return ERROR; /* return error if doenst send start bit */
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	27 c0       	rjmp	.+78     	; 0xb6e <EEPROM_writeByte+0x70>

	/* to avoid sending 3 bytes 1  byte for EEPROM address  and 2 bytes  for memory location address
	 * combine address of EEPROM address (in our case 24c16 EEPROM----->>0XA0 ) and last 3 bits of memory location address
	 * memory location address for 24c16 EEPROM is 11 bits as memory size 2kByte and the memory width is 1 K byte
	 */
	TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     b20:	89 81       	ldd	r24, Y+1	; 0x01
     b22:	9a 81       	ldd	r25, Y+2	; 0x02
     b24:	88 27       	eor	r24, r24
     b26:	97 70       	andi	r25, 0x07	; 7
     b28:	88 0f       	add	r24, r24
     b2a:	89 2f       	mov	r24, r25
     b2c:	88 1f       	adc	r24, r24
     b2e:	99 0b       	sbc	r25, r25
     b30:	91 95       	neg	r25
     b32:	80 6a       	ori	r24, 0xA0	; 160
     b34:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
	if(TWI_getStatus()!=TW_MT_SLA_W_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b38:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     b3c:	88 31       	cpi	r24, 0x18	; 24
     b3e:	11 f0       	breq	.+4      	; 0xb44 <EEPROM_writeByte+0x46>
		return ERROR;
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	15 c0       	rjmp	.+42     	; 0xb6e <EEPROM_writeByte+0x70>

/* send the remaining of memory location address =11-3=8 bits */
	TWI_write((uint8)u16addr);
     b44:	89 81       	ldd	r24, Y+1	; 0x01
     b46:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) DATA (DATA) acknowledge (ACK) */
     b4a:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     b4e:	88 32       	cpi	r24, 0x28	; 40
     b50:	11 f0       	breq	.+4      	; 0xb56 <EEPROM_writeByte+0x58>
			return ERROR;
     b52:	80 e0       	ldi	r24, 0x00	; 0
     b54:	0c c0       	rjmp	.+24     	; 0xb6e <EEPROM_writeByte+0x70>


	TWI_write(u8data);
     b56:	8b 81       	ldd	r24, Y+3	; 0x03
     b58:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b5c:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     b60:	88 32       	cpi	r24, 0x28	; 40
     b62:	11 f0       	breq	.+4      	; 0xb68 <EEPROM_writeByte+0x6a>
			return ERROR;
     b64:	80 e0       	ldi	r24, 0x00	; 0
     b66:	03 c0       	rjmp	.+6      	; 0xb6e <EEPROM_writeByte+0x70>

	TWI_stop(); /* end the frame */
     b68:	0e 94 ba 07 	call	0xf74	; 0xf74 <TWI_stop>
	return SUCCESS; /* send success if the frame is completed by reach this line */
     b6c:	81 e0       	ldi	r24, 0x01	; 1
}
     b6e:	0f 90       	pop	r0
     b70:	0f 90       	pop	r0
     b72:	0f 90       	pop	r0
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	00 d0       	rcall	.+0      	; 0xb80 <EEPROM_readByte+0x6>
     b80:	00 d0       	rcall	.+0      	; 0xb82 <EEPROM_readByte+0x8>
     b82:	cd b7       	in	r28, 0x3d	; 61
     b84:	de b7       	in	r29, 0x3e	; 62
     b86:	9a 83       	std	Y+2, r25	; 0x02
     b88:	89 83       	std	Y+1, r24	; 0x01
     b8a:	7c 83       	std	Y+4, r23	; 0x04
     b8c:	6b 83       	std	Y+3, r22	; 0x03
	TWI_start();
     b8e:	0e 94 a6 07 	call	0xf4c	; 0xf4c <TWI_start>
		if(TWI_getStatus()!=TW_START)
     b92:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     b96:	88 30       	cpi	r24, 0x08	; 8
     b98:	11 f0       	breq	.+4      	; 0xb9e <EEPROM_readByte+0x24>
		return ERROR;
     b9a:	80 e0       	ldi	r24, 0x00	; 0
     b9c:	45 c0       	rjmp	.+138    	; 0xc28 <EEPROM_readByte+0xae>

		TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
     ba2:	88 27       	eor	r24, r24
     ba4:	97 70       	andi	r25, 0x07	; 7
     ba6:	88 0f       	add	r24, r24
     ba8:	89 2f       	mov	r24, r25
     baa:	88 1f       	adc	r24, r24
     bac:	99 0b       	sbc	r25, r25
     bae:	91 95       	neg	r25
     bb0:	80 6a       	ori	r24, 0xA0	; 160
     bb2:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_W_ACK)
     bb6:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     bba:	88 31       	cpi	r24, 0x18	; 24
     bbc:	11 f0       	breq	.+4      	; 0xbc2 <EEPROM_readByte+0x48>
			return ERROR;
     bbe:	80 e0       	ldi	r24, 0x00	; 0
     bc0:	33 c0       	rjmp	.+102    	; 0xc28 <EEPROM_readByte+0xae>


		TWI_write((uint8)u16addr);
     bc2:	89 81       	ldd	r24, Y+1	; 0x01
     bc4:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
		if(TWI_getStatus()!=TW_MT_DATA_ACK)
     bc8:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     bcc:	88 32       	cpi	r24, 0x28	; 40
     bce:	11 f0       	breq	.+4      	; 0xbd4 <EEPROM_readByte+0x5a>
				return ERROR;
     bd0:	80 e0       	ldi	r24, 0x00	; 0
     bd2:	2a c0       	rjmp	.+84     	; 0xc28 <EEPROM_readByte+0xae>

/* repeat start the frame as in this case master will read from the slave */
				TWI_start();
     bd4:	0e 94 a6 07 	call	0xf4c	; 0xf4c <TWI_start>
		if(TWI_getStatus()!=TW_REP_START) /* check the repeated start done */
     bd8:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     bdc:	80 31       	cpi	r24, 0x10	; 16
     bde:	11 f0       	breq	.+4      	; 0xbe4 <EEPROM_readByte+0x6a>
						return ERROR;
     be0:	80 e0       	ldi	r24, 0x00	; 0
     be2:	22 c0       	rjmp	.+68     	; 0xc28 <EEPROM_readByte+0xae>
/* send the address of EEPROM as slave and set the less significant bit to make master read from the slave */
		TWI_write((uint8)((0xA0)|((u16addr&0X0700)>>7)|1));
     be4:	89 81       	ldd	r24, Y+1	; 0x01
     be6:	9a 81       	ldd	r25, Y+2	; 0x02
     be8:	88 27       	eor	r24, r24
     bea:	97 70       	andi	r25, 0x07	; 7
     bec:	88 0f       	add	r24, r24
     bee:	89 2f       	mov	r24, r25
     bf0:	88 1f       	adc	r24, r24
     bf2:	99 0b       	sbc	r25, r25
     bf4:	91 95       	neg	r25
     bf6:	81 6a       	ori	r24, 0xA1	; 161
     bf8:	0e 94 c7 07 	call	0xf8e	; 0xf8e <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_R_ACK)  /* check the master (MT) send  to slave (SLA) read (R) acknowledge (ACK) */
     bfc:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     c00:	80 34       	cpi	r24, 0x40	; 64
     c02:	11 f0       	breq	.+4      	; 0xc08 <EEPROM_readByte+0x8e>
						return ERROR;
     c04:	80 e0       	ldi	r24, 0x00	; 0
     c06:	10 c0       	rjmp	.+32     	; 0xc28 <EEPROM_readByte+0xae>


			*u8data=TWI_read_with_NACK(); /* read the byte */
     c08:	0e 94 fa 07 	call	0xff4	; 0xff4 <TWI_read_with_NACK>
     c0c:	28 2f       	mov	r18, r24
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	fc 01       	movw	r30, r24
     c14:	20 83       	st	Z, r18
			if(TWI_getStatus()!=TW_MR_DATA_NACK) /* check the master (MT) read the byte  from slave (SLA) read (DATA) acknowledge (ACK) */
     c16:	0e 94 11 08 	call	0x1022	; 0x1022 <TWI_getStatus>
     c1a:	88 35       	cpi	r24, 0x58	; 88
     c1c:	11 f0       	breq	.+4      	; 0xc22 <EEPROM_readByte+0xa8>
					return ERROR;
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	03 c0       	rjmp	.+6      	; 0xc28 <EEPROM_readByte+0xae>

			TWI_stop();
     c22:	0e 94 ba 07 	call	0xf74	; 0xf74 <TWI_stop>
			return SUCCESS;
     c26:	81 e0       	ldi	r24, 0x01	; 1

}
     c28:	0f 90       	pop	r0
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
     c2e:	0f 90       	pop	r0
     c30:	df 91       	pop	r29
     c32:	cf 91       	pop	r28
     c34:	08 95       	ret

00000c36 <EEPROM_writeString>:
uint8 EEPROM_writeString(uint16 u16addr, uint8* str)
{
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	63 97       	sbiw	r28, 0x13	; 19
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	99 8b       	std	Y+17, r25	; 0x11
     c4c:	88 8b       	std	Y+16, r24	; 0x10
     c4e:	7b 8b       	std	Y+19, r23	; 0x13
     c50:	6a 8b       	std	Y+18, r22	; 0x12
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
     c52:	19 82       	std	Y+1, r1	; 0x01
	for( i=0;str[i]!='\0';i++)
     c54:	19 82       	std	Y+1, r1	; 0x01
     c56:	88 c0       	rjmp	.+272    	; 0xd68 <EEPROM_writeString+0x132>
{

/* increase the address by base +i */
	EEPROM_writeByte(u16addr+i,str[i]);
     c58:	89 81       	ldd	r24, Y+1	; 0x01
     c5a:	88 2f       	mov	r24, r24
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	2a 89       	ldd	r18, Y+18	; 0x12
     c60:	3b 89       	ldd	r19, Y+19	; 0x13
     c62:	82 0f       	add	r24, r18
     c64:	93 1f       	adc	r25, r19
     c66:	fc 01       	movw	r30, r24
     c68:	40 81       	ld	r20, Z
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	28 2f       	mov	r18, r24
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	88 89       	ldd	r24, Y+16	; 0x10
     c72:	99 89       	ldd	r25, Y+17	; 0x11
     c74:	82 0f       	add	r24, r18
     c76:	93 1f       	adc	r25, r19
     c78:	64 2f       	mov	r22, r20
     c7a:	0e 94 7f 05 	call	0xafe	; 0xafe <EEPROM_writeByte>
     c7e:	80 e0       	ldi	r24, 0x00	; 0
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	a0 e2       	ldi	r26, 0x20	; 32
     c84:	b1 e4       	ldi	r27, 0x41	; 65
     c86:	8a 83       	std	Y+2, r24	; 0x02
     c88:	9b 83       	std	Y+3, r25	; 0x03
     c8a:	ac 83       	std	Y+4, r26	; 0x04
     c8c:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     c8e:	20 e0       	ldi	r18, 0x00	; 0
     c90:	30 e0       	ldi	r19, 0x00	; 0
     c92:	4a ef       	ldi	r20, 0xFA	; 250
     c94:	54 e4       	ldi	r21, 0x44	; 68
     c96:	6a 81       	ldd	r22, Y+2	; 0x02
     c98:	7b 81       	ldd	r23, Y+3	; 0x03
     c9a:	8c 81       	ldd	r24, Y+4	; 0x04
     c9c:	9d 81       	ldd	r25, Y+5	; 0x05
     c9e:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     ca2:	dc 01       	movw	r26, r24
     ca4:	cb 01       	movw	r24, r22
     ca6:	8e 83       	std	Y+6, r24	; 0x06
     ca8:	9f 83       	std	Y+7, r25	; 0x07
     caa:	a8 87       	std	Y+8, r26	; 0x08
     cac:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
     cae:	20 e0       	ldi	r18, 0x00	; 0
     cb0:	30 e0       	ldi	r19, 0x00	; 0
     cb2:	40 e8       	ldi	r20, 0x80	; 128
     cb4:	5f e3       	ldi	r21, 0x3F	; 63
     cb6:	6e 81       	ldd	r22, Y+6	; 0x06
     cb8:	7f 81       	ldd	r23, Y+7	; 0x07
     cba:	88 85       	ldd	r24, Y+8	; 0x08
     cbc:	99 85       	ldd	r25, Y+9	; 0x09
     cbe:	0e 94 c4 10 	call	0x2188	; 0x2188 <__cmpsf2>
     cc2:	88 23       	and	r24, r24
     cc4:	2c f4       	brge	.+10     	; 0xcd0 <EEPROM_writeString+0x9a>
		__ticks = 1;
     cc6:	81 e0       	ldi	r24, 0x01	; 1
     cc8:	90 e0       	ldi	r25, 0x00	; 0
     cca:	9b 87       	std	Y+11, r25	; 0x0b
     ccc:	8a 87       	std	Y+10, r24	; 0x0a
     cce:	3f c0       	rjmp	.+126    	; 0xd4e <EEPROM_writeString+0x118>
	else if (__tmp > 65535)
     cd0:	20 e0       	ldi	r18, 0x00	; 0
     cd2:	3f ef       	ldi	r19, 0xFF	; 255
     cd4:	4f e7       	ldi	r20, 0x7F	; 127
     cd6:	57 e4       	ldi	r21, 0x47	; 71
     cd8:	6e 81       	ldd	r22, Y+6	; 0x06
     cda:	7f 81       	ldd	r23, Y+7	; 0x07
     cdc:	88 85       	ldd	r24, Y+8	; 0x08
     cde:	99 85       	ldd	r25, Y+9	; 0x09
     ce0:	0e 94 1c 12 	call	0x2438	; 0x2438 <__gesf2>
     ce4:	18 16       	cp	r1, r24
     ce6:	4c f5       	brge	.+82     	; 0xd3a <EEPROM_writeString+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	40 e2       	ldi	r20, 0x20	; 32
     cee:	51 e4       	ldi	r21, 0x41	; 65
     cf0:	6a 81       	ldd	r22, Y+2	; 0x02
     cf2:	7b 81       	ldd	r23, Y+3	; 0x03
     cf4:	8c 81       	ldd	r24, Y+4	; 0x04
     cf6:	9d 81       	ldd	r25, Y+5	; 0x05
     cf8:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
     cfc:	dc 01       	movw	r26, r24
     cfe:	cb 01       	movw	r24, r22
     d00:	bc 01       	movw	r22, r24
     d02:	cd 01       	movw	r24, r26
     d04:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     d08:	dc 01       	movw	r26, r24
     d0a:	cb 01       	movw	r24, r22
     d0c:	9b 87       	std	Y+11, r25	; 0x0b
     d0e:	8a 87       	std	Y+10, r24	; 0x0a
     d10:	0f c0       	rjmp	.+30     	; 0xd30 <EEPROM_writeString+0xfa>
     d12:	88 ec       	ldi	r24, 0xC8	; 200
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	9d 87       	std	Y+13, r25	; 0x0d
     d18:	8c 87       	std	Y+12, r24	; 0x0c
     d1a:	8c 85       	ldd	r24, Y+12	; 0x0c
     d1c:	9d 85       	ldd	r25, Y+13	; 0x0d
     d1e:	01 97       	sbiw	r24, 0x01	; 1
     d20:	f1 f7       	brne	.-4      	; 0xd1e <EEPROM_writeString+0xe8>
     d22:	9d 87       	std	Y+13, r25	; 0x0d
     d24:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d26:	8a 85       	ldd	r24, Y+10	; 0x0a
     d28:	9b 85       	ldd	r25, Y+11	; 0x0b
     d2a:	01 97       	sbiw	r24, 0x01	; 1
     d2c:	9b 87       	std	Y+11, r25	; 0x0b
     d2e:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d30:	8a 85       	ldd	r24, Y+10	; 0x0a
     d32:	9b 85       	ldd	r25, Y+11	; 0x0b
     d34:	89 2b       	or	r24, r25
     d36:	69 f7       	brne	.-38     	; 0xd12 <EEPROM_writeString+0xdc>
     d38:	14 c0       	rjmp	.+40     	; 0xd62 <EEPROM_writeString+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d3a:	6e 81       	ldd	r22, Y+6	; 0x06
     d3c:	7f 81       	ldd	r23, Y+7	; 0x07
     d3e:	88 85       	ldd	r24, Y+8	; 0x08
     d40:	99 85       	ldd	r25, Y+9	; 0x09
     d42:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     d46:	dc 01       	movw	r26, r24
     d48:	cb 01       	movw	r24, r22
     d4a:	9b 87       	std	Y+11, r25	; 0x0b
     d4c:	8a 87       	std	Y+10, r24	; 0x0a
     d4e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d50:	9b 85       	ldd	r25, Y+11	; 0x0b
     d52:	9f 87       	std	Y+15, r25	; 0x0f
     d54:	8e 87       	std	Y+14, r24	; 0x0e
     d56:	8e 85       	ldd	r24, Y+14	; 0x0e
     d58:	9f 85       	ldd	r25, Y+15	; 0x0f
     d5a:	01 97       	sbiw	r24, 0x01	; 1
     d5c:	f1 f7       	brne	.-4      	; 0xd5a <EEPROM_writeString+0x124>
     d5e:	9f 87       	std	Y+15, r25	; 0x0f
     d60:	8e 87       	std	Y+14, r24	; 0x0e
{
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
	for( i=0;str[i]!='\0';i++)
     d62:	89 81       	ldd	r24, Y+1	; 0x01
     d64:	8f 5f       	subi	r24, 0xFF	; 255
     d66:	89 83       	std	Y+1, r24	; 0x01
     d68:	89 81       	ldd	r24, Y+1	; 0x01
     d6a:	88 2f       	mov	r24, r24
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	2a 89       	ldd	r18, Y+18	; 0x12
     d70:	3b 89       	ldd	r19, Y+19	; 0x13
     d72:	82 0f       	add	r24, r18
     d74:	93 1f       	adc	r25, r19
     d76:	fc 01       	movw	r30, r24
     d78:	80 81       	ld	r24, Z
     d7a:	88 23       	and	r24, r24
     d7c:	09 f0       	breq	.+2      	; 0xd80 <EEPROM_writeString+0x14a>
     d7e:	6c cf       	rjmp	.-296    	; 0xc58 <EEPROM_writeString+0x22>
	EEPROM_writeByte(u16addr+i,str[i]);
	_delay_ms(10);

}

	EEPROM_writeByte(u16addr+i,'\0');
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	28 2f       	mov	r18, r24
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	88 89       	ldd	r24, Y+16	; 0x10
     d88:	99 89       	ldd	r25, Y+17	; 0x11
     d8a:	82 0f       	add	r24, r18
     d8c:	93 1f       	adc	r25, r19
     d8e:	60 e0       	ldi	r22, 0x00	; 0
     d90:	0e 94 7f 05 	call	0xafe	; 0xafe <EEPROM_writeByte>


}
     d94:	00 00       	nop
     d96:	63 96       	adiw	r28, 0x13	; 19
     d98:	0f b6       	in	r0, 0x3f	; 63
     d9a:	f8 94       	cli
     d9c:	de bf       	out	0x3e, r29	; 62
     d9e:	0f be       	out	0x3f, r0	; 63
     da0:	cd bf       	out	0x3d, r28	; 61
     da2:	df 91       	pop	r29
     da4:	cf 91       	pop	r28
     da6:	08 95       	ret

00000da8 <EEPROM_readString>:
uint8 EEPROM_readString(uint16 u16addr, uint8 *str)
{
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	00 d0       	rcall	.+0      	; 0xdae <EEPROM_readString+0x6>
     dae:	00 d0       	rcall	.+0      	; 0xdb0 <EEPROM_readString+0x8>
     db0:	1f 92       	push	r1
     db2:	cd b7       	in	r28, 0x3d	; 61
     db4:	de b7       	in	r29, 0x3e	; 62
     db6:	9b 83       	std	Y+3, r25	; 0x03
     db8:	8a 83       	std	Y+2, r24	; 0x02
     dba:	7d 83       	std	Y+5, r23	; 0x05
     dbc:	6c 83       	std	Y+4, r22	; 0x04
	then enter the while loop  and receive byte by byte  until reach null
	put null '\0' at the end of string
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
     dbe:	19 82       	std	Y+1, r1	; 0x01
		EEPROM_readByte(u16addr, &str[i]);
     dc0:	89 81       	ldd	r24, Y+1	; 0x01
     dc2:	88 2f       	mov	r24, r24
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	2c 81       	ldd	r18, Y+4	; 0x04
     dc8:	3d 81       	ldd	r19, Y+5	; 0x05
     dca:	28 0f       	add	r18, r24
     dcc:	39 1f       	adc	r19, r25
     dce:	8a 81       	ldd	r24, Y+2	; 0x02
     dd0:	9b 81       	ldd	r25, Y+3	; 0x03
     dd2:	b9 01       	movw	r22, r18
     dd4:	0e 94 bd 05 	call	0xb7a	; 0xb7a <EEPROM_readByte>
		while(str[i]!='\0')
     dd8:	14 c0       	rjmp	.+40     	; 0xe02 <EEPROM_readString+0x5a>
		{u16addr++;
     dda:	8a 81       	ldd	r24, Y+2	; 0x02
     ddc:	9b 81       	ldd	r25, Y+3	; 0x03
     dde:	01 96       	adiw	r24, 0x01	; 1
     de0:	9b 83       	std	Y+3, r25	; 0x03
     de2:	8a 83       	std	Y+2, r24	; 0x02
			i++;
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	8f 5f       	subi	r24, 0xFF	; 255
     de8:	89 83       	std	Y+1, r24	; 0x01
			EEPROM_readByte(u16addr, &str[i]);
     dea:	89 81       	ldd	r24, Y+1	; 0x01
     dec:	88 2f       	mov	r24, r24
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	2c 81       	ldd	r18, Y+4	; 0x04
     df2:	3d 81       	ldd	r19, Y+5	; 0x05
     df4:	28 0f       	add	r18, r24
     df6:	39 1f       	adc	r19, r25
     df8:	8a 81       	ldd	r24, Y+2	; 0x02
     dfa:	9b 81       	ldd	r25, Y+3	; 0x03
     dfc:	b9 01       	movw	r22, r18
     dfe:	0e 94 bd 05 	call	0xb7a	; 0xb7a <EEPROM_readByte>
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
		EEPROM_readByte(u16addr, &str[i]);
		while(str[i]!='\0')
     e02:	89 81       	ldd	r24, Y+1	; 0x01
     e04:	88 2f       	mov	r24, r24
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	2c 81       	ldd	r18, Y+4	; 0x04
     e0a:	3d 81       	ldd	r19, Y+5	; 0x05
     e0c:	82 0f       	add	r24, r18
     e0e:	93 1f       	adc	r25, r19
     e10:	fc 01       	movw	r30, r24
     e12:	80 81       	ld	r24, Z
     e14:	88 23       	and	r24, r24
     e16:	09 f7       	brne	.-62     	; 0xdda <EEPROM_readString+0x32>
		{u16addr++;
			i++;
			EEPROM_readByte(u16addr, &str[i]);
		}
		str[i]='\0';
     e18:	89 81       	ldd	r24, Y+1	; 0x01
     e1a:	88 2f       	mov	r24, r24
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	2c 81       	ldd	r18, Y+4	; 0x04
     e20:	3d 81       	ldd	r19, Y+5	; 0x05
     e22:	82 0f       	add	r24, r18
     e24:	93 1f       	adc	r25, r19
     e26:	fc 01       	movw	r30, r24
     e28:	10 82       	st	Z, r1

}
     e2a:	00 00       	nop
     e2c:	0f 90       	pop	r0
     e2e:	0f 90       	pop	r0
     e30:	0f 90       	pop	r0
     e32:	0f 90       	pop	r0
     e34:	0f 90       	pop	r0
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	08 95       	ret

00000e3c <TWI_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void TWI_init(const TWI_configurationType *config)
{
     e3c:	cf 92       	push	r12
     e3e:	df 92       	push	r13
     e40:	ef 92       	push	r14
     e42:	ff 92       	push	r15
     e44:	0f 93       	push	r16
     e46:	1f 93       	push	r17
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	00 d0       	rcall	.+0      	; 0xe4e <TWI_init+0x12>
     e4e:	cd b7       	in	r28, 0x3d	; 61
     e50:	de b7       	in	r29, 0x3e	; 62
     e52:	9a 83       	std	Y+2, r25	; 0x02
     e54:	89 83       	std	Y+1, r24	; 0x01
	/* the equation is SCL frequency = CPU clock frequency /(16+2(TWBR)*4^prescaler */
	TWBR=((float)F_CPU/config->baudRate +16)/(2*pow(4,config->prescasler));
     e56:	00 e2       	ldi	r16, 0x20	; 32
     e58:	10 e0       	ldi	r17, 0x00	; 0
     e5a:	89 81       	ldd	r24, Y+1	; 0x01
     e5c:	9a 81       	ldd	r25, Y+2	; 0x02
     e5e:	fc 01       	movw	r30, r24
     e60:	80 81       	ld	r24, Z
     e62:	91 81       	ldd	r25, Z+1	; 0x01
     e64:	a2 81       	ldd	r26, Z+2	; 0x02
     e66:	b3 81       	ldd	r27, Z+3	; 0x03
     e68:	bc 01       	movw	r22, r24
     e6a:	cd 01       	movw	r24, r26
     e6c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <__floatunsisf>
     e70:	dc 01       	movw	r26, r24
     e72:	cb 01       	movw	r24, r22
     e74:	9c 01       	movw	r18, r24
     e76:	ad 01       	movw	r20, r26
     e78:	60 e0       	ldi	r22, 0x00	; 0
     e7a:	74 e2       	ldi	r23, 0x24	; 36
     e7c:	84 ef       	ldi	r24, 0xF4	; 244
     e7e:	9a e4       	ldi	r25, 0x4A	; 74
     e80:	0e 94 c9 10 	call	0x2192	; 0x2192 <__divsf3>
     e84:	dc 01       	movw	r26, r24
     e86:	cb 01       	movw	r24, r22
     e88:	20 e0       	ldi	r18, 0x00	; 0
     e8a:	30 e0       	ldi	r19, 0x00	; 0
     e8c:	40 e8       	ldi	r20, 0x80	; 128
     e8e:	51 e4       	ldi	r21, 0x41	; 65
     e90:	bc 01       	movw	r22, r24
     e92:	cd 01       	movw	r24, r26
     e94:	0e 94 58 10 	call	0x20b0	; 0x20b0 <__addsf3>
     e98:	dc 01       	movw	r26, r24
     e9a:	cb 01       	movw	r24, r22
     e9c:	6c 01       	movw	r12, r24
     e9e:	7d 01       	movw	r14, r26
     ea0:	89 81       	ldd	r24, Y+1	; 0x01
     ea2:	9a 81       	ldd	r25, Y+2	; 0x02
     ea4:	fc 01       	movw	r30, r24
     ea6:	84 81       	ldd	r24, Z+4	; 0x04
     ea8:	88 2f       	mov	r24, r24
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	a0 e0       	ldi	r26, 0x00	; 0
     eae:	b0 e0       	ldi	r27, 0x00	; 0
     eb0:	bc 01       	movw	r22, r24
     eb2:	cd 01       	movw	r24, r26
     eb4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <__floatunsisf>
     eb8:	dc 01       	movw	r26, r24
     eba:	cb 01       	movw	r24, r22
     ebc:	9c 01       	movw	r18, r24
     ebe:	ad 01       	movw	r20, r26
     ec0:	60 e0       	ldi	r22, 0x00	; 0
     ec2:	70 e0       	ldi	r23, 0x00	; 0
     ec4:	80 e8       	ldi	r24, 0x80	; 128
     ec6:	90 e4       	ldi	r25, 0x40	; 64
     ec8:	0e 94 8e 12 	call	0x251c	; 0x251c <pow>
     ecc:	dc 01       	movw	r26, r24
     ece:	cb 01       	movw	r24, r22
     ed0:	9c 01       	movw	r18, r24
     ed2:	ad 01       	movw	r20, r26
     ed4:	bc 01       	movw	r22, r24
     ed6:	cd 01       	movw	r24, r26
     ed8:	0e 94 58 10 	call	0x20b0	; 0x20b0 <__addsf3>
     edc:	dc 01       	movw	r26, r24
     ede:	cb 01       	movw	r24, r22
     ee0:	9c 01       	movw	r18, r24
     ee2:	ad 01       	movw	r20, r26
     ee4:	c7 01       	movw	r24, r14
     ee6:	b6 01       	movw	r22, r12
     ee8:	0e 94 c9 10 	call	0x2192	; 0x2192 <__divsf3>
     eec:	dc 01       	movw	r26, r24
     eee:	cb 01       	movw	r24, r22
     ef0:	bc 01       	movw	r22, r24
     ef2:	cd 01       	movw	r24, r26
     ef4:	0e 94 3b 11 	call	0x2276	; 0x2276 <__fixunssfsi>
     ef8:	dc 01       	movw	r26, r24
     efa:	cb 01       	movw	r24, r22
     efc:	f8 01       	movw	r30, r16
     efe:	80 83       	st	Z, r24
	 	TWSR=config->prescasler;/*store prescaler  in first 2 bits (TWPS1 and TWPS0) as other bits read only*/
     f00:	81 e2       	ldi	r24, 0x21	; 33
     f02:	90 e0       	ldi	r25, 0x00	; 0
     f04:	29 81       	ldd	r18, Y+1	; 0x01
     f06:	3a 81       	ldd	r19, Y+2	; 0x02
     f08:	f9 01       	movw	r30, r18
     f0a:	24 81       	ldd	r18, Z+4	; 0x04
     f0c:	fc 01       	movw	r30, r24
     f0e:	20 83       	st	Z, r18
	 TWAR=config->slave_address<<1;/* store slave address (7bits) in the most 7 significant bits
     f10:	82 e2       	ldi	r24, 0x22	; 34
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	29 81       	ldd	r18, Y+1	; 0x01
     f16:	3a 81       	ldd	r19, Y+2	; 0x02
     f18:	f9 01       	movw	r30, r18
     f1a:	25 81       	ldd	r18, Z+5	; 0x05
     f1c:	22 0f       	add	r18, r18
     f1e:	fc 01       	movw	r30, r24
     f20:	20 83       	st	Z, r18
	  the address of master when receive data from (as slave) form other slaves */
	TWCR|=(1<<TWEN);/* enable TWI module */
     f22:	86 e5       	ldi	r24, 0x56	; 86
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	26 e5       	ldi	r18, 0x56	; 86
     f28:	30 e0       	ldi	r19, 0x00	; 0
     f2a:	f9 01       	movw	r30, r18
     f2c:	20 81       	ld	r18, Z
     f2e:	24 60       	ori	r18, 0x04	; 4
     f30:	fc 01       	movw	r30, r24
     f32:	20 83       	st	Z, r18

}
     f34:	00 00       	nop
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	ff 90       	pop	r15
     f44:	ef 90       	pop	r14
     f46:	df 90       	pop	r13
     f48:	cf 90       	pop	r12
     f4a:	08 95       	ret

00000f4c <TWI_start>:
void TWI_start(void)
{
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	cd b7       	in	r28, 0x3d	; 61
     f52:	de b7       	in	r29, 0x3e	; 62
	//make enable again to force other bits in the register to be zero
	//start bit TWSTA and clear finish current job flag TWINT by toggle it
TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     f54:	86 e5       	ldi	r24, 0x56	; 86
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	24 ea       	ldi	r18, 0xA4	; 164
     f5a:	fc 01       	movw	r30, r24
     f5c:	20 83       	st	Z, r18
while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     f5e:	00 00       	nop
     f60:	86 e5       	ldi	r24, 0x56	; 86
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	fc 01       	movw	r30, r24
     f66:	80 81       	ld	r24, Z
     f68:	88 23       	and	r24, r24
     f6a:	d4 f7       	brge	.-12     	; 0xf60 <TWI_start+0x14>
}
     f6c:	00 00       	nop
     f6e:	df 91       	pop	r29
     f70:	cf 91       	pop	r28
     f72:	08 95       	ret

00000f74 <TWI_stop>:
void TWI_stop(void)
{/*make enable again to force other bits in the register to be zero
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
     f78:	cd b7       	in	r28, 0x3d	; 61
     f7a:	de b7       	in	r29, 0x3e	; 62
	stop bit TWST0 and clear finish current job flag TWINT by toggle it */
TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     f7c:	86 e5       	ldi	r24, 0x56	; 86
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	24 e9       	ldi	r18, 0x94	; 148
     f82:	fc 01       	movw	r30, r24
     f84:	20 83       	st	Z, r18

//NO NEED TO WAIT TWINT flag as it  is the end of frame
}
     f86:	00 00       	nop
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	08 95       	ret

00000f8e <TWI_write>:
void TWI_write(uint8 data)
{
     f8e:	cf 93       	push	r28
     f90:	df 93       	push	r29
     f92:	1f 92       	push	r1
     f94:	cd b7       	in	r28, 0x3d	; 61
     f96:	de b7       	in	r29, 0x3e	; 62
     f98:	89 83       	std	Y+1, r24	; 0x01
/* store data in TWDR */
	TWDR=data;
     f9a:	83 e2       	ldi	r24, 0x23	; 35
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	29 81       	ldd	r18, Y+1	; 0x01
     fa0:	fc 01       	movw	r30, r24
     fa2:	20 83       	st	Z, r18
	/*make enable again to force other bits in the register to be zero
		 clear finish current job flag TWINT by toggle it */
	TWCR=(1<<TWINT)|(1<<TWEN);
     fa4:	86 e5       	ldi	r24, 0x56	; 86
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	24 e8       	ldi	r18, 0x84	; 132
     faa:	fc 01       	movw	r30, r24
     fac:	20 83       	st	Z, r18

	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     fae:	00 00       	nop
     fb0:	86 e5       	ldi	r24, 0x56	; 86
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	fc 01       	movw	r30, r24
     fb6:	80 81       	ld	r24, Z
     fb8:	88 23       	and	r24, r24
     fba:	d4 f7       	brge	.-12     	; 0xfb0 <TWI_write+0x22>

}
     fbc:	00 00       	nop
     fbe:	0f 90       	pop	r0
     fc0:	df 91       	pop	r29
     fc2:	cf 91       	pop	r28
     fc4:	08 95       	ret

00000fc6 <TWI_read_with_ACK>:
uint8 TWI_read_with_ACK(void)
{/*make enable again to force other bits in the register to be zero
     fc6:	cf 93       	push	r28
     fc8:	df 93       	push	r29
     fca:	cd b7       	in	r28, 0x3d	; 61
     fcc:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it
		 enable acknowledge bit TWEA */

	TWCR=(1<<TWINT)|(1<<TWEA)|(1<<TWEN);
     fce:	86 e5       	ldi	r24, 0x56	; 86
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	24 ec       	ldi	r18, 0xC4	; 196
     fd4:	fc 01       	movw	r30, r24
     fd6:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));
     fd8:	00 00       	nop
     fda:	86 e5       	ldi	r24, 0x56	; 86
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	fc 01       	movw	r30, r24
     fe0:	80 81       	ld	r24, Z
     fe2:	88 23       	and	r24, r24
     fe4:	d4 f7       	brge	.-12     	; 0xfda <TWI_read_with_ACK+0x14>
	//CLEAR flag before or after
	return TWDR;
     fe6:	83 e2       	ldi	r24, 0x23	; 35
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	fc 01       	movw	r30, r24
     fec:	80 81       	ld	r24, Z
}
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	08 95       	ret

00000ff4 <TWI_read_with_NACK>:

uint8 TWI_read_with_NACK(void)
{/*make enable again to force other bits in the register to be zero
     ff4:	cf 93       	push	r28
     ff6:	df 93       	push	r29
     ff8:	cd b7       	in	r28, 0x3d	; 61
     ffa:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it*/
	TWCR=(1<<TWINT)|(1<<TWEN);
     ffc:	86 e5       	ldi	r24, 0x56	; 86
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	24 e8       	ldi	r18, 0x84	; 132
    1002:	fc 01       	movw	r30, r24
    1004:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
    1006:	00 00       	nop
    1008:	86 e5       	ldi	r24, 0x56	; 86
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	fc 01       	movw	r30, r24
    100e:	80 81       	ld	r24, Z
    1010:	88 23       	and	r24, r24
    1012:	d4 f7       	brge	.-12     	; 0x1008 <TWI_read_with_NACK+0x14>

	return TWDR;
    1014:	83 e2       	ldi	r24, 0x23	; 35
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	fc 01       	movw	r30, r24
    101a:	80 81       	ld	r24, Z
}
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	08 95       	ret

00001022 <TWI_getStatus>:
uint8 TWI_getStatus()
{	/*return bits 7:3 in status register TWSR */
    1022:	cf 93       	push	r28
    1024:	df 93       	push	r29
    1026:	cd b7       	in	r28, 0x3d	; 61
    1028:	de b7       	in	r29, 0x3e	; 62
	return TWSR&0XF8;
    102a:	81 e2       	ldi	r24, 0x21	; 33
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	fc 01       	movw	r30, r24
    1030:	80 81       	ld	r24, Z
    1032:	88 7f       	andi	r24, 0xF8	; 248
}
    1034:	df 91       	pop	r29
    1036:	cf 91       	pop	r28
    1038:	08 95       	ret

0000103a <__vector_19>:
/***************************************************************
 * 		Interrupt Service Routine functions definition 						*
 * *************************************************************
 */
/*ISR function work with timer 0 compare match mode */
ISR(TIMER0_COMP_vect) {
    103a:	1f 92       	push	r1
    103c:	0f 92       	push	r0
    103e:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1042:	0f 92       	push	r0
    1044:	11 24       	eor	r1, r1
    1046:	2f 93       	push	r18
    1048:	3f 93       	push	r19
    104a:	4f 93       	push	r20
    104c:	5f 93       	push	r21
    104e:	6f 93       	push	r22
    1050:	7f 93       	push	r23
    1052:	8f 93       	push	r24
    1054:	9f 93       	push	r25
    1056:	af 93       	push	r26
    1058:	bf 93       	push	r27
    105a:	ef 93       	push	r30
    105c:	ff 93       	push	r31
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) /* check that callback function address is passed */
    1066:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    106a:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    106e:	89 2b       	or	r24, r25
    1070:	31 f0       	breq	.+12     	; 0x107e <__vector_19+0x44>
		g_callBackPtr();/* point to callBack function */
    1072:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1076:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    107a:	fc 01       	movw	r30, r24
    107c:	09 95       	icall

}
    107e:	00 00       	nop
    1080:	df 91       	pop	r29
    1082:	cf 91       	pop	r28
    1084:	ff 91       	pop	r31
    1086:	ef 91       	pop	r30
    1088:	bf 91       	pop	r27
    108a:	af 91       	pop	r26
    108c:	9f 91       	pop	r25
    108e:	8f 91       	pop	r24
    1090:	7f 91       	pop	r23
    1092:	6f 91       	pop	r22
    1094:	5f 91       	pop	r21
    1096:	4f 91       	pop	r20
    1098:	3f 91       	pop	r19
    109a:	2f 91       	pop	r18
    109c:	0f 90       	pop	r0
    109e:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10a2:	0f 90       	pop	r0
    10a4:	1f 90       	pop	r1
    10a6:	18 95       	reti

000010a8 <__vector_9>:
/*ISR function work with timer 0 normal mode */
ISR(TIMER0_OVF_vect) {
    10a8:	1f 92       	push	r1
    10aa:	0f 92       	push	r0
    10ac:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10b0:	0f 92       	push	r0
    10b2:	11 24       	eor	r1, r1
    10b4:	2f 93       	push	r18
    10b6:	3f 93       	push	r19
    10b8:	4f 93       	push	r20
    10ba:	5f 93       	push	r21
    10bc:	6f 93       	push	r22
    10be:	7f 93       	push	r23
    10c0:	8f 93       	push	r24
    10c2:	9f 93       	push	r25
    10c4:	af 93       	push	r26
    10c6:	bf 93       	push	r27
    10c8:	ef 93       	push	r30
    10ca:	ff 93       	push	r31
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	cd b7       	in	r28, 0x3d	; 61
    10d2:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    10d4:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    10d8:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    10dc:	89 2b       	or	r24, r25
    10de:	31 f0       	breq	.+12     	; 0x10ec <__vector_9+0x44>
		g_callBackPtr();
    10e0:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    10e4:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    10e8:	fc 01       	movw	r30, r24
    10ea:	09 95       	icall

}
    10ec:	00 00       	nop
    10ee:	df 91       	pop	r29
    10f0:	cf 91       	pop	r28
    10f2:	ff 91       	pop	r31
    10f4:	ef 91       	pop	r30
    10f6:	bf 91       	pop	r27
    10f8:	af 91       	pop	r26
    10fa:	9f 91       	pop	r25
    10fc:	8f 91       	pop	r24
    10fe:	7f 91       	pop	r23
    1100:	6f 91       	pop	r22
    1102:	5f 91       	pop	r21
    1104:	4f 91       	pop	r20
    1106:	3f 91       	pop	r19
    1108:	2f 91       	pop	r18
    110a:	0f 90       	pop	r0
    110c:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1110:	0f 90       	pop	r0
    1112:	1f 90       	pop	r1
    1114:	18 95       	reti

00001116 <__vector_8>:
/*ISR function work with timer 1 normal mode */
ISR(TIMER1_OVF_vect) {
    1116:	1f 92       	push	r1
    1118:	0f 92       	push	r0
    111a:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    111e:	0f 92       	push	r0
    1120:	11 24       	eor	r1, r1
    1122:	2f 93       	push	r18
    1124:	3f 93       	push	r19
    1126:	4f 93       	push	r20
    1128:	5f 93       	push	r21
    112a:	6f 93       	push	r22
    112c:	7f 93       	push	r23
    112e:	8f 93       	push	r24
    1130:	9f 93       	push	r25
    1132:	af 93       	push	r26
    1134:	bf 93       	push	r27
    1136:	ef 93       	push	r30
    1138:	ff 93       	push	r31
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	cd b7       	in	r28, 0x3d	; 61
    1140:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    1142:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1146:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    114a:	89 2b       	or	r24, r25
    114c:	31 f0       	breq	.+12     	; 0x115a <__vector_8+0x44>
		g_callBackPtr();
    114e:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1152:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1156:	fc 01       	movw	r30, r24
    1158:	09 95       	icall

}
    115a:	00 00       	nop
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	ff 91       	pop	r31
    1162:	ef 91       	pop	r30
    1164:	bf 91       	pop	r27
    1166:	af 91       	pop	r26
    1168:	9f 91       	pop	r25
    116a:	8f 91       	pop	r24
    116c:	7f 91       	pop	r23
    116e:	6f 91       	pop	r22
    1170:	5f 91       	pop	r21
    1172:	4f 91       	pop	r20
    1174:	3f 91       	pop	r19
    1176:	2f 91       	pop	r18
    1178:	0f 90       	pop	r0
    117a:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    117e:	0f 90       	pop	r0
    1180:	1f 90       	pop	r1
    1182:	18 95       	reti

00001184 <__vector_6>:
/*ISR function work with timer 1A compare match mode */
ISR(TIMER1_COMPA_vect) {
    1184:	1f 92       	push	r1
    1186:	0f 92       	push	r0
    1188:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    118c:	0f 92       	push	r0
    118e:	11 24       	eor	r1, r1
    1190:	2f 93       	push	r18
    1192:	3f 93       	push	r19
    1194:	4f 93       	push	r20
    1196:	5f 93       	push	r21
    1198:	6f 93       	push	r22
    119a:	7f 93       	push	r23
    119c:	8f 93       	push	r24
    119e:	9f 93       	push	r25
    11a0:	af 93       	push	r26
    11a2:	bf 93       	push	r27
    11a4:	ef 93       	push	r30
    11a6:	ff 93       	push	r31
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	cd b7       	in	r28, 0x3d	; 61
    11ae:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    11b0:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    11b4:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    11b8:	89 2b       	or	r24, r25
    11ba:	31 f0       	breq	.+12     	; 0x11c8 <__vector_6+0x44>
		g_callBackPtr();
    11bc:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    11c0:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    11c4:	fc 01       	movw	r30, r24
    11c6:	09 95       	icall
}
    11c8:	00 00       	nop
    11ca:	df 91       	pop	r29
    11cc:	cf 91       	pop	r28
    11ce:	ff 91       	pop	r31
    11d0:	ef 91       	pop	r30
    11d2:	bf 91       	pop	r27
    11d4:	af 91       	pop	r26
    11d6:	9f 91       	pop	r25
    11d8:	8f 91       	pop	r24
    11da:	7f 91       	pop	r23
    11dc:	6f 91       	pop	r22
    11de:	5f 91       	pop	r21
    11e0:	4f 91       	pop	r20
    11e2:	3f 91       	pop	r19
    11e4:	2f 91       	pop	r18
    11e6:	0f 90       	pop	r0
    11e8:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    11ec:	0f 90       	pop	r0
    11ee:	1f 90       	pop	r1
    11f0:	18 95       	reti

000011f2 <__vector_3>:
/*ISR function work with timer 2 compare match mode */
ISR(TIMER2_COMP_vect) {
    11f2:	1f 92       	push	r1
    11f4:	0f 92       	push	r0
    11f6:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    11fa:	0f 92       	push	r0
    11fc:	11 24       	eor	r1, r1
    11fe:	2f 93       	push	r18
    1200:	3f 93       	push	r19
    1202:	4f 93       	push	r20
    1204:	5f 93       	push	r21
    1206:	6f 93       	push	r22
    1208:	7f 93       	push	r23
    120a:	8f 93       	push	r24
    120c:	9f 93       	push	r25
    120e:	af 93       	push	r26
    1210:	bf 93       	push	r27
    1212:	ef 93       	push	r30
    1214:	ff 93       	push	r31
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	cd b7       	in	r28, 0x3d	; 61
    121c:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    121e:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1222:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1226:	89 2b       	or	r24, r25
    1228:	31 f0       	breq	.+12     	; 0x1236 <__vector_3+0x44>
		g_callBackPtr();
    122a:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    122e:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1232:	fc 01       	movw	r30, r24
    1234:	09 95       	icall

}
    1236:	00 00       	nop
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	ff 91       	pop	r31
    123e:	ef 91       	pop	r30
    1240:	bf 91       	pop	r27
    1242:	af 91       	pop	r26
    1244:	9f 91       	pop	r25
    1246:	8f 91       	pop	r24
    1248:	7f 91       	pop	r23
    124a:	6f 91       	pop	r22
    124c:	5f 91       	pop	r21
    124e:	4f 91       	pop	r20
    1250:	3f 91       	pop	r19
    1252:	2f 91       	pop	r18
    1254:	0f 90       	pop	r0
    1256:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    125a:	0f 90       	pop	r0
    125c:	1f 90       	pop	r1
    125e:	18 95       	reti

00001260 <__vector_4>:
/*ISR function work with timer 2 normal mode */
ISR(TIMER2_OVF_vect) {
    1260:	1f 92       	push	r1
    1262:	0f 92       	push	r0
    1264:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1268:	0f 92       	push	r0
    126a:	11 24       	eor	r1, r1
    126c:	2f 93       	push	r18
    126e:	3f 93       	push	r19
    1270:	4f 93       	push	r20
    1272:	5f 93       	push	r21
    1274:	6f 93       	push	r22
    1276:	7f 93       	push	r23
    1278:	8f 93       	push	r24
    127a:	9f 93       	push	r25
    127c:	af 93       	push	r26
    127e:	bf 93       	push	r27
    1280:	ef 93       	push	r30
    1282:	ff 93       	push	r31
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	cd b7       	in	r28, 0x3d	; 61
    128a:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    128c:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1290:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1294:	89 2b       	or	r24, r25
    1296:	31 f0       	breq	.+12     	; 0x12a4 <__vector_4+0x44>
		g_callBackPtr();
    1298:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    129c:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    12a0:	fc 01       	movw	r30, r24
    12a2:	09 95       	icall
}
    12a4:	00 00       	nop
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	ff 91       	pop	r31
    12ac:	ef 91       	pop	r30
    12ae:	bf 91       	pop	r27
    12b0:	af 91       	pop	r26
    12b2:	9f 91       	pop	r25
    12b4:	8f 91       	pop	r24
    12b6:	7f 91       	pop	r23
    12b8:	6f 91       	pop	r22
    12ba:	5f 91       	pop	r21
    12bc:	4f 91       	pop	r20
    12be:	3f 91       	pop	r19
    12c0:	2f 91       	pop	r18
    12c2:	0f 90       	pop	r0
    12c4:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    12c8:	0f 90       	pop	r0
    12ca:	1f 90       	pop	r1
    12cc:	18 95       	reti

000012ce <TIMER_init>:




/* configurate by passing timer  configuration structure */
void TIMER_init(TIMER_configurationType *config) {
    12ce:	cf 93       	push	r28
    12d0:	df 93       	push	r29
    12d2:	00 d0       	rcall	.+0      	; 0x12d4 <TIMER_init+0x6>
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    12d8:	9a 83       	std	Y+2, r25	; 0x02
    12da:	89 83       	std	Y+1, r24	; 0x01
	configPtr = config; /* make passed configuration global */
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	9a 81       	ldd	r25, Y+2	; 0x02
    12e0:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <configPtr+0x1>
    12e4:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <configPtr>


/***************************************************************
* 						0	TIMER0		*
* *************************************************************/
	if (config->timerNumber == 0) {
    12e8:	89 81       	ldd	r24, Y+1	; 0x01
    12ea:	9a 81       	ldd	r25, Y+2	; 0x02
    12ec:	fc 01       	movw	r30, r24
    12ee:	80 81       	ld	r24, Z
    12f0:	88 23       	and	r24, r24
    12f2:	09 f0       	breq	.+2      	; 0x12f6 <TIMER_init+0x28>
    12f4:	22 c1       	rjmp	.+580    	; 0x153a <TIMER_init+0x26c>
		TCCR0 = 0; /* put zeros into all bits in the register */
    12f6:	83 e5       	ldi	r24, 0x53	; 83
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	fc 01       	movw	r30, r24
    12fc:	10 82       	st	Z, r1
		switch (config->prescaler) {
    12fe:	89 81       	ldd	r24, Y+1	; 0x01
    1300:	9a 81       	ldd	r25, Y+2	; 0x02
    1302:	fc 01       	movw	r30, r24
    1304:	85 89       	ldd	r24, Z+21	; 0x15
    1306:	96 89       	ldd	r25, Z+22	; 0x16
    1308:	80 34       	cpi	r24, 0x40	; 64
    130a:	91 05       	cpc	r25, r1
    130c:	c1 f0       	breq	.+48     	; 0x133e <TIMER_init+0x70>
    130e:	81 34       	cpi	r24, 0x41	; 65
    1310:	91 05       	cpc	r25, r1
    1312:	18 f4       	brcc	.+6      	; 0x131a <TIMER_init+0x4c>
    1314:	08 97       	sbiw	r24, 0x08	; 8
    1316:	49 f0       	breq	.+18     	; 0x132a <TIMER_init+0x5c>
    1318:	30 c0       	rjmp	.+96     	; 0x137a <TIMER_init+0xac>
    131a:	81 15       	cp	r24, r1
    131c:	f1 e0       	ldi	r31, 0x01	; 1
    131e:	9f 07       	cpc	r25, r31
    1320:	c1 f0       	breq	.+48     	; 0x1352 <TIMER_init+0x84>
    1322:	81 15       	cp	r24, r1
    1324:	94 40       	sbci	r25, 0x04	; 4
    1326:	f9 f0       	breq	.+62     	; 0x1366 <TIMER_init+0x98>
    1328:	28 c0       	rjmp	.+80     	; 0x137a <TIMER_init+0xac>
		case 8:
			TCCR0 |= (1 << CS01); /*CS00=0  CS01=1 CS02=0  */
    132a:	83 e5       	ldi	r24, 0x53	; 83
    132c:	90 e0       	ldi	r25, 0x00	; 0
    132e:	23 e5       	ldi	r18, 0x53	; 83
    1330:	30 e0       	ldi	r19, 0x00	; 0
    1332:	f9 01       	movw	r30, r18
    1334:	20 81       	ld	r18, Z
    1336:	22 60       	ori	r18, 0x02	; 2
    1338:	fc 01       	movw	r30, r24
    133a:	20 83       	st	Z, r18
			break;
    133c:	27 c0       	rjmp	.+78     	; 0x138c <TIMER_init+0xbe>
		case 64:
			TCCR0 |= (1 << CS00) | (1 << CS01); /*CS00=1  CS01=1 CS02=0  */
    133e:	83 e5       	ldi	r24, 0x53	; 83
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	23 e5       	ldi	r18, 0x53	; 83
    1344:	30 e0       	ldi	r19, 0x00	; 0
    1346:	f9 01       	movw	r30, r18
    1348:	20 81       	ld	r18, Z
    134a:	23 60       	ori	r18, 0x03	; 3
    134c:	fc 01       	movw	r30, r24
    134e:	20 83       	st	Z, r18
			break;
    1350:	1d c0       	rjmp	.+58     	; 0x138c <TIMER_init+0xbe>
		case 256:
			TCCR0 |= (1 << CS02); /*CS00=0  CS01=0 CS02=02  */
    1352:	83 e5       	ldi	r24, 0x53	; 83
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	23 e5       	ldi	r18, 0x53	; 83
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	f9 01       	movw	r30, r18
    135c:	20 81       	ld	r18, Z
    135e:	24 60       	ori	r18, 0x04	; 4
    1360:	fc 01       	movw	r30, r24
    1362:	20 83       	st	Z, r18
			break;
    1364:	13 c0       	rjmp	.+38     	; 0x138c <TIMER_init+0xbe>
		case 1024:
			TCCR0 |= (1 << CS00) | (1 << CS02); /*CS00=1  CS01=0 CS02=1  */
    1366:	83 e5       	ldi	r24, 0x53	; 83
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	23 e5       	ldi	r18, 0x53	; 83
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	f9 01       	movw	r30, r18
    1370:	20 81       	ld	r18, Z
    1372:	25 60       	ori	r18, 0x05	; 5
    1374:	fc 01       	movw	r30, r24
    1376:	20 83       	st	Z, r18
			break;
    1378:	09 c0       	rjmp	.+18     	; 0x138c <TIMER_init+0xbe>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR0 |= (1 << CS00); /*CS00=1  CS01=0 CS02=0  */
    137a:	83 e5       	ldi	r24, 0x53	; 83
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	23 e5       	ldi	r18, 0x53	; 83
    1380:	30 e0       	ldi	r19, 0x00	; 0
    1382:	f9 01       	movw	r30, r18
    1384:	20 81       	ld	r18, Z
    1386:	21 60       	ori	r18, 0x01	; 1
    1388:	fc 01       	movw	r30, r24
    138a:	20 83       	st	Z, r18
		}
/***************************************************************
 * 					0-0 select the mode for TIMER0	*
* *************************************************************
*/
		if (!strcmp(config->mode, "compare"))
    138c:	89 81       	ldd	r24, Y+1	; 0x01
    138e:	9a 81       	ldd	r25, Y+2	; 0x02
    1390:	01 96       	adiw	r24, 0x01	; 1
    1392:	65 e7       	ldi	r22, 0x75	; 117
    1394:	70 e0       	ldi	r23, 0x00	; 0
    1396:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    139a:	89 2b       	or	r24, r25
    139c:	09 f0       	breq	.+2      	; 0x13a0 <TIMER_init+0xd2>
    139e:	62 c0       	rjmp	.+196    	; 0x1464 <TIMER_init+0x196>
		{
			TCCR0 |= (1 << FOC0) | (1 << WGM01);
    13a0:	83 e5       	ldi	r24, 0x53	; 83
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	23 e5       	ldi	r18, 0x53	; 83
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	f9 01       	movw	r30, r18
    13aa:	20 81       	ld	r18, Z
    13ac:	28 68       	ori	r18, 0x88	; 136
    13ae:	fc 01       	movw	r30, r24
    13b0:	20 83       	st	Z, r18
 * 		0-1 compare match output mode for TIMER0	*
 * ***************************************************
 */


				if (!strcmp(config->compareMatchMode, "toggle")) {
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
    13b4:	9a 81       	ldd	r25, Y+2	; 0x02
    13b6:	47 96       	adiw	r24, 0x17	; 23
    13b8:	6d e7       	ldi	r22, 0x7D	; 125
    13ba:	70 e0       	ldi	r23, 0x00	; 0
    13bc:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    13c0:	89 2b       	or	r24, r25
    13c2:	99 f4       	brne	.+38     	; 0x13ea <TIMER_init+0x11c>
					TCCR0 |= (1 << COM00); /*COM00=1 AND COM01=0 */
    13c4:	83 e5       	ldi	r24, 0x53	; 83
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	23 e5       	ldi	r18, 0x53	; 83
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	f9 01       	movw	r30, r18
    13ce:	20 81       	ld	r18, Z
    13d0:	20 61       	ori	r18, 0x10	; 16
    13d2:	fc 01       	movw	r30, r24
    13d4:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3); /*make OCO AS OUTPUT BIT */
    13d6:	87 e3       	ldi	r24, 0x37	; 55
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	27 e3       	ldi	r18, 0x37	; 55
    13dc:	30 e0       	ldi	r19, 0x00	; 0
    13de:	f9 01       	movw	r30, r18
    13e0:	20 81       	ld	r18, Z
    13e2:	28 60       	ori	r18, 0x08	; 8
    13e4:	fc 01       	movw	r30, r24
    13e6:	20 83       	st	Z, r18
    13e8:	37 c0       	rjmp	.+110    	; 0x1458 <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    13ea:	89 81       	ldd	r24, Y+1	; 0x01
    13ec:	9a 81       	ldd	r25, Y+2	; 0x02
    13ee:	47 96       	adiw	r24, 0x17	; 23
    13f0:	64 e8       	ldi	r22, 0x84	; 132
    13f2:	70 e0       	ldi	r23, 0x00	; 0
    13f4:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    13f8:	89 2b       	or	r24, r25
    13fa:	99 f4       	brne	.+38     	; 0x1422 <TIMER_init+0x154>
					TCCR0 |= (1 << COM01); /*COM00=0 AND COM01=1 */
    13fc:	83 e5       	ldi	r24, 0x53	; 83
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	23 e5       	ldi	r18, 0x53	; 83
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	f9 01       	movw	r30, r18
    1406:	20 81       	ld	r18, Z
    1408:	20 62       	ori	r18, 0x20	; 32
    140a:	fc 01       	movw	r30, r24
    140c:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    140e:	87 e3       	ldi	r24, 0x37	; 55
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	27 e3       	ldi	r18, 0x37	; 55
    1414:	30 e0       	ldi	r19, 0x00	; 0
    1416:	f9 01       	movw	r30, r18
    1418:	20 81       	ld	r18, Z
    141a:	28 60       	ori	r18, 0x08	; 8
    141c:	fc 01       	movw	r30, r24
    141e:	20 83       	st	Z, r18
    1420:	1b c0       	rjmp	.+54     	; 0x1458 <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "set")) {
    1422:	89 81       	ldd	r24, Y+1	; 0x01
    1424:	9a 81       	ldd	r25, Y+2	; 0x02
    1426:	47 96       	adiw	r24, 0x17	; 23
    1428:	6a e8       	ldi	r22, 0x8A	; 138
    142a:	70 e0       	ldi	r23, 0x00	; 0
    142c:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1430:	89 2b       	or	r24, r25
    1432:	91 f4       	brne	.+36     	; 0x1458 <TIMER_init+0x18a>
					TCCR0 |= (1 << COM01) | (1 << COM00); /*COM00=1 AND COM01=1 */
    1434:	83 e5       	ldi	r24, 0x53	; 83
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	23 e5       	ldi	r18, 0x53	; 83
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	f9 01       	movw	r30, r18
    143e:	20 81       	ld	r18, Z
    1440:	20 63       	ori	r18, 0x30	; 48
    1442:	fc 01       	movw	r30, r24
    1444:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    1446:	87 e3       	ldi	r24, 0x37	; 55
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	27 e3       	ldi	r18, 0x37	; 55
    144c:	30 e0       	ldi	r19, 0x00	; 0
    144e:	f9 01       	movw	r30, r18
    1450:	20 81       	ld	r18, Z
    1452:	28 60       	ori	r18, 0x08	; 8
    1454:	fc 01       	movw	r30, r24
    1456:	20 83       	st	Z, r18
				}
				/* the default case will be normal port operation OCO disconnected
				enable interrupt for compare mode */
				TIMSK = (1 << OCIE0);
    1458:	89 e5       	ldi	r24, 0x59	; 89
    145a:	90 e0       	ldi	r25, 0x00	; 0
    145c:	22 e0       	ldi	r18, 0x02	; 2
    145e:	fc 01       	movw	r30, r24
    1460:	20 83       	st	Z, r18
    1462:	6b c0       	rjmp	.+214    	; 0x153a <TIMER_init+0x26c>
/****************************************************
 * 		0-2 normal  mode for TIMER0		    *
 * ***************************************************
 */

		else if (!strcmp(config->mode, "normal"))
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	9a 81       	ldd	r25, Y+2	; 0x02
    1468:	01 96       	adiw	r24, 0x01	; 1
    146a:	6e e8       	ldi	r22, 0x8E	; 142
    146c:	70 e0       	ldi	r23, 0x00	; 0
    146e:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1472:	89 2b       	or	r24, r25
    1474:	79 f4       	brne	.+30     	; 0x1494 <TIMER_init+0x1c6>
			{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM01=0 and WGM00=0
			 */
			TCCR0 |= (1 << FOC0);
    1476:	83 e5       	ldi	r24, 0x53	; 83
    1478:	90 e0       	ldi	r25, 0x00	; 0
    147a:	23 e5       	ldi	r18, 0x53	; 83
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	f9 01       	movw	r30, r18
    1480:	20 81       	ld	r18, Z
    1482:	20 68       	ori	r18, 0x80	; 128
    1484:	fc 01       	movw	r30, r24
    1486:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE0);
    1488:	89 e5       	ldi	r24, 0x59	; 89
    148a:	90 e0       	ldi	r25, 0x00	; 0
    148c:	21 e0       	ldi	r18, 0x01	; 1
    148e:	fc 01       	movw	r30, r24
    1490:	20 83       	st	Z, r18
    1492:	53 c0       	rjmp	.+166    	; 0x153a <TIMER_init+0x26c>
			}
/****************************************************
 * 			0-3 PWM  mode for TIMER0	   *
 * ***************************************************
								 */
		else if (!strcmp(config->mode, "pwm")) {
    1494:	89 81       	ldd	r24, Y+1	; 0x01
    1496:	9a 81       	ldd	r25, Y+2	; 0x02
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	65 e9       	ldi	r22, 0x95	; 149
    149c:	70 e0       	ldi	r23, 0x00	; 0
    149e:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    14a2:	89 2b       	or	r24, r25
    14a4:	09 f0       	breq	.+2      	; 0x14a8 <TIMER_init+0x1da>
    14a6:	49 c0       	rjmp	.+146    	; 0x153a <TIMER_init+0x26c>
			/*
			 * FOC0=0 for  PWM mode
			 * select PWM mode --->> WGM01=1 and WGM00=1
			 */
			TCCR0 |= (1 << WGM00) | (1 << WGM01);
    14a8:	83 e5       	ldi	r24, 0x53	; 83
    14aa:	90 e0       	ldi	r25, 0x00	; 0
    14ac:	23 e5       	ldi	r18, 0x53	; 83
    14ae:	30 e0       	ldi	r19, 0x00	; 0
    14b0:	f9 01       	movw	r30, r18
    14b2:	20 81       	ld	r18, Z
    14b4:	28 64       	ori	r18, 0x48	; 72
    14b6:	fc 01       	movw	r30, r24
    14b8:	20 83       	st	Z, r18


			if (!strcmp(config->pwmMode, "inverting")) {
    14ba:	89 81       	ldd	r24, Y+1	; 0x01
    14bc:	9a 81       	ldd	r25, Y+2	; 0x02
    14be:	8b 96       	adiw	r24, 0x2b	; 43
    14c0:	69 e9       	ldi	r22, 0x99	; 153
    14c2:	70 e0       	ldi	r23, 0x00	; 0
    14c4:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    14c8:	89 2b       	or	r24, r25
    14ca:	e1 f4       	brne	.+56     	; 0x1504 <TIMER_init+0x236>
				/* COM00=1 and COM01=1 */
				TCCR0 |= (1 << COM00);
    14cc:	83 e5       	ldi	r24, 0x53	; 83
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	23 e5       	ldi	r18, 0x53	; 83
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	f9 01       	movw	r30, r18
    14d6:	20 81       	ld	r18, Z
    14d8:	20 61       	ori	r18, 0x10	; 16
    14da:	fc 01       	movw	r30, r24
    14dc:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM01);
    14de:	83 e5       	ldi	r24, 0x53	; 83
    14e0:	90 e0       	ldi	r25, 0x00	; 0
    14e2:	23 e5       	ldi	r18, 0x53	; 83
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	f9 01       	movw	r30, r18
    14e8:	20 81       	ld	r18, Z
    14ea:	20 62       	ori	r18, 0x20	; 32
    14ec:	fc 01       	movw	r30, r24
    14ee:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    14f0:	87 e3       	ldi	r24, 0x37	; 55
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	27 e3       	ldi	r18, 0x37	; 55
    14f6:	30 e0       	ldi	r19, 0x00	; 0
    14f8:	f9 01       	movw	r30, r18
    14fa:	20 81       	ld	r18, Z
    14fc:	28 60       	ori	r18, 0x08	; 8
    14fe:	fc 01       	movw	r30, r24
    1500:	20 83       	st	Z, r18
    1502:	1b c0       	rjmp	.+54     	; 0x153a <TIMER_init+0x26c>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    1504:	89 81       	ldd	r24, Y+1	; 0x01
    1506:	9a 81       	ldd	r25, Y+2	; 0x02
    1508:	8b 96       	adiw	r24, 0x2b	; 43
    150a:	63 ea       	ldi	r22, 0xA3	; 163
    150c:	70 e0       	ldi	r23, 0x00	; 0
    150e:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1512:	89 2b       	or	r24, r25
    1514:	91 f4       	brne	.+36     	; 0x153a <TIMER_init+0x26c>
				/* COM00=0 and COM01=1 */
				TCCR0 |= (1 << COM01);
    1516:	83 e5       	ldi	r24, 0x53	; 83
    1518:	90 e0       	ldi	r25, 0x00	; 0
    151a:	23 e5       	ldi	r18, 0x53	; 83
    151c:	30 e0       	ldi	r19, 0x00	; 0
    151e:	f9 01       	movw	r30, r18
    1520:	20 81       	ld	r18, Z
    1522:	20 62       	ori	r18, 0x20	; 32
    1524:	fc 01       	movw	r30, r24
    1526:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    1528:	87 e3       	ldi	r24, 0x37	; 55
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	27 e3       	ldi	r18, 0x37	; 55
    152e:	30 e0       	ldi	r19, 0x00	; 0
    1530:	f9 01       	movw	r30, r18
    1532:	20 81       	ld	r18, Z
    1534:	28 60       	ori	r18, 0x08	; 8
    1536:	fc 01       	movw	r30, r24
    1538:	20 83       	st	Z, r18
*/

	if (config->timerNumber == 1) {
		/* put zeros into all bits in the registers */
	}
		TCCR1A = 0;
    153a:	8f e4       	ldi	r24, 0x4F	; 79
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	fc 01       	movw	r30, r24
    1540:	10 82       	st	Z, r1
		TCCR1B = 0;
    1542:	8e e4       	ldi	r24, 0x4E	; 78
    1544:	90 e0       	ldi	r25, 0x00	; 0
    1546:	fc 01       	movw	r30, r24
    1548:	10 82       	st	Z, r1

		switch (config->prescaler) {
    154a:	89 81       	ldd	r24, Y+1	; 0x01
    154c:	9a 81       	ldd	r25, Y+2	; 0x02
    154e:	fc 01       	movw	r30, r24
    1550:	85 89       	ldd	r24, Z+21	; 0x15
    1552:	96 89       	ldd	r25, Z+22	; 0x16
    1554:	80 34       	cpi	r24, 0x40	; 64
    1556:	91 05       	cpc	r25, r1
    1558:	c1 f0       	breq	.+48     	; 0x158a <TIMER_init+0x2bc>
    155a:	81 34       	cpi	r24, 0x41	; 65
    155c:	91 05       	cpc	r25, r1
    155e:	18 f4       	brcc	.+6      	; 0x1566 <TIMER_init+0x298>
    1560:	08 97       	sbiw	r24, 0x08	; 8
    1562:	49 f0       	breq	.+18     	; 0x1576 <TIMER_init+0x2a8>
    1564:	30 c0       	rjmp	.+96     	; 0x15c6 <TIMER_init+0x2f8>
    1566:	81 15       	cp	r24, r1
    1568:	f1 e0       	ldi	r31, 0x01	; 1
    156a:	9f 07       	cpc	r25, r31
    156c:	c1 f0       	breq	.+48     	; 0x159e <TIMER_init+0x2d0>
    156e:	81 15       	cp	r24, r1
    1570:	94 40       	sbci	r25, 0x04	; 4
    1572:	f9 f0       	breq	.+62     	; 0x15b2 <TIMER_init+0x2e4>
    1574:	28 c0       	rjmp	.+80     	; 0x15c6 <TIMER_init+0x2f8>
		case 8:
			TCCR1B |= (1 << CS11);/*CS10=0  CS11=1 CS12=0  */
    1576:	8e e4       	ldi	r24, 0x4E	; 78
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	2e e4       	ldi	r18, 0x4E	; 78
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	f9 01       	movw	r30, r18
    1580:	20 81       	ld	r18, Z
    1582:	22 60       	ori	r18, 0x02	; 2
    1584:	fc 01       	movw	r30, r24
    1586:	20 83       	st	Z, r18
			break;
    1588:	27 c0       	rjmp	.+78     	; 0x15d8 <TIMER_init+0x30a>
		case 64:
			TCCR1B |= (1 << CS10) | (1 << CS11); /*CS10=1  CS11=1 CS12=0  */
    158a:	8e e4       	ldi	r24, 0x4E	; 78
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	2e e4       	ldi	r18, 0x4E	; 78
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	f9 01       	movw	r30, r18
    1594:	20 81       	ld	r18, Z
    1596:	23 60       	ori	r18, 0x03	; 3
    1598:	fc 01       	movw	r30, r24
    159a:	20 83       	st	Z, r18
			break;
    159c:	1d c0       	rjmp	.+58     	; 0x15d8 <TIMER_init+0x30a>
		case 256:
			TCCR1B |= (1 << CS12);/*CS10=0  CS11=0 CS12=1  */
    159e:	8e e4       	ldi	r24, 0x4E	; 78
    15a0:	90 e0       	ldi	r25, 0x00	; 0
    15a2:	2e e4       	ldi	r18, 0x4E	; 78
    15a4:	30 e0       	ldi	r19, 0x00	; 0
    15a6:	f9 01       	movw	r30, r18
    15a8:	20 81       	ld	r18, Z
    15aa:	24 60       	ori	r18, 0x04	; 4
    15ac:	fc 01       	movw	r30, r24
    15ae:	20 83       	st	Z, r18
			break;
    15b0:	13 c0       	rjmp	.+38     	; 0x15d8 <TIMER_init+0x30a>
		case 1024:
			TCCR1B |= (1 << CS10) | (1 << CS12);/*CS10=1  CS11=1 CS12=1  */
    15b2:	8e e4       	ldi	r24, 0x4E	; 78
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	2e e4       	ldi	r18, 0x4E	; 78
    15b8:	30 e0       	ldi	r19, 0x00	; 0
    15ba:	f9 01       	movw	r30, r18
    15bc:	20 81       	ld	r18, Z
    15be:	25 60       	ori	r18, 0x05	; 5
    15c0:	fc 01       	movw	r30, r24
    15c2:	20 83       	st	Z, r18
			break;
    15c4:	09 c0       	rjmp	.+18     	; 0x15d8 <TIMER_init+0x30a>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR1B |= (1 << CS10); /*CS10=1  CS11=0 CS12=0  */
    15c6:	8e e4       	ldi	r24, 0x4E	; 78
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	2e e4       	ldi	r18, 0x4E	; 78
    15cc:	30 e0       	ldi	r19, 0x00	; 0
    15ce:	f9 01       	movw	r30, r18
    15d0:	20 81       	ld	r18, Z
    15d2:	21 60       	ori	r18, 0x01	; 1
    15d4:	fc 01       	movw	r30, r24
    15d6:	20 83       	st	Z, r18

/****************************************************
* 		1-1 compare match output mode for TIMER1 A	*
* ***************************************************
*/
		if (!strcmp(config->mode, "compare")) {
    15d8:	89 81       	ldd	r24, Y+1	; 0x01
    15da:	9a 81       	ldd	r25, Y+2	; 0x02
    15dc:	01 96       	adiw	r24, 0x01	; 1
    15de:	65 e7       	ldi	r22, 0x75	; 117
    15e0:	70 e0       	ldi	r23, 0x00	; 0
    15e2:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    15e6:	89 2b       	or	r24, r25
    15e8:	09 f0       	breq	.+2      	; 0x15ec <TIMER_init+0x31e>
    15ea:	6b c0       	rjmp	.+214    	; 0x16c2 <TIMER_init+0x3f4>
			/*
			 * FOC1=1 for non PWM mode
			 * select compare mode --->> /* WGM10=0 ,  WGM11=0 , WGM12=1 and WGM13=0 */
			TCCR1A |= (1 << FOC1A);
    15ec:	8f e4       	ldi	r24, 0x4F	; 79
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	2f e4       	ldi	r18, 0x4F	; 79
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	f9 01       	movw	r30, r18
    15f6:	20 81       	ld	r18, Z
    15f8:	28 60       	ori	r18, 0x08	; 8
    15fa:	fc 01       	movw	r30, r24
    15fc:	20 83       	st	Z, r18
			TCCR1B |= (1 << WGM12);
    15fe:	8e e4       	ldi	r24, 0x4E	; 78
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	2e e4       	ldi	r18, 0x4E	; 78
    1604:	30 e0       	ldi	r19, 0x00	; 0
    1606:	f9 01       	movw	r30, r18
    1608:	20 81       	ld	r18, Z
    160a:	28 60       	ori	r18, 0x08	; 8
    160c:	fc 01       	movw	r30, r24
    160e:	20 83       	st	Z, r18
			if (!strcmp(config->compareMatchMode, "toggle")) {
    1610:	89 81       	ldd	r24, Y+1	; 0x01
    1612:	9a 81       	ldd	r25, Y+2	; 0x02
    1614:	47 96       	adiw	r24, 0x17	; 23
    1616:	6d e7       	ldi	r22, 0x7D	; 125
    1618:	70 e0       	ldi	r23, 0x00	; 0
    161a:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    161e:	89 2b       	or	r24, r25
    1620:	99 f4       	brne	.+38     	; 0x1648 <TIMER_init+0x37a>
				TCCR1A |= (1 << COM1A0); /*COM1A0=1 AND COM1A1=0 */
    1622:	8f e4       	ldi	r24, 0x4F	; 79
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	2f e4       	ldi	r18, 0x4F	; 79
    1628:	30 e0       	ldi	r19, 0x00	; 0
    162a:	f9 01       	movw	r30, r18
    162c:	20 81       	ld	r18, Z
    162e:	20 64       	ori	r18, 0x40	; 64
    1630:	fc 01       	movw	r30, r24
    1632:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);/*make OCO AS OUTPUT BIT */
    1634:	81 e3       	ldi	r24, 0x31	; 49
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	21 e3       	ldi	r18, 0x31	; 49
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	f9 01       	movw	r30, r18
    163e:	20 81       	ld	r18, Z
    1640:	20 62       	ori	r18, 0x20	; 32
    1642:	fc 01       	movw	r30, r24
    1644:	20 83       	st	Z, r18
    1646:	37 c0       	rjmp	.+110    	; 0x16b6 <TIMER_init+0x3e8>
			} else if (!strcmp(config->compareMatchMode, "clear")) {
    1648:	89 81       	ldd	r24, Y+1	; 0x01
    164a:	9a 81       	ldd	r25, Y+2	; 0x02
    164c:	47 96       	adiw	r24, 0x17	; 23
    164e:	64 e8       	ldi	r22, 0x84	; 132
    1650:	70 e0       	ldi	r23, 0x00	; 0
    1652:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1656:	89 2b       	or	r24, r25
    1658:	99 f4       	brne	.+38     	; 0x1680 <TIMER_init+0x3b2>
				TCCR1A |= (1 << COM1A1);/*COM1A0=0 AND COM1A1=1 */
    165a:	8f e4       	ldi	r24, 0x4F	; 79
    165c:	90 e0       	ldi	r25, 0x00	; 0
    165e:	2f e4       	ldi	r18, 0x4F	; 79
    1660:	30 e0       	ldi	r19, 0x00	; 0
    1662:	f9 01       	movw	r30, r18
    1664:	20 81       	ld	r18, Z
    1666:	20 68       	ori	r18, 0x80	; 128
    1668:	fc 01       	movw	r30, r24
    166a:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    166c:	81 e3       	ldi	r24, 0x31	; 49
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	21 e3       	ldi	r18, 0x31	; 49
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	f9 01       	movw	r30, r18
    1676:	20 81       	ld	r18, Z
    1678:	20 62       	ori	r18, 0x20	; 32
    167a:	fc 01       	movw	r30, r24
    167c:	20 83       	st	Z, r18
    167e:	1b c0       	rjmp	.+54     	; 0x16b6 <TIMER_init+0x3e8>

			} else if (!strcmp(config->compareMatchMode, "set")) {
    1680:	89 81       	ldd	r24, Y+1	; 0x01
    1682:	9a 81       	ldd	r25, Y+2	; 0x02
    1684:	47 96       	adiw	r24, 0x17	; 23
    1686:	6a e8       	ldi	r22, 0x8A	; 138
    1688:	70 e0       	ldi	r23, 0x00	; 0
    168a:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    168e:	89 2b       	or	r24, r25
    1690:	91 f4       	brne	.+36     	; 0x16b6 <TIMER_init+0x3e8>
				TCCR1A |= (1 << COM1A1) | (1 << COM1A0);/*COM1A0=1 AND COM1A1=1 */
    1692:	8f e4       	ldi	r24, 0x4F	; 79
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	2f e4       	ldi	r18, 0x4F	; 79
    1698:	30 e0       	ldi	r19, 0x00	; 0
    169a:	f9 01       	movw	r30, r18
    169c:	20 81       	ld	r18, Z
    169e:	20 6c       	ori	r18, 0xC0	; 192
    16a0:	fc 01       	movw	r30, r24
    16a2:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    16a4:	81 e3       	ldi	r24, 0x31	; 49
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	21 e3       	ldi	r18, 0x31	; 49
    16aa:	30 e0       	ldi	r19, 0x00	; 0
    16ac:	f9 01       	movw	r30, r18
    16ae:	20 81       	ld	r18, Z
    16b0:	20 62       	ori	r18, 0x20	; 32
    16b2:	fc 01       	movw	r30, r24
    16b4:	20 83       	st	Z, r18

			}
			/* the default case will be normal port operation OCO disconnected
							enable interrupt for compare mode */
			TIMSK = (1 << OCIE1A);
    16b6:	89 e5       	ldi	r24, 0x59	; 89
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	20 e1       	ldi	r18, 0x10	; 16
    16bc:	fc 01       	movw	r30, r24
    16be:	20 83       	st	Z, r18
    16c0:	6b c0       	rjmp	.+214    	; 0x1798 <TIMER_init+0x4ca>
/****************************************************
* 		1-2 normal  mode for TIMER1		      *
* ***************************************************
*/
		} else if (!strcmp(config->mode, "normal"))
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	9a 81       	ldd	r25, Y+2	; 0x02
    16c6:	01 96       	adiw	r24, 0x01	; 1
    16c8:	6e e8       	ldi	r22, 0x8E	; 142
    16ca:	70 e0       	ldi	r23, 0x00	; 0
    16cc:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    16d0:	89 2b       	or	r24, r25
    16d2:	79 f4       	brne	.+30     	; 0x16f2 <TIMER_init+0x424>
		{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM11=0 and WGM10=0
						 */
			TCCR1A |= (1 << FOC1A);
    16d4:	8f e4       	ldi	r24, 0x4F	; 79
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	2f e4       	ldi	r18, 0x4F	; 79
    16da:	30 e0       	ldi	r19, 0x00	; 0
    16dc:	f9 01       	movw	r30, r18
    16de:	20 81       	ld	r18, Z
    16e0:	28 60       	ori	r18, 0x08	; 8
    16e2:	fc 01       	movw	r30, r24
    16e4:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE1);
    16e6:	89 e5       	ldi	r24, 0x59	; 89
    16e8:	90 e0       	ldi	r25, 0x00	; 0
    16ea:	24 e0       	ldi	r18, 0x04	; 4
    16ec:	fc 01       	movw	r30, r24
    16ee:	20 83       	st	Z, r18
    16f0:	53 c0       	rjmp	.+166    	; 0x1798 <TIMER_init+0x4ca>


/****************************************************
 * 			1-3 PWM  mode for TIMER1 A		  *
 * ***************************************************/
		} else if (!strcmp(config->mode, "pwm")) {
    16f2:	89 81       	ldd	r24, Y+1	; 0x01
    16f4:	9a 81       	ldd	r25, Y+2	; 0x02
    16f6:	01 96       	adiw	r24, 0x01	; 1
    16f8:	65 e9       	ldi	r22, 0x95	; 149
    16fa:	70 e0       	ldi	r23, 0x00	; 0
    16fc:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1700:	89 2b       	or	r24, r25
    1702:	09 f0       	breq	.+2      	; 0x1706 <TIMER_init+0x438>
    1704:	49 c0       	rjmp	.+146    	; 0x1798 <TIMER_init+0x4ca>
			/* WGM10=1 ,  WGM11=1 , WGM12=1 and WGM13=1 */
			TCCR0 |= (1 << WGM10) | (1 << WGM11)| (1 << WGM12)| (1 << WGM13);
    1706:	83 e5       	ldi	r24, 0x53	; 83
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	23 e5       	ldi	r18, 0x53	; 83
    170c:	30 e0       	ldi	r19, 0x00	; 0
    170e:	f9 01       	movw	r30, r18
    1710:	20 81       	ld	r18, Z
    1712:	2b 61       	ori	r18, 0x1B	; 27
    1714:	fc 01       	movw	r30, r24
    1716:	20 83       	st	Z, r18
			if (!strcmp(config->pwmMode, "inverting")) {
    1718:	89 81       	ldd	r24, Y+1	; 0x01
    171a:	9a 81       	ldd	r25, Y+2	; 0x02
    171c:	8b 96       	adiw	r24, 0x2b	; 43
    171e:	69 e9       	ldi	r22, 0x99	; 153
    1720:	70 e0       	ldi	r23, 0x00	; 0
    1722:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1726:	89 2b       	or	r24, r25
    1728:	e1 f4       	brne	.+56     	; 0x1762 <TIMER_init+0x494>
				TCCR0 |= (1 << COM1A0);/* COM1A0=1 and COM1A1=1 */
    172a:	83 e5       	ldi	r24, 0x53	; 83
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	23 e5       	ldi	r18, 0x53	; 83
    1730:	30 e0       	ldi	r19, 0x00	; 0
    1732:	f9 01       	movw	r30, r18
    1734:	20 81       	ld	r18, Z
    1736:	20 64       	ori	r18, 0x40	; 64
    1738:	fc 01       	movw	r30, r24
    173a:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM1A1);
    173c:	83 e5       	ldi	r24, 0x53	; 83
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	23 e5       	ldi	r18, 0x53	; 83
    1742:	30 e0       	ldi	r19, 0x00	; 0
    1744:	f9 01       	movw	r30, r18
    1746:	20 81       	ld	r18, Z
    1748:	20 68       	ori	r18, 0x80	; 128
    174a:	fc 01       	movw	r30, r24
    174c:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    174e:	87 e3       	ldi	r24, 0x37	; 55
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	27 e3       	ldi	r18, 0x37	; 55
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	f9 01       	movw	r30, r18
    1758:	20 81       	ld	r18, Z
    175a:	28 60       	ori	r18, 0x08	; 8
    175c:	fc 01       	movw	r30, r24
    175e:	20 83       	st	Z, r18
    1760:	1b c0       	rjmp	.+54     	; 0x1798 <TIMER_init+0x4ca>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    1762:	89 81       	ldd	r24, Y+1	; 0x01
    1764:	9a 81       	ldd	r25, Y+2	; 0x02
    1766:	8b 96       	adiw	r24, 0x2b	; 43
    1768:	63 ea       	ldi	r22, 0xA3	; 163
    176a:	70 e0       	ldi	r23, 0x00	; 0
    176c:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1770:	89 2b       	or	r24, r25
    1772:	91 f4       	brne	.+36     	; 0x1798 <TIMER_init+0x4ca>
				TCCR0 |= (1 << COM1A1);/* COM1A0=0 and COM1A1=1 */
    1774:	83 e5       	ldi	r24, 0x53	; 83
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	23 e5       	ldi	r18, 0x53	; 83
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	f9 01       	movw	r30, r18
    177e:	20 81       	ld	r18, Z
    1780:	20 68       	ori	r18, 0x80	; 128
    1782:	fc 01       	movw	r30, r24
    1784:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    1786:	87 e3       	ldi	r24, 0x37	; 55
    1788:	90 e0       	ldi	r25, 0x00	; 0
    178a:	27 e3       	ldi	r18, 0x37	; 55
    178c:	30 e0       	ldi	r19, 0x00	; 0
    178e:	f9 01       	movw	r30, r18
    1790:	20 81       	ld	r18, Z
    1792:	28 60       	ori	r18, 0x08	; 8
    1794:	fc 01       	movw	r30, r24
    1796:	20 83       	st	Z, r18

		}
/***************************************************************
* 						2	TIMER2						*
 * *************************************************************/
		if (config->timerNumber == 2) {
    1798:	89 81       	ldd	r24, Y+1	; 0x01
    179a:	9a 81       	ldd	r25, Y+2	; 0x02
    179c:	fc 01       	movw	r30, r24
    179e:	80 81       	ld	r24, Z
    17a0:	82 30       	cpi	r24, 0x02	; 2
    17a2:	09 f0       	breq	.+2      	; 0x17a6 <TIMER_init+0x4d8>
    17a4:	3d c1       	rjmp	.+634    	; 0x1a20 <TIMER_init+0x752>
			TCCR2 = 0;/* put zeros into all bits in the register */
    17a6:	85 e4       	ldi	r24, 0x45	; 69
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	fc 01       	movw	r30, r24
    17ac:	10 82       	st	Z, r1
			switch (config->prescaler) {
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	fc 01       	movw	r30, r24
    17b4:	85 89       	ldd	r24, Z+21	; 0x15
    17b6:	96 89       	ldd	r25, Z+22	; 0x16
    17b8:	80 34       	cpi	r24, 0x40	; 64
    17ba:	91 05       	cpc	r25, r1
    17bc:	49 f1       	breq	.+82     	; 0x1810 <TIMER_init+0x542>
    17be:	81 34       	cpi	r24, 0x41	; 65
    17c0:	91 05       	cpc	r25, r1
    17c2:	30 f4       	brcc	.+12     	; 0x17d0 <TIMER_init+0x502>
    17c4:	88 30       	cpi	r24, 0x08	; 8
    17c6:	91 05       	cpc	r25, r1
    17c8:	79 f0       	breq	.+30     	; 0x17e8 <TIMER_init+0x51a>
    17ca:	80 97       	sbiw	r24, 0x20	; 32
    17cc:	b9 f0       	breq	.+46     	; 0x17fc <TIMER_init+0x52e>
    17ce:	48 c0       	rjmp	.+144    	; 0x1860 <TIMER_init+0x592>
    17d0:	81 15       	cp	r24, r1
    17d2:	f1 e0       	ldi	r31, 0x01	; 1
    17d4:	9f 07       	cpc	r25, r31
    17d6:	81 f1       	breq	.+96     	; 0x1838 <TIMER_init+0x56a>
    17d8:	81 15       	cp	r24, r1
    17da:	24 e0       	ldi	r18, 0x04	; 4
    17dc:	92 07       	cpc	r25, r18
    17de:	b1 f1       	breq	.+108    	; 0x184c <TIMER_init+0x57e>
    17e0:	80 38       	cpi	r24, 0x80	; 128
    17e2:	91 05       	cpc	r25, r1
    17e4:	f9 f0       	breq	.+62     	; 0x1824 <TIMER_init+0x556>
    17e6:	3c c0       	rjmp	.+120    	; 0x1860 <TIMER_init+0x592>
			case 8:
				TCCR2 |= (1 << CS21);/*CS20=0  CS21=1 CS22=0  */
    17e8:	85 e4       	ldi	r24, 0x45	; 69
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	25 e4       	ldi	r18, 0x45	; 69
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	f9 01       	movw	r30, r18
    17f2:	20 81       	ld	r18, Z
    17f4:	22 60       	ori	r18, 0x02	; 2
    17f6:	fc 01       	movw	r30, r24
    17f8:	20 83       	st	Z, r18
				break;
    17fa:	3b c0       	rjmp	.+118    	; 0x1872 <TIMER_init+0x5a4>
			case 32:
				TCCR2 |= (1 << CS20) | (1 << CS21);/*CS20=1  CS21=0 CS22=0  */
    17fc:	85 e4       	ldi	r24, 0x45	; 69
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	25 e4       	ldi	r18, 0x45	; 69
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	f9 01       	movw	r30, r18
    1806:	20 81       	ld	r18, Z
    1808:	23 60       	ori	r18, 0x03	; 3
    180a:	fc 01       	movw	r30, r24
    180c:	20 83       	st	Z, r18
				break;
    180e:	31 c0       	rjmp	.+98     	; 0x1872 <TIMER_init+0x5a4>
			case 64:
				TCCR2 |= (1 << CS22);/*CS20=0  CS21=0 CS22=1  */
    1810:	85 e4       	ldi	r24, 0x45	; 69
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	25 e4       	ldi	r18, 0x45	; 69
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	f9 01       	movw	r30, r18
    181a:	20 81       	ld	r18, Z
    181c:	24 60       	ori	r18, 0x04	; 4
    181e:	fc 01       	movw	r30, r24
    1820:	20 83       	st	Z, r18
				break;
    1822:	27 c0       	rjmp	.+78     	; 0x1872 <TIMER_init+0x5a4>
			case 128:
				TCCR2 |= (1 << CS20) | (1 << CS22);/*CS20=1  CS21=0 CS22=1  */
    1824:	85 e4       	ldi	r24, 0x45	; 69
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	25 e4       	ldi	r18, 0x45	; 69
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	f9 01       	movw	r30, r18
    182e:	20 81       	ld	r18, Z
    1830:	25 60       	ori	r18, 0x05	; 5
    1832:	fc 01       	movw	r30, r24
    1834:	20 83       	st	Z, r18
				break;
    1836:	1d c0       	rjmp	.+58     	; 0x1872 <TIMER_init+0x5a4>
			case 256:
				TCCR2 |= (1 << CS21) | (1 << CS22);/*CS20=0  CS21=1 CS22=1  */
    1838:	85 e4       	ldi	r24, 0x45	; 69
    183a:	90 e0       	ldi	r25, 0x00	; 0
    183c:	25 e4       	ldi	r18, 0x45	; 69
    183e:	30 e0       	ldi	r19, 0x00	; 0
    1840:	f9 01       	movw	r30, r18
    1842:	20 81       	ld	r18, Z
    1844:	26 60       	ori	r18, 0x06	; 6
    1846:	fc 01       	movw	r30, r24
    1848:	20 83       	st	Z, r18
				break;
    184a:	13 c0       	rjmp	.+38     	; 0x1872 <TIMER_init+0x5a4>
			case 1024:
				TCCR2 |= (1 << CS20) | (1 << CS21) | (1 << CS22);/*CS20=1  CS21=1 CS22=1  */
    184c:	85 e4       	ldi	r24, 0x45	; 69
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	25 e4       	ldi	r18, 0x45	; 69
    1852:	30 e0       	ldi	r19, 0x00	; 0
    1854:	f9 01       	movw	r30, r18
    1856:	20 81       	ld	r18, Z
    1858:	27 60       	ori	r18, 0x07	; 7
    185a:	fc 01       	movw	r30, r24
    185c:	20 83       	st	Z, r18
				break;
    185e:	09 c0       	rjmp	.+18     	; 0x1872 <TIMER_init+0x5a4>
			default:/* the default case work scale 1:1 even the prescaler member not determine */
				TCCR2 |= (1 << CS20);/*CS20=1  CS21=0 CS22=0  */
    1860:	85 e4       	ldi	r24, 0x45	; 69
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	25 e4       	ldi	r18, 0x45	; 69
    1866:	30 e0       	ldi	r19, 0x00	; 0
    1868:	f9 01       	movw	r30, r18
    186a:	20 81       	ld	r18, Z
    186c:	21 60       	ori	r18, 0x01	; 1
    186e:	fc 01       	movw	r30, r24
    1870:	20 83       	st	Z, r18

/****************************************************
* 		2-1 compare match output mode for TIMER2	*
 * ***************************************************
					 */
			if (!strcmp(config->mode, "compare")) {
    1872:	89 81       	ldd	r24, Y+1	; 0x01
    1874:	9a 81       	ldd	r25, Y+2	; 0x02
    1876:	01 96       	adiw	r24, 0x01	; 1
    1878:	65 e7       	ldi	r22, 0x75	; 117
    187a:	70 e0       	ldi	r23, 0x00	; 0
    187c:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1880:	89 2b       	or	r24, r25
    1882:	09 f0       	breq	.+2      	; 0x1886 <TIMER_init+0x5b8>
    1884:	62 c0       	rjmp	.+196    	; 0x194a <TIMER_init+0x67c>
				/*
				 * FOC2=1 for non PWM mode
				 * select compare mode --->> WGM21=1 and WGM20=0
				 */
				TCCR2 |= (1 << FOC2) | (1 << WGM21);
    1886:	85 e4       	ldi	r24, 0x45	; 69
    1888:	90 e0       	ldi	r25, 0x00	; 0
    188a:	25 e4       	ldi	r18, 0x45	; 69
    188c:	30 e0       	ldi	r19, 0x00	; 0
    188e:	f9 01       	movw	r30, r18
    1890:	20 81       	ld	r18, Z
    1892:	28 68       	ori	r18, 0x88	; 136
    1894:	fc 01       	movw	r30, r24
    1896:	20 83       	st	Z, r18

				if (!strcmp(config->compareMatchMode, "toggle")) {
    1898:	89 81       	ldd	r24, Y+1	; 0x01
    189a:	9a 81       	ldd	r25, Y+2	; 0x02
    189c:	47 96       	adiw	r24, 0x17	; 23
    189e:	6d e7       	ldi	r22, 0x7D	; 125
    18a0:	70 e0       	ldi	r23, 0x00	; 0
    18a2:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    18a6:	89 2b       	or	r24, r25
    18a8:	99 f4       	brne	.+38     	; 0x18d0 <TIMER_init+0x602>
					TCCR2 |= (1 << COM20);/*COM20=1 AND COM21=0 */
    18aa:	85 e4       	ldi	r24, 0x45	; 69
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	25 e4       	ldi	r18, 0x45	; 69
    18b0:	30 e0       	ldi	r19, 0x00	; 0
    18b2:	f9 01       	movw	r30, r18
    18b4:	20 81       	ld	r18, Z
    18b6:	20 61       	ori	r18, 0x10	; 16
    18b8:	fc 01       	movw	r30, r24
    18ba:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    18bc:	81 e3       	ldi	r24, 0x31	; 49
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	21 e3       	ldi	r18, 0x31	; 49
    18c2:	30 e0       	ldi	r19, 0x00	; 0
    18c4:	f9 01       	movw	r30, r18
    18c6:	20 81       	ld	r18, Z
    18c8:	20 68       	ori	r18, 0x80	; 128
    18ca:	fc 01       	movw	r30, r24
    18cc:	20 83       	st	Z, r18
    18ce:	37 c0       	rjmp	.+110    	; 0x193e <TIMER_init+0x670>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    18d0:	89 81       	ldd	r24, Y+1	; 0x01
    18d2:	9a 81       	ldd	r25, Y+2	; 0x02
    18d4:	47 96       	adiw	r24, 0x17	; 23
    18d6:	64 e8       	ldi	r22, 0x84	; 132
    18d8:	70 e0       	ldi	r23, 0x00	; 0
    18da:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    18de:	89 2b       	or	r24, r25
    18e0:	99 f4       	brne	.+38     	; 0x1908 <TIMER_init+0x63a>
					TCCR2 |= (1 << COM21);/*COM20=0 AND COM21=1 */
    18e2:	85 e4       	ldi	r24, 0x45	; 69
    18e4:	90 e0       	ldi	r25, 0x00	; 0
    18e6:	25 e4       	ldi	r18, 0x45	; 69
    18e8:	30 e0       	ldi	r19, 0x00	; 0
    18ea:	f9 01       	movw	r30, r18
    18ec:	20 81       	ld	r18, Z
    18ee:	20 62       	ori	r18, 0x20	; 32
    18f0:	fc 01       	movw	r30, r24
    18f2:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    18f4:	81 e3       	ldi	r24, 0x31	; 49
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	21 e3       	ldi	r18, 0x31	; 49
    18fa:	30 e0       	ldi	r19, 0x00	; 0
    18fc:	f9 01       	movw	r30, r18
    18fe:	20 81       	ld	r18, Z
    1900:	20 68       	ori	r18, 0x80	; 128
    1902:	fc 01       	movw	r30, r24
    1904:	20 83       	st	Z, r18
    1906:	1b c0       	rjmp	.+54     	; 0x193e <TIMER_init+0x670>

				} else if (!strcmp(config->compareMatchMode, "set")) {
    1908:	89 81       	ldd	r24, Y+1	; 0x01
    190a:	9a 81       	ldd	r25, Y+2	; 0x02
    190c:	47 96       	adiw	r24, 0x17	; 23
    190e:	6a e8       	ldi	r22, 0x8A	; 138
    1910:	70 e0       	ldi	r23, 0x00	; 0
    1912:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1916:	89 2b       	or	r24, r25
    1918:	91 f4       	brne	.+36     	; 0x193e <TIMER_init+0x670>
					TCCR2 |= (1 << COM21) | (1 << COM20);/*COM20=1 AND COM21=1 */
    191a:	85 e4       	ldi	r24, 0x45	; 69
    191c:	90 e0       	ldi	r25, 0x00	; 0
    191e:	25 e4       	ldi	r18, 0x45	; 69
    1920:	30 e0       	ldi	r19, 0x00	; 0
    1922:	f9 01       	movw	r30, r18
    1924:	20 81       	ld	r18, Z
    1926:	20 63       	ori	r18, 0x30	; 48
    1928:	fc 01       	movw	r30, r24
    192a:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    192c:	81 e3       	ldi	r24, 0x31	; 49
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	21 e3       	ldi	r18, 0x31	; 49
    1932:	30 e0       	ldi	r19, 0x00	; 0
    1934:	f9 01       	movw	r30, r18
    1936:	20 81       	ld	r18, Z
    1938:	20 68       	ori	r18, 0x80	; 128
    193a:	fc 01       	movw	r30, r24
    193c:	20 83       	st	Z, r18

				}
				/* the default case will be normal port operation OCO disconnected
											enable interrupt for compare mode */
				TIMSK = (1 << OCIE2);
    193e:	89 e5       	ldi	r24, 0x59	; 89
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	20 e8       	ldi	r18, 0x80	; 128
    1944:	fc 01       	movw	r30, r24
    1946:	20 83       	st	Z, r18
    1948:	6b c0       	rjmp	.+214    	; 0x1a20 <TIMER_init+0x752>

/****************************************************
* 		2-2 normal  mode for TIMER2		     *
 * ***************************************************
					 */
			else if (!strcmp(config->mode, "normal")) {
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	9a 81       	ldd	r25, Y+2	; 0x02
    194e:	01 96       	adiw	r24, 0x01	; 1
    1950:	6e e8       	ldi	r22, 0x8E	; 142
    1952:	70 e0       	ldi	r23, 0x00	; 0
    1954:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1958:	89 2b       	or	r24, r25
    195a:	79 f4       	brne	.+30     	; 0x197a <TIMER_init+0x6ac>
				/*
				 * FOC2=1 for non PWM mode
				 * select normal mode --->> WGM21=0 and WGM20=0
				*/
				TCCR2 |= (1 << FOC2);
    195c:	85 e4       	ldi	r24, 0x45	; 69
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	25 e4       	ldi	r18, 0x45	; 69
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	f9 01       	movw	r30, r18
    1966:	20 81       	ld	r18, Z
    1968:	20 68       	ori	r18, 0x80	; 128
    196a:	fc 01       	movw	r30, r24
    196c:	20 83       	st	Z, r18
				TIMSK = (1 << TOIE2); /*enable interrupt for normal mode */
    196e:	89 e5       	ldi	r24, 0x59	; 89
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	20 e4       	ldi	r18, 0x40	; 64
    1974:	fc 01       	movw	r30, r24
    1976:	20 83       	st	Z, r18
    1978:	53 c0       	rjmp	.+166    	; 0x1a20 <TIMER_init+0x752>

/****************************************************
 * 			2-3 PWM  mode for TIMER2	     *
 * ***************************************************/

			} else if (!strcmp(config->mode, "pwm")) {
    197a:	89 81       	ldd	r24, Y+1	; 0x01
    197c:	9a 81       	ldd	r25, Y+2	; 0x02
    197e:	01 96       	adiw	r24, 0x01	; 1
    1980:	65 e9       	ldi	r22, 0x95	; 149
    1982:	70 e0       	ldi	r23, 0x00	; 0
    1984:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1988:	89 2b       	or	r24, r25
    198a:	09 f0       	breq	.+2      	; 0x198e <TIMER_init+0x6c0>
    198c:	49 c0       	rjmp	.+146    	; 0x1a20 <TIMER_init+0x752>
				/*
				 * FOC2=0 for  PWM mode
				 * select PWM mode --->> WGM21=1 and WGM20=1
				 */

				TCCR2 |= (1 << WGM20) | (1 << WGM21);
    198e:	85 e4       	ldi	r24, 0x45	; 69
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	25 e4       	ldi	r18, 0x45	; 69
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	f9 01       	movw	r30, r18
    1998:	20 81       	ld	r18, Z
    199a:	28 64       	ori	r18, 0x48	; 72
    199c:	fc 01       	movw	r30, r24
    199e:	20 83       	st	Z, r18
				if (!strcmp(config->pwmMode, "inverting")) {
    19a0:	89 81       	ldd	r24, Y+1	; 0x01
    19a2:	9a 81       	ldd	r25, Y+2	; 0x02
    19a4:	8b 96       	adiw	r24, 0x2b	; 43
    19a6:	69 e9       	ldi	r22, 0x99	; 153
    19a8:	70 e0       	ldi	r23, 0x00	; 0
    19aa:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    19ae:	89 2b       	or	r24, r25
    19b0:	e1 f4       	brne	.+56     	; 0x19ea <TIMER_init+0x71c>
					/* COM20=1 and COM21=1 */
					TCCR2 |= (1 << COM20);
    19b2:	85 e4       	ldi	r24, 0x45	; 69
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	25 e4       	ldi	r18, 0x45	; 69
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	f9 01       	movw	r30, r18
    19bc:	20 81       	ld	r18, Z
    19be:	20 61       	ori	r18, 0x10	; 16
    19c0:	fc 01       	movw	r30, r24
    19c2:	20 83       	st	Z, r18
					TCCR2 |= (1 << COM21);
    19c4:	85 e4       	ldi	r24, 0x45	; 69
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	25 e4       	ldi	r18, 0x45	; 69
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	f9 01       	movw	r30, r18
    19ce:	20 81       	ld	r18, Z
    19d0:	20 62       	ori	r18, 0x20	; 32
    19d2:	fc 01       	movw	r30, r24
    19d4:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    19d6:	81 e3       	ldi	r24, 0x31	; 49
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	21 e3       	ldi	r18, 0x31	; 49
    19dc:	30 e0       	ldi	r19, 0x00	; 0
    19de:	f9 01       	movw	r30, r18
    19e0:	20 81       	ld	r18, Z
    19e2:	20 68       	ori	r18, 0x80	; 128
    19e4:	fc 01       	movw	r30, r24
    19e6:	20 83       	st	Z, r18
    19e8:	1b c0       	rjmp	.+54     	; 0x1a20 <TIMER_init+0x752>
				} else if (!strcmp(config->pwmMode, "non-inverting")) {
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	9a 81       	ldd	r25, Y+2	; 0x02
    19ee:	8b 96       	adiw	r24, 0x2b	; 43
    19f0:	63 ea       	ldi	r22, 0xA3	; 163
    19f2:	70 e0       	ldi	r23, 0x00	; 0
    19f4:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    19f8:	89 2b       	or	r24, r25
    19fa:	91 f4       	brne	.+36     	; 0x1a20 <TIMER_init+0x752>
					/* COM20=0 and COM21=1 */
					TCCR2 |= (1 << COM21);
    19fc:	85 e4       	ldi	r24, 0x45	; 69
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	25 e4       	ldi	r18, 0x45	; 69
    1a02:	30 e0       	ldi	r19, 0x00	; 0
    1a04:	f9 01       	movw	r30, r18
    1a06:	20 81       	ld	r18, Z
    1a08:	20 62       	ori	r18, 0x20	; 32
    1a0a:	fc 01       	movw	r30, r24
    1a0c:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    1a0e:	81 e3       	ldi	r24, 0x31	; 49
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	21 e3       	ldi	r18, 0x31	; 49
    1a14:	30 e0       	ldi	r19, 0x00	; 0
    1a16:	f9 01       	movw	r30, r18
    1a18:	20 81       	ld	r18, Z
    1a1a:	20 68       	ori	r18, 0x80	; 128
    1a1c:	fc 01       	movw	r30, r24
    1a1e:	20 83       	st	Z, r18

			}

		}
		/* global interrupt enable */
		sei();
    1a20:	78 94       	sei
	}
    1a22:	00 00       	nop
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	df 91       	pop	r29
    1a2a:	cf 91       	pop	r28
    1a2c:	08 95       	ret

00001a2e <TIMER_setCompare>:
 * 			 setting functions definition 			*
 * *******************************************************
 */

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
    1a2e:	cf 93       	push	r28
    1a30:	df 93       	push	r29
    1a32:	00 d0       	rcall	.+0      	; 0x1a34 <TIMER_setCompare+0x6>
    1a34:	cd b7       	in	r28, 0x3d	; 61
    1a36:	de b7       	in	r29, 0x3e	; 62
    1a38:	9a 83       	std	Y+2, r25	; 0x02
    1a3a:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1a3c:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1a40:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1a44:	fc 01       	movw	r30, r24
    1a46:	80 81       	ld	r24, Z
    1a48:	88 2f       	mov	r24, r24
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	81 30       	cpi	r24, 0x01	; 1
    1a4e:	91 05       	cpc	r25, r1
    1a50:	81 f0       	breq	.+32     	; 0x1a72 <TIMER_setCompare+0x44>
    1a52:	82 30       	cpi	r24, 0x02	; 2
    1a54:	91 05       	cpc	r25, r1
    1a56:	d1 f0       	breq	.+52     	; 0x1a8c <TIMER_setCompare+0x5e>
    1a58:	89 2b       	or	r24, r25
    1a5a:	09 f0       	breq	.+2      	; 0x1a5e <TIMER_setCompare+0x30>
	case 2:
		TCNT2 = 0;
		OCR2 = compareValue;
		break;
	}
}
    1a5c:	21 c0       	rjmp	.+66     	; 0x1aa0 <TIMER_setCompare+0x72>

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
	switch (configPtr->timerNumber) {
	case 0:/* timer number*/
		TCNT0 = 0;/* initial value */
    1a5e:	82 e5       	ldi	r24, 0x52	; 82
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	fc 01       	movw	r30, r24
    1a64:	10 82       	st	Z, r1
		OCR0 = compareValue; /*compare value */
    1a66:	8c e5       	ldi	r24, 0x5C	; 92
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	29 81       	ldd	r18, Y+1	; 0x01
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	20 83       	st	Z, r18
		break;
    1a70:	17 c0       	rjmp	.+46     	; 0x1aa0 <TIMER_setCompare+0x72>
	case 1:
		TCNT1 = 0;
    1a72:	8c e4       	ldi	r24, 0x4C	; 76
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	fc 01       	movw	r30, r24
    1a78:	11 82       	std	Z+1, r1	; 0x01
    1a7a:	10 82       	st	Z, r1
		OCR1A = compareValue;
    1a7c:	8a e4       	ldi	r24, 0x4A	; 74
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	29 81       	ldd	r18, Y+1	; 0x01
    1a82:	3a 81       	ldd	r19, Y+2	; 0x02
    1a84:	fc 01       	movw	r30, r24
    1a86:	31 83       	std	Z+1, r19	; 0x01
    1a88:	20 83       	st	Z, r18
		break;
    1a8a:	0a c0       	rjmp	.+20     	; 0x1aa0 <TIMER_setCompare+0x72>
	case 2:
		TCNT2 = 0;
    1a8c:	84 e4       	ldi	r24, 0x44	; 68
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	fc 01       	movw	r30, r24
    1a92:	10 82       	st	Z, r1
		OCR2 = compareValue;
    1a94:	83 e4       	ldi	r24, 0x43	; 67
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	29 81       	ldd	r18, Y+1	; 0x01
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	20 83       	st	Z, r18
		break;
    1a9e:	00 00       	nop
	}
}
    1aa0:	00 00       	nop
    1aa2:	0f 90       	pop	r0
    1aa4:	0f 90       	pop	r0
    1aa6:	df 91       	pop	r29
    1aa8:	cf 91       	pop	r28
    1aaa:	08 95       	ret

00001aac <TIMER_setNormal>:
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
    1aac:	cf 93       	push	r28
    1aae:	df 93       	push	r29
    1ab0:	1f 92       	push	r1
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
    1ab6:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1ab8:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1abc:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	80 81       	ld	r24, Z
    1ac4:	88 2f       	mov	r24, r24
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	81 30       	cpi	r24, 0x01	; 1
    1aca:	91 05       	cpc	r25, r1
    1acc:	61 f0       	breq	.+24     	; 0x1ae6 <TIMER_setNormal+0x3a>
    1ace:	82 30       	cpi	r24, 0x02	; 2
    1ad0:	91 05       	cpc	r25, r1
    1ad2:	91 f0       	breq	.+36     	; 0x1af8 <TIMER_setNormal+0x4c>
    1ad4:	89 2b       	or	r24, r25
    1ad6:	09 f0       	breq	.+2      	; 0x1ada <TIMER_setNormal+0x2e>
		TCNT2 = initValue;
		break;

	}
	/* function to set duty cycle value in PWM mode */
}
    1ad8:	15 c0       	rjmp	.+42     	; 0x1b04 <TIMER_setNormal+0x58>
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
	switch (configPtr->timerNumber) {
	case 0:
		TCNT0 = initValue;
    1ada:	82 e5       	ldi	r24, 0x52	; 82
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	29 81       	ldd	r18, Y+1	; 0x01
    1ae0:	fc 01       	movw	r30, r24
    1ae2:	20 83       	st	Z, r18
		break;
    1ae4:	0f c0       	rjmp	.+30     	; 0x1b04 <TIMER_setNormal+0x58>
	case 1:
		TCNT1 = initValue;
    1ae6:	8c e4       	ldi	r24, 0x4C	; 76
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	29 81       	ldd	r18, Y+1	; 0x01
    1aec:	22 2f       	mov	r18, r18
    1aee:	30 e0       	ldi	r19, 0x00	; 0
    1af0:	fc 01       	movw	r30, r24
    1af2:	31 83       	std	Z+1, r19	; 0x01
    1af4:	20 83       	st	Z, r18
		break;
    1af6:	06 c0       	rjmp	.+12     	; 0x1b04 <TIMER_setNormal+0x58>
	case 2:
		TCNT2 = initValue;
    1af8:	84 e4       	ldi	r24, 0x44	; 68
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	29 81       	ldd	r18, Y+1	; 0x01
    1afe:	fc 01       	movw	r30, r24
    1b00:	20 83       	st	Z, r18
		break;
    1b02:	00 00       	nop

	}
	/* function to set duty cycle value in PWM mode */
}
    1b04:	00 00       	nop
    1b06:	0f 90       	pop	r0
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	08 95       	ret

00001b0e <TIMER_setpwm>:
void TIMER_setpwm(uint8 dutyCycle) {
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	1f 92       	push	r1
    1b14:	cd b7       	in	r28, 0x3d	; 61
    1b16:	de b7       	in	r29, 0x3e	; 62
    1b18:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1b1a:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1b1e:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1b22:	fc 01       	movw	r30, r24
    1b24:	80 81       	ld	r24, Z
    1b26:	88 2f       	mov	r24, r24
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	81 30       	cpi	r24, 0x01	; 1
    1b2c:	91 05       	cpc	r25, r1
    1b2e:	81 f0       	breq	.+32     	; 0x1b50 <TIMER_setpwm+0x42>
    1b30:	82 30       	cpi	r24, 0x02	; 2
    1b32:	91 05       	cpc	r25, r1
    1b34:	d9 f0       	breq	.+54     	; 0x1b6c <TIMER_setpwm+0x5e>
    1b36:	89 2b       	or	r24, r25
    1b38:	09 f0       	breq	.+2      	; 0x1b3c <TIMER_setpwm+0x2e>
	case 2:
		TCNT2 = 0;
		OCR2 = dutyCycle;
		break;
	}
}
    1b3a:	22 c0       	rjmp	.+68     	; 0x1b80 <TIMER_setpwm+0x72>
}
void TIMER_setpwm(uint8 dutyCycle) {
	switch (configPtr->timerNumber) {

	case 0:
		TCNT0 = 0;
    1b3c:	82 e5       	ldi	r24, 0x52	; 82
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	fc 01       	movw	r30, r24
    1b42:	10 82       	st	Z, r1
		OCR0 = dutyCycle;
    1b44:	8c e5       	ldi	r24, 0x5C	; 92
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	29 81       	ldd	r18, Y+1	; 0x01
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	20 83       	st	Z, r18
		break;
    1b4e:	18 c0       	rjmp	.+48     	; 0x1b80 <TIMER_setpwm+0x72>
	case 1:
		TCNT1 = 0;
    1b50:	8c e4       	ldi	r24, 0x4C	; 76
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	fc 01       	movw	r30, r24
    1b56:	11 82       	std	Z+1, r1	; 0x01
    1b58:	10 82       	st	Z, r1
		OCR1A = dutyCycle;
    1b5a:	8a e4       	ldi	r24, 0x4A	; 74
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	29 81       	ldd	r18, Y+1	; 0x01
    1b60:	22 2f       	mov	r18, r18
    1b62:	30 e0       	ldi	r19, 0x00	; 0
    1b64:	fc 01       	movw	r30, r24
    1b66:	31 83       	std	Z+1, r19	; 0x01
    1b68:	20 83       	st	Z, r18
		break;
    1b6a:	0a c0       	rjmp	.+20     	; 0x1b80 <TIMER_setpwm+0x72>
	case 2:
		TCNT2 = 0;
    1b6c:	84 e4       	ldi	r24, 0x44	; 68
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	fc 01       	movw	r30, r24
    1b72:	10 82       	st	Z, r1
		OCR2 = dutyCycle;
    1b74:	83 e4       	ldi	r24, 0x43	; 67
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	29 81       	ldd	r18, Y+1	; 0x01
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	20 83       	st	Z, r18
		break;
    1b7e:	00 00       	nop
	}
}
    1b80:	00 00       	nop
    1b82:	0f 90       	pop	r0
    1b84:	df 91       	pop	r29
    1b86:	cf 91       	pop	r28
    1b88:	08 95       	ret

00001b8a <TIMER_setCallBackPtr>:
/* function to get adress of call back funtion to passing it for ISR */
void TIMER_setCallBackPtr(void (*a_ptr)(void)) {
    1b8a:	cf 93       	push	r28
    1b8c:	df 93       	push	r29
    1b8e:	00 d0       	rcall	.+0      	; 0x1b90 <TIMER_setCallBackPtr+0x6>
    1b90:	cd b7       	in	r28, 0x3d	; 61
    1b92:	de b7       	in	r29, 0x3e	; 62
    1b94:	9a 83       	std	Y+2, r25	; 0x02
    1b96:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr; /*g_callBackPtr is shared global variable */
    1b98:	89 81       	ldd	r24, Y+1	; 0x01
    1b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9c:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <g_callBackPtr+0x1>
    1ba0:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <g_callBackPtr>
}
    1ba4:	00 00       	nop
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	08 95       	ret

00001bb0 <TIMER_stop>:
/* function to stop the running timer */
void TIMER_stop() {
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
	switch (configPtr->timerNumber)
    1bb8:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1bbc:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	80 81       	ld	r24, Z
    1bc4:	88 2f       	mov	r24, r24
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	81 30       	cpi	r24, 0x01	; 1
    1bca:	91 05       	cpc	r25, r1
    1bcc:	81 f0       	breq	.+32     	; 0x1bee <TIMER_stop+0x3e>
    1bce:	82 30       	cpi	r24, 0x02	; 2
    1bd0:	91 05       	cpc	r25, r1
    1bd2:	b9 f0       	breq	.+46     	; 0x1c02 <TIMER_stop+0x52>
    1bd4:	89 2b       	or	r24, r25
    1bd6:	09 f0       	breq	.+2      	; 0x1bda <TIMER_stop+0x2a>
		break;
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
		break;
	}
}
    1bd8:	1e c0       	rjmp	.+60     	; 0x1c16 <TIMER_stop+0x66>
void TIMER_stop() {
	switch (configPtr->timerNumber)

	{
	case 0:
		TCCR0 &= ~(1 << CS00) & ~(1 << CS01) & ~(1 << CS02);
    1bda:	83 e5       	ldi	r24, 0x53	; 83
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	23 e5       	ldi	r18, 0x53	; 83
    1be0:	30 e0       	ldi	r19, 0x00	; 0
    1be2:	f9 01       	movw	r30, r18
    1be4:	20 81       	ld	r18, Z
    1be6:	28 7f       	andi	r18, 0xF8	; 248
    1be8:	fc 01       	movw	r30, r24
    1bea:	20 83       	st	Z, r18
		break;
    1bec:	14 c0       	rjmp	.+40     	; 0x1c16 <TIMER_stop+0x66>
	case 1:
		TCCR1B &= ~(1 << CS10) & ~(1 << CS11) & ~(1 << CS12);
    1bee:	8e e4       	ldi	r24, 0x4E	; 78
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	2e e4       	ldi	r18, 0x4E	; 78
    1bf4:	30 e0       	ldi	r19, 0x00	; 0
    1bf6:	f9 01       	movw	r30, r18
    1bf8:	20 81       	ld	r18, Z
    1bfa:	28 7f       	andi	r18, 0xF8	; 248
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	20 83       	st	Z, r18
		break;
    1c00:	0a c0       	rjmp	.+20     	; 0x1c16 <TIMER_stop+0x66>
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
    1c02:	85 e4       	ldi	r24, 0x45	; 69
    1c04:	90 e0       	ldi	r25, 0x00	; 0
    1c06:	25 e4       	ldi	r18, 0x45	; 69
    1c08:	30 e0       	ldi	r19, 0x00	; 0
    1c0a:	f9 01       	movw	r30, r18
    1c0c:	20 81       	ld	r18, Z
    1c0e:	28 7f       	andi	r18, 0xF8	; 248
    1c10:	fc 01       	movw	r30, r24
    1c12:	20 83       	st	Z, r18
		break;
    1c14:	00 00       	nop
	}
}
    1c16:	00 00       	nop
    1c18:	df 91       	pop	r29
    1c1a:	cf 91       	pop	r28
    1c1c:	08 95       	ret

00001c1e <UART_init>:
 */

/* configurate by passing UART  configuration structure */

void UART_init(UART_configurationType * config)
{/* put zeros into all bits in the registers */
    1c1e:	0f 93       	push	r16
    1c20:	1f 93       	push	r17
    1c22:	cf 93       	push	r28
    1c24:	df 93       	push	r29
    1c26:	00 d0       	rcall	.+0      	; 0x1c28 <UART_init+0xa>
    1c28:	cd b7       	in	r28, 0x3d	; 61
    1c2a:	de b7       	in	r29, 0x3e	; 62
    1c2c:	9a 83       	std	Y+2, r25	; 0x02
    1c2e:	89 83       	std	Y+1, r24	; 0x01
UCSRA=0;
    1c30:	8b e2       	ldi	r24, 0x2B	; 43
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	fc 01       	movw	r30, r24
    1c36:	10 82       	st	Z, r1
UCSRB=0;
    1c38:	8a e2       	ldi	r24, 0x2A	; 42
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	fc 01       	movw	r30, r24
    1c3e:	10 82       	st	Z, r1
UCSRC=0;
    1c40:	80 e4       	ldi	r24, 0x40	; 64
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	fc 01       	movw	r30, r24
    1c46:	10 82       	st	Z, r1
/* enables */
	if(!strcmp(config->mode,"normal"))
    1c48:	89 81       	ldd	r24, Y+1	; 0x01
    1c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c4c:	05 96       	adiw	r24, 0x05	; 5
    1c4e:	61 eb       	ldi	r22, 0xB1	; 177
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1c56:	89 2b       	or	r24, r25
    1c58:	09 f0       	breq	.+2      	; 0x1c5c <UART_init+0x3e>
    1c5a:	60 c0       	rjmp	.+192    	; 0x1d1c <UART_init+0xfe>
	{
CLEAR_BIT(UCSRA,U2X); /* disable double speed bit */
    1c5c:	8b e2       	ldi	r24, 0x2B	; 43
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	2b e2       	ldi	r18, 0x2B	; 43
    1c62:	30 e0       	ldi	r19, 0x00	; 0
    1c64:	f9 01       	movw	r30, r18
    1c66:	20 81       	ld	r18, Z
    1c68:	2d 7f       	andi	r18, 0xFD	; 253
    1c6a:	fc 01       	movw	r30, r24
    1c6c:	20 83       	st	Z, r18
/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
UBRRL=((F_CPU /(16*config->buadRate))-1);
    1c6e:	09 e2       	ldi	r16, 0x29	; 41
    1c70:	10 e0       	ldi	r17, 0x00	; 0
    1c72:	89 81       	ldd	r24, Y+1	; 0x01
    1c74:	9a 81       	ldd	r25, Y+2	; 0x02
    1c76:	fc 01       	movw	r30, r24
    1c78:	81 81       	ldd	r24, Z+1	; 0x01
    1c7a:	92 81       	ldd	r25, Z+2	; 0x02
    1c7c:	a3 81       	ldd	r26, Z+3	; 0x03
    1c7e:	b4 81       	ldd	r27, Z+4	; 0x04
    1c80:	88 0f       	add	r24, r24
    1c82:	99 1f       	adc	r25, r25
    1c84:	aa 1f       	adc	r26, r26
    1c86:	bb 1f       	adc	r27, r27
    1c88:	88 0f       	add	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	aa 1f       	adc	r26, r26
    1c8e:	bb 1f       	adc	r27, r27
    1c90:	88 0f       	add	r24, r24
    1c92:	99 1f       	adc	r25, r25
    1c94:	aa 1f       	adc	r26, r26
    1c96:	bb 1f       	adc	r27, r27
    1c98:	88 0f       	add	r24, r24
    1c9a:	99 1f       	adc	r25, r25
    1c9c:	aa 1f       	adc	r26, r26
    1c9e:	bb 1f       	adc	r27, r27
    1ca0:	9c 01       	movw	r18, r24
    1ca2:	ad 01       	movw	r20, r26
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
    1ca6:	92 e1       	ldi	r25, 0x12	; 18
    1ca8:	aa e7       	ldi	r26, 0x7A	; 122
    1caa:	b0 e0       	ldi	r27, 0x00	; 0
    1cac:	bc 01       	movw	r22, r24
    1cae:	cd 01       	movw	r24, r26
    1cb0:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
    1cb4:	da 01       	movw	r26, r20
    1cb6:	c9 01       	movw	r24, r18
    1cb8:	81 50       	subi	r24, 0x01	; 1
    1cba:	f8 01       	movw	r30, r16
    1cbc:	80 83       	st	Z, r24
UBRRH=((F_CPU /(16*config->buadRate))-1)>>8;
    1cbe:	00 e4       	ldi	r16, 0x40	; 64
    1cc0:	10 e0       	ldi	r17, 0x00	; 0
    1cc2:	89 81       	ldd	r24, Y+1	; 0x01
    1cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	81 81       	ldd	r24, Z+1	; 0x01
    1cca:	92 81       	ldd	r25, Z+2	; 0x02
    1ccc:	a3 81       	ldd	r26, Z+3	; 0x03
    1cce:	b4 81       	ldd	r27, Z+4	; 0x04
    1cd0:	88 0f       	add	r24, r24
    1cd2:	99 1f       	adc	r25, r25
    1cd4:	aa 1f       	adc	r26, r26
    1cd6:	bb 1f       	adc	r27, r27
    1cd8:	88 0f       	add	r24, r24
    1cda:	99 1f       	adc	r25, r25
    1cdc:	aa 1f       	adc	r26, r26
    1cde:	bb 1f       	adc	r27, r27
    1ce0:	88 0f       	add	r24, r24
    1ce2:	99 1f       	adc	r25, r25
    1ce4:	aa 1f       	adc	r26, r26
    1ce6:	bb 1f       	adc	r27, r27
    1ce8:	88 0f       	add	r24, r24
    1cea:	99 1f       	adc	r25, r25
    1cec:	aa 1f       	adc	r26, r26
    1cee:	bb 1f       	adc	r27, r27
    1cf0:	9c 01       	movw	r18, r24
    1cf2:	ad 01       	movw	r20, r26
    1cf4:	80 e0       	ldi	r24, 0x00	; 0
    1cf6:	92 e1       	ldi	r25, 0x12	; 18
    1cf8:	aa e7       	ldi	r26, 0x7A	; 122
    1cfa:	b0 e0       	ldi	r27, 0x00	; 0
    1cfc:	bc 01       	movw	r22, r24
    1cfe:	cd 01       	movw	r24, r26
    1d00:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
    1d04:	da 01       	movw	r26, r20
    1d06:	c9 01       	movw	r24, r18
    1d08:	01 97       	sbiw	r24, 0x01	; 1
    1d0a:	a1 09       	sbc	r26, r1
    1d0c:	b1 09       	sbc	r27, r1
    1d0e:	89 2f       	mov	r24, r25
    1d10:	9a 2f       	mov	r25, r26
    1d12:	ab 2f       	mov	r26, r27
    1d14:	bb 27       	eor	r27, r27
    1d16:	f8 01       	movw	r30, r16
    1d18:	80 83       	st	Z, r24
    1d1a:	61 c0       	rjmp	.+194    	; 0x1dde <UART_init+0x1c0>


	}
	else if(!strcmp(config->mode,"double speed"))
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d20:	05 96       	adiw	r24, 0x05	; 5
    1d22:	68 eb       	ldi	r22, 0xB8	; 184
    1d24:	70 e0       	ldi	r23, 0x00	; 0
    1d26:	0e 94 13 14 	call	0x2826	; 0x2826 <strcmp>
    1d2a:	89 2b       	or	r24, r25
    1d2c:	09 f0       	breq	.+2      	; 0x1d30 <UART_init+0x112>
    1d2e:	57 c0       	rjmp	.+174    	; 0x1dde <UART_init+0x1c0>
	{
		SET_BIT(UCSRA,U2X);/* enable double speed bit */
    1d30:	8b e2       	ldi	r24, 0x2B	; 43
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	2b e2       	ldi	r18, 0x2B	; 43
    1d36:	30 e0       	ldi	r19, 0x00	; 0
    1d38:	f9 01       	movw	r30, r18
    1d3a:	20 81       	ld	r18, Z
    1d3c:	22 60       	ori	r18, 0x02	; 2
    1d3e:	fc 01       	movw	r30, r24
    1d40:	20 83       	st	Z, r18
		/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
		UBRRL=((F_CPU /(8*config->buadRate))-1);
    1d42:	09 e2       	ldi	r16, 0x29	; 41
    1d44:	10 e0       	ldi	r17, 0x00	; 0
    1d46:	89 81       	ldd	r24, Y+1	; 0x01
    1d48:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4a:	fc 01       	movw	r30, r24
    1d4c:	81 81       	ldd	r24, Z+1	; 0x01
    1d4e:	92 81       	ldd	r25, Z+2	; 0x02
    1d50:	a3 81       	ldd	r26, Z+3	; 0x03
    1d52:	b4 81       	ldd	r27, Z+4	; 0x04
    1d54:	88 0f       	add	r24, r24
    1d56:	99 1f       	adc	r25, r25
    1d58:	aa 1f       	adc	r26, r26
    1d5a:	bb 1f       	adc	r27, r27
    1d5c:	88 0f       	add	r24, r24
    1d5e:	99 1f       	adc	r25, r25
    1d60:	aa 1f       	adc	r26, r26
    1d62:	bb 1f       	adc	r27, r27
    1d64:	88 0f       	add	r24, r24
    1d66:	99 1f       	adc	r25, r25
    1d68:	aa 1f       	adc	r26, r26
    1d6a:	bb 1f       	adc	r27, r27
    1d6c:	9c 01       	movw	r18, r24
    1d6e:	ad 01       	movw	r20, r26
    1d70:	80 e0       	ldi	r24, 0x00	; 0
    1d72:	92 e1       	ldi	r25, 0x12	; 18
    1d74:	aa e7       	ldi	r26, 0x7A	; 122
    1d76:	b0 e0       	ldi	r27, 0x00	; 0
    1d78:	bc 01       	movw	r22, r24
    1d7a:	cd 01       	movw	r24, r26
    1d7c:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
    1d80:	da 01       	movw	r26, r20
    1d82:	c9 01       	movw	r24, r18
    1d84:	81 50       	subi	r24, 0x01	; 1
    1d86:	f8 01       	movw	r30, r16
    1d88:	80 83       	st	Z, r24
		UBRRH=((F_CPU /(8*config->buadRate))-1)>>8;
    1d8a:	00 e4       	ldi	r16, 0x40	; 64
    1d8c:	10 e0       	ldi	r17, 0x00	; 0
    1d8e:	89 81       	ldd	r24, Y+1	; 0x01
    1d90:	9a 81       	ldd	r25, Y+2	; 0x02
    1d92:	fc 01       	movw	r30, r24
    1d94:	81 81       	ldd	r24, Z+1	; 0x01
    1d96:	92 81       	ldd	r25, Z+2	; 0x02
    1d98:	a3 81       	ldd	r26, Z+3	; 0x03
    1d9a:	b4 81       	ldd	r27, Z+4	; 0x04
    1d9c:	88 0f       	add	r24, r24
    1d9e:	99 1f       	adc	r25, r25
    1da0:	aa 1f       	adc	r26, r26
    1da2:	bb 1f       	adc	r27, r27
    1da4:	88 0f       	add	r24, r24
    1da6:	99 1f       	adc	r25, r25
    1da8:	aa 1f       	adc	r26, r26
    1daa:	bb 1f       	adc	r27, r27
    1dac:	88 0f       	add	r24, r24
    1dae:	99 1f       	adc	r25, r25
    1db0:	aa 1f       	adc	r26, r26
    1db2:	bb 1f       	adc	r27, r27
    1db4:	9c 01       	movw	r18, r24
    1db6:	ad 01       	movw	r20, r26
    1db8:	80 e0       	ldi	r24, 0x00	; 0
    1dba:	92 e1       	ldi	r25, 0x12	; 18
    1dbc:	aa e7       	ldi	r26, 0x7A	; 122
    1dbe:	b0 e0       	ldi	r27, 0x00	; 0
    1dc0:	bc 01       	movw	r22, r24
    1dc2:	cd 01       	movw	r24, r26
    1dc4:	0e 94 35 10 	call	0x206a	; 0x206a <__udivmodsi4>
    1dc8:	da 01       	movw	r26, r20
    1dca:	c9 01       	movw	r24, r18
    1dcc:	01 97       	sbiw	r24, 0x01	; 1
    1dce:	a1 09       	sbc	r26, r1
    1dd0:	b1 09       	sbc	r27, r1
    1dd2:	89 2f       	mov	r24, r25
    1dd4:	9a 2f       	mov	r25, r26
    1dd6:	ab 2f       	mov	r26, r27
    1dd8:	bb 27       	eor	r27, r27
    1dda:	f8 01       	movw	r30, r16
    1ddc:	80 83       	st	Z, r24

	}


/* TO enable writing on Register UCSRC (used for define the frame )as it has the same address with UBRR register */
SET_BIT(UCSRC,URSEL);
    1dde:	80 e4       	ldi	r24, 0x40	; 64
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	20 e4       	ldi	r18, 0x40	; 64
    1de4:	30 e0       	ldi	r19, 0x00	; 0
    1de6:	f9 01       	movw	r30, r18
    1de8:	20 81       	ld	r18, Z
    1dea:	20 68       	ori	r18, 0x80	; 128
    1dec:	fc 01       	movw	r30, r24
    1dee:	20 83       	st	Z, r18
/* the UART frame parameters*/
/* character size */

switch(config->character_size)
    1df0:	89 81       	ldd	r24, Y+1	; 0x01
    1df2:	9a 81       	ldd	r25, Y+2	; 0x02
    1df4:	fc 01       	movw	r30, r24
    1df6:	80 81       	ld	r24, Z
    1df8:	88 2f       	mov	r24, r24
    1dfa:	90 e0       	ldi	r25, 0x00	; 0
    1dfc:	86 30       	cpi	r24, 0x06	; 6
    1dfe:	91 05       	cpc	r25, r1
    1e00:	f9 f0       	breq	.+62     	; 0x1e40 <UART_init+0x222>
    1e02:	87 30       	cpi	r24, 0x07	; 7
    1e04:	91 05       	cpc	r25, r1
    1e06:	1c f4       	brge	.+6      	; 0x1e0e <UART_init+0x1f0>
    1e08:	05 97       	sbiw	r24, 0x05	; 5
    1e0a:	39 f0       	breq	.+14     	; 0x1e1a <UART_init+0x1fc>
    1e0c:	5b c0       	rjmp	.+182    	; 0x1ec4 <UART_init+0x2a6>
    1e0e:	87 30       	cpi	r24, 0x07	; 7
    1e10:	91 05       	cpc	r25, r1
    1e12:	49 f1       	breq	.+82     	; 0x1e66 <UART_init+0x248>
    1e14:	09 97       	sbiw	r24, 0x09	; 9
    1e16:	d1 f1       	breq	.+116    	; 0x1e8c <UART_init+0x26e>
    1e18:	55 c0       	rjmp	.+170    	; 0x1ec4 <UART_init+0x2a6>
{
case 5:
	/* UCSZ0 =0, UCSZ1=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e1a:	80 e4       	ldi	r24, 0x40	; 64
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	20 e4       	ldi	r18, 0x40	; 64
    1e20:	30 e0       	ldi	r19, 0x00	; 0
    1e22:	f9 01       	movw	r30, r18
    1e24:	20 81       	ld	r18, Z
    1e26:	2d 7f       	andi	r18, 0xFD	; 253
    1e28:	fc 01       	movw	r30, r24
    1e2a:	20 83       	st	Z, r18
	CLEAR_BIT(UCSRC,UCSZ1);
    1e2c:	80 e4       	ldi	r24, 0x40	; 64
    1e2e:	90 e0       	ldi	r25, 0x00	; 0
    1e30:	20 e4       	ldi	r18, 0x40	; 64
    1e32:	30 e0       	ldi	r19, 0x00	; 0
    1e34:	f9 01       	movw	r30, r18
    1e36:	20 81       	ld	r18, Z
    1e38:	2b 7f       	andi	r18, 0xFB	; 251
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	20 83       	st	Z, r18
	break;
    1e3e:	54 c0       	rjmp	.+168    	; 0x1ee8 <UART_init+0x2ca>

case 6:
	/* UCSZ0 =0, UCSZ1=1,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e40:	80 e4       	ldi	r24, 0x40	; 64
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	20 e4       	ldi	r18, 0x40	; 64
    1e46:	30 e0       	ldi	r19, 0x00	; 0
    1e48:	f9 01       	movw	r30, r18
    1e4a:	20 81       	ld	r18, Z
    1e4c:	2d 7f       	andi	r18, 0xFD	; 253
    1e4e:	fc 01       	movw	r30, r24
    1e50:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1e52:	80 e4       	ldi	r24, 0x40	; 64
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	20 e4       	ldi	r18, 0x40	; 64
    1e58:	30 e0       	ldi	r19, 0x00	; 0
    1e5a:	f9 01       	movw	r30, r18
    1e5c:	20 81       	ld	r18, Z
    1e5e:	24 60       	ori	r18, 0x04	; 4
    1e60:	fc 01       	movw	r30, r24
    1e62:	20 83       	st	Z, r18
	break;
    1e64:	41 c0       	rjmp	.+130    	; 0x1ee8 <UART_init+0x2ca>
case 7:
	/* UCSZ0 =1, UCSZ=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ1);
    1e66:	80 e4       	ldi	r24, 0x40	; 64
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	20 e4       	ldi	r18, 0x40	; 64
    1e6c:	30 e0       	ldi	r19, 0x00	; 0
    1e6e:	f9 01       	movw	r30, r18
    1e70:	20 81       	ld	r18, Z
    1e72:	2b 7f       	andi	r18, 0xFB	; 251
    1e74:	fc 01       	movw	r30, r24
    1e76:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ0);
    1e78:	80 e4       	ldi	r24, 0x40	; 64
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	20 e4       	ldi	r18, 0x40	; 64
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	f9 01       	movw	r30, r18
    1e82:	20 81       	ld	r18, Z
    1e84:	22 60       	ori	r18, 0x02	; 2
    1e86:	fc 01       	movw	r30, r24
    1e88:	20 83       	st	Z, r18
		break;
    1e8a:	2e c0       	rjmp	.+92     	; 0x1ee8 <UART_init+0x2ca>
case 9:
	/* UCSZ0 =1, UCSZ1=0,UCSZ2=1 */
	SET_BIT(UCSRC,UCSZ0);
    1e8c:	80 e4       	ldi	r24, 0x40	; 64
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	20 e4       	ldi	r18, 0x40	; 64
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	f9 01       	movw	r30, r18
    1e96:	20 81       	ld	r18, Z
    1e98:	22 60       	ori	r18, 0x02	; 2
    1e9a:	fc 01       	movw	r30, r24
    1e9c:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1e9e:	80 e4       	ldi	r24, 0x40	; 64
    1ea0:	90 e0       	ldi	r25, 0x00	; 0
    1ea2:	20 e4       	ldi	r18, 0x40	; 64
    1ea4:	30 e0       	ldi	r19, 0x00	; 0
    1ea6:	f9 01       	movw	r30, r18
    1ea8:	20 81       	ld	r18, Z
    1eaa:	24 60       	ori	r18, 0x04	; 4
    1eac:	fc 01       	movw	r30, r24
    1eae:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ2);
    1eb0:	80 e4       	ldi	r24, 0x40	; 64
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	20 e4       	ldi	r18, 0x40	; 64
    1eb6:	30 e0       	ldi	r19, 0x00	; 0
    1eb8:	f9 01       	movw	r30, r18
    1eba:	20 81       	ld	r18, Z
    1ebc:	24 60       	ori	r18, 0x04	; 4
    1ebe:	fc 01       	movw	r30, r24
    1ec0:	20 83       	st	Z, r18


	break;
    1ec2:	12 c0       	rjmp	.+36     	; 0x1ee8 <UART_init+0x2ca>

default :
	/* the default will be 8bits */
	/* UCSZ0 =1, UCSZ1=1,UCSZ2=0 */
	SET_BIT(UCSRC,UCSZ0);
    1ec4:	80 e4       	ldi	r24, 0x40	; 64
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	20 e4       	ldi	r18, 0x40	; 64
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	f9 01       	movw	r30, r18
    1ece:	20 81       	ld	r18, Z
    1ed0:	22 60       	ori	r18, 0x02	; 2
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1ed6:	80 e4       	ldi	r24, 0x40	; 64
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	20 e4       	ldi	r18, 0x40	; 64
    1edc:	30 e0       	ldi	r19, 0x00	; 0
    1ede:	f9 01       	movw	r30, r18
    1ee0:	20 81       	ld	r18, Z
    1ee2:	24 60       	ori	r18, 0x04	; 4
    1ee4:	fc 01       	movw	r30, r24
    1ee6:	20 83       	st	Z, r18
}

/* enable uart receive and transmit */
SET_BIT(UCSRB,RXEN);
    1ee8:	8a e2       	ldi	r24, 0x2A	; 42
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	2a e2       	ldi	r18, 0x2A	; 42
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	f9 01       	movw	r30, r18
    1ef2:	20 81       	ld	r18, Z
    1ef4:	20 61       	ori	r18, 0x10	; 16
    1ef6:	fc 01       	movw	r30, r24
    1ef8:	20 83       	st	Z, r18
SET_BIT(UCSRB,TXEN);
    1efa:	8a e2       	ldi	r24, 0x2A	; 42
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	2a e2       	ldi	r18, 0x2A	; 42
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	f9 01       	movw	r30, r18
    1f04:	20 81       	ld	r18, Z
    1f06:	28 60       	ori	r18, 0x08	; 8
    1f08:	fc 01       	movw	r30, r24
    1f0a:	20 83       	st	Z, r18
}
    1f0c:	00 00       	nop
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	df 91       	pop	r29
    1f14:	cf 91       	pop	r28
    1f16:	1f 91       	pop	r17
    1f18:	0f 91       	pop	r16
    1f1a:	08 95       	ret

00001f1c <UART_receiveByte>:

uint8 UART_receiveByte(void)
{
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
    1f20:	cd b7       	in	r28, 0x3d	; 61
    1f22:	de b7       	in	r29, 0x3e	; 62
	while(BIT_IS_CLEAR(UCSRA,RXC)); /* wait until RXC  flag be 1 it means that there is data not read */
    1f24:	00 00       	nop
    1f26:	8b e2       	ldi	r24, 0x2B	; 43
    1f28:	90 e0       	ldi	r25, 0x00	; 0
    1f2a:	fc 01       	movw	r30, r24
    1f2c:	80 81       	ld	r24, Z
    1f2e:	88 23       	and	r24, r24
    1f30:	d4 f7       	brge	.-12     	; 0x1f26 <UART_receiveByte+0xa>

	return UDR;/* read and return RXC flag to zero */
    1f32:	8c e2       	ldi	r24, 0x2C	; 44
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	fc 01       	movw	r30, r24
    1f38:	80 81       	ld	r24, Z
}
    1f3a:	df 91       	pop	r29
    1f3c:	cf 91       	pop	r28
    1f3e:	08 95       	ret

00001f40 <UART_sendByte>:
void UART_sendByte(const uint8 data)
{
    1f40:	cf 93       	push	r28
    1f42:	df 93       	push	r29
    1f44:	1f 92       	push	r1
    1f46:	cd b7       	in	r28, 0x3d	; 61
    1f48:	de b7       	in	r29, 0x3e	; 62
    1f4a:	89 83       	std	Y+1, r24	; 0x01
	UDR=data; /*store data in shift register UDR from less significant bit */
    1f4c:	8c e2       	ldi	r24, 0x2C	; 44
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
    1f50:	29 81       	ldd	r18, Y+1	; 0x01
    1f52:	fc 01       	movw	r30, r24
    1f54:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(UCSRA,TXC));/*wait until send data txc =1*/
    1f56:	00 00       	nop
    1f58:	8b e2       	ldi	r24, 0x2B	; 43
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	fc 01       	movw	r30, r24
    1f5e:	80 81       	ld	r24, Z
    1f60:	88 2f       	mov	r24, r24
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	80 74       	andi	r24, 0x40	; 64
    1f66:	99 27       	eor	r25, r25
    1f68:	89 2b       	or	r24, r25
    1f6a:	b1 f3       	breq	.-20     	; 0x1f58 <UART_sendByte+0x18>
	SET_BIT(UCSRA,TXC); /*clear the flag as it doesnt clear automatically as no interrupt or ISR*/
    1f6c:	8b e2       	ldi	r24, 0x2B	; 43
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	2b e2       	ldi	r18, 0x2B	; 43
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	f9 01       	movw	r30, r18
    1f76:	20 81       	ld	r18, Z
    1f78:	20 64       	ori	r18, 0x40	; 64
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	20 83       	st	Z, r18

}
    1f7e:	00 00       	nop
    1f80:	0f 90       	pop	r0
    1f82:	df 91       	pop	r29
    1f84:	cf 91       	pop	r28
    1f86:	08 95       	ret

00001f88 <UART_sendString>:
void UART_sendString(uint8 *str)
{
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	00 d0       	rcall	.+0      	; 0x1f8e <UART_sendString+0x6>
    1f8e:	1f 92       	push	r1
    1f90:	cd b7       	in	r28, 0x3d	; 61
    1f92:	de b7       	in	r29, 0x3e	; 62
    1f94:	9b 83       	std	Y+3, r25	; 0x03
    1f96:	8a 83       	std	Y+2, r24	; 0x02
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
    1f98:	19 82       	std	Y+1, r1	; 0x01
		while(str[i] != '\0')
    1f9a:	0e c0       	rjmp	.+28     	; 0x1fb8 <UART_sendString+0x30>
		{
			UART_sendByte(str[i]);
    1f9c:	89 81       	ldd	r24, Y+1	; 0x01
    1f9e:	88 2f       	mov	r24, r24
    1fa0:	90 e0       	ldi	r25, 0x00	; 0
    1fa2:	2a 81       	ldd	r18, Y+2	; 0x02
    1fa4:	3b 81       	ldd	r19, Y+3	; 0x03
    1fa6:	82 0f       	add	r24, r18
    1fa8:	93 1f       	adc	r25, r19
    1faa:	fc 01       	movw	r30, r24
    1fac:	80 81       	ld	r24, Z
    1fae:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>
			i++;
    1fb2:	89 81       	ldd	r24, Y+1	; 0x01
    1fb4:	8f 5f       	subi	r24, 0xFF	; 255
    1fb6:	89 83       	std	Y+1, r24	; 0x01
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
		while(str[i] != '\0')
    1fb8:	89 81       	ldd	r24, Y+1	; 0x01
    1fba:	88 2f       	mov	r24, r24
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	2a 81       	ldd	r18, Y+2	; 0x02
    1fc0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fc2:	82 0f       	add	r24, r18
    1fc4:	93 1f       	adc	r25, r19
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	80 81       	ld	r24, Z
    1fca:	88 23       	and	r24, r24
    1fcc:	39 f7       	brne	.-50     	; 0x1f9c <UART_sendString+0x14>
		{
			UART_sendByte(str[i]);
			i++;
		}
	UART_sendByte('#');
    1fce:	83 e2       	ldi	r24, 0x23	; 35
    1fd0:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <UART_sendByte>

}
    1fd4:	00 00       	nop
    1fd6:	0f 90       	pop	r0
    1fd8:	0f 90       	pop	r0
    1fda:	0f 90       	pop	r0
    1fdc:	df 91       	pop	r29
    1fde:	cf 91       	pop	r28
    1fe0:	08 95       	ret

00001fe2 <UART_receiveString>:
void UART_receiveString(uint8 *str)
{ /*
    1fe2:	0f 93       	push	r16
    1fe4:	1f 93       	push	r17
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <UART_receiveString+0xa>
    1fec:	1f 92       	push	r1
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	9b 83       	std	Y+3, r25	; 0x03
    1ff4:	8a 83       	std	Y+2, r24	; 0x02
at first receive first byte then check the  pre define pattern # may be empty string ""
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
    1ff6:	19 82       	std	Y+1, r1	; 0x01
		str[i] = UART_receiveByte();
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	88 2f       	mov	r24, r24
    1ffc:	90 e0       	ldi	r25, 0x00	; 0
    1ffe:	2a 81       	ldd	r18, Y+2	; 0x02
    2000:	3b 81       	ldd	r19, Y+3	; 0x03
    2002:	89 01       	movw	r16, r18
    2004:	08 0f       	add	r16, r24
    2006:	19 1f       	adc	r17, r25
    2008:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <UART_receiveByte>
    200c:	f8 01       	movw	r30, r16
    200e:	80 83       	st	Z, r24
		while(str[i] != '#')
    2010:	0f c0       	rjmp	.+30     	; 0x2030 <UART_receiveString+0x4e>
		{
			i++;
    2012:	89 81       	ldd	r24, Y+1	; 0x01
    2014:	8f 5f       	subi	r24, 0xFF	; 255
    2016:	89 83       	std	Y+1, r24	; 0x01
			str[i] = UART_receiveByte();
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	88 2f       	mov	r24, r24
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	2a 81       	ldd	r18, Y+2	; 0x02
    2020:	3b 81       	ldd	r19, Y+3	; 0x03
    2022:	89 01       	movw	r16, r18
    2024:	08 0f       	add	r16, r24
    2026:	19 1f       	adc	r17, r25
    2028:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <UART_receiveByte>
    202c:	f8 01       	movw	r30, r16
    202e:	80 83       	st	Z, r24
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
		str[i] = UART_receiveByte();
		while(str[i] != '#')
    2030:	89 81       	ldd	r24, Y+1	; 0x01
    2032:	88 2f       	mov	r24, r24
    2034:	90 e0       	ldi	r25, 0x00	; 0
    2036:	2a 81       	ldd	r18, Y+2	; 0x02
    2038:	3b 81       	ldd	r19, Y+3	; 0x03
    203a:	82 0f       	add	r24, r18
    203c:	93 1f       	adc	r25, r19
    203e:	fc 01       	movw	r30, r24
    2040:	80 81       	ld	r24, Z
    2042:	83 32       	cpi	r24, 0x23	; 35
    2044:	31 f7       	brne	.-52     	; 0x2012 <UART_receiveString+0x30>
		{
			i++;
			str[i] = UART_receiveByte();
		}
		str[i] = '\0';
    2046:	89 81       	ldd	r24, Y+1	; 0x01
    2048:	88 2f       	mov	r24, r24
    204a:	90 e0       	ldi	r25, 0x00	; 0
    204c:	2a 81       	ldd	r18, Y+2	; 0x02
    204e:	3b 81       	ldd	r19, Y+3	; 0x03
    2050:	82 0f       	add	r24, r18
    2052:	93 1f       	adc	r25, r19
    2054:	fc 01       	movw	r30, r24
    2056:	10 82       	st	Z, r1
}
    2058:	00 00       	nop
    205a:	0f 90       	pop	r0
    205c:	0f 90       	pop	r0
    205e:	0f 90       	pop	r0
    2060:	df 91       	pop	r29
    2062:	cf 91       	pop	r28
    2064:	1f 91       	pop	r17
    2066:	0f 91       	pop	r16
    2068:	08 95       	ret

0000206a <__udivmodsi4>:
    206a:	a1 e2       	ldi	r26, 0x21	; 33
    206c:	1a 2e       	mov	r1, r26
    206e:	aa 1b       	sub	r26, r26
    2070:	bb 1b       	sub	r27, r27
    2072:	fd 01       	movw	r30, r26
    2074:	0d c0       	rjmp	.+26     	; 0x2090 <__udivmodsi4_ep>

00002076 <__udivmodsi4_loop>:
    2076:	aa 1f       	adc	r26, r26
    2078:	bb 1f       	adc	r27, r27
    207a:	ee 1f       	adc	r30, r30
    207c:	ff 1f       	adc	r31, r31
    207e:	a2 17       	cp	r26, r18
    2080:	b3 07       	cpc	r27, r19
    2082:	e4 07       	cpc	r30, r20
    2084:	f5 07       	cpc	r31, r21
    2086:	20 f0       	brcs	.+8      	; 0x2090 <__udivmodsi4_ep>
    2088:	a2 1b       	sub	r26, r18
    208a:	b3 0b       	sbc	r27, r19
    208c:	e4 0b       	sbc	r30, r20
    208e:	f5 0b       	sbc	r31, r21

00002090 <__udivmodsi4_ep>:
    2090:	66 1f       	adc	r22, r22
    2092:	77 1f       	adc	r23, r23
    2094:	88 1f       	adc	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	1a 94       	dec	r1
    209a:	69 f7       	brne	.-38     	; 0x2076 <__udivmodsi4_loop>
    209c:	60 95       	com	r22
    209e:	70 95       	com	r23
    20a0:	80 95       	com	r24
    20a2:	90 95       	com	r25
    20a4:	9b 01       	movw	r18, r22
    20a6:	ac 01       	movw	r20, r24
    20a8:	bd 01       	movw	r22, r26
    20aa:	cf 01       	movw	r24, r30
    20ac:	08 95       	ret

000020ae <__subsf3>:
    20ae:	50 58       	subi	r21, 0x80	; 128

000020b0 <__addsf3>:
    20b0:	bb 27       	eor	r27, r27
    20b2:	aa 27       	eor	r26, r26
    20b4:	0e 94 6f 10 	call	0x20de	; 0x20de <__addsf3x>
    20b8:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__fp_round>
    20bc:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__fp_pscA>
    20c0:	38 f0       	brcs	.+14     	; 0x20d0 <__addsf3+0x20>
    20c2:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__fp_pscB>
    20c6:	20 f0       	brcs	.+8      	; 0x20d0 <__addsf3+0x20>
    20c8:	39 f4       	brne	.+14     	; 0x20d8 <__addsf3+0x28>
    20ca:	9f 3f       	cpi	r25, 0xFF	; 255
    20cc:	19 f4       	brne	.+6      	; 0x20d4 <__addsf3+0x24>
    20ce:	26 f4       	brtc	.+8      	; 0x20d8 <__addsf3+0x28>
    20d0:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>
    20d4:	0e f4       	brtc	.+2      	; 0x20d8 <__addsf3+0x28>
    20d6:	e0 95       	com	r30
    20d8:	e7 fb       	bst	r30, 7
    20da:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>

000020de <__addsf3x>:
    20de:	e9 2f       	mov	r30, r25
    20e0:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__fp_split3>
    20e4:	58 f3       	brcs	.-42     	; 0x20bc <__addsf3+0xc>
    20e6:	ba 17       	cp	r27, r26
    20e8:	62 07       	cpc	r22, r18
    20ea:	73 07       	cpc	r23, r19
    20ec:	84 07       	cpc	r24, r20
    20ee:	95 07       	cpc	r25, r21
    20f0:	20 f0       	brcs	.+8      	; 0x20fa <__addsf3x+0x1c>
    20f2:	79 f4       	brne	.+30     	; 0x2112 <__addsf3x+0x34>
    20f4:	a6 f5       	brtc	.+104    	; 0x215e <__addsf3x+0x80>
    20f6:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_zero>
    20fa:	0e f4       	brtc	.+2      	; 0x20fe <__addsf3x+0x20>
    20fc:	e0 95       	com	r30
    20fe:	0b 2e       	mov	r0, r27
    2100:	ba 2f       	mov	r27, r26
    2102:	a0 2d       	mov	r26, r0
    2104:	0b 01       	movw	r0, r22
    2106:	b9 01       	movw	r22, r18
    2108:	90 01       	movw	r18, r0
    210a:	0c 01       	movw	r0, r24
    210c:	ca 01       	movw	r24, r20
    210e:	a0 01       	movw	r20, r0
    2110:	11 24       	eor	r1, r1
    2112:	ff 27       	eor	r31, r31
    2114:	59 1b       	sub	r21, r25
    2116:	99 f0       	breq	.+38     	; 0x213e <__addsf3x+0x60>
    2118:	59 3f       	cpi	r21, 0xF9	; 249
    211a:	50 f4       	brcc	.+20     	; 0x2130 <__addsf3x+0x52>
    211c:	50 3e       	cpi	r21, 0xE0	; 224
    211e:	68 f1       	brcs	.+90     	; 0x217a <__addsf3x+0x9c>
    2120:	1a 16       	cp	r1, r26
    2122:	f0 40       	sbci	r31, 0x00	; 0
    2124:	a2 2f       	mov	r26, r18
    2126:	23 2f       	mov	r18, r19
    2128:	34 2f       	mov	r19, r20
    212a:	44 27       	eor	r20, r20
    212c:	58 5f       	subi	r21, 0xF8	; 248
    212e:	f3 cf       	rjmp	.-26     	; 0x2116 <__addsf3x+0x38>
    2130:	46 95       	lsr	r20
    2132:	37 95       	ror	r19
    2134:	27 95       	ror	r18
    2136:	a7 95       	ror	r26
    2138:	f0 40       	sbci	r31, 0x00	; 0
    213a:	53 95       	inc	r21
    213c:	c9 f7       	brne	.-14     	; 0x2130 <__addsf3x+0x52>
    213e:	7e f4       	brtc	.+30     	; 0x215e <__addsf3x+0x80>
    2140:	1f 16       	cp	r1, r31
    2142:	ba 0b       	sbc	r27, r26
    2144:	62 0b       	sbc	r22, r18
    2146:	73 0b       	sbc	r23, r19
    2148:	84 0b       	sbc	r24, r20
    214a:	ba f0       	brmi	.+46     	; 0x217a <__addsf3x+0x9c>
    214c:	91 50       	subi	r25, 0x01	; 1
    214e:	a1 f0       	breq	.+40     	; 0x2178 <__addsf3x+0x9a>
    2150:	ff 0f       	add	r31, r31
    2152:	bb 1f       	adc	r27, r27
    2154:	66 1f       	adc	r22, r22
    2156:	77 1f       	adc	r23, r23
    2158:	88 1f       	adc	r24, r24
    215a:	c2 f7       	brpl	.-16     	; 0x214c <__addsf3x+0x6e>
    215c:	0e c0       	rjmp	.+28     	; 0x217a <__addsf3x+0x9c>
    215e:	ba 0f       	add	r27, r26
    2160:	62 1f       	adc	r22, r18
    2162:	73 1f       	adc	r23, r19
    2164:	84 1f       	adc	r24, r20
    2166:	48 f4       	brcc	.+18     	; 0x217a <__addsf3x+0x9c>
    2168:	87 95       	ror	r24
    216a:	77 95       	ror	r23
    216c:	67 95       	ror	r22
    216e:	b7 95       	ror	r27
    2170:	f7 95       	ror	r31
    2172:	9e 3f       	cpi	r25, 0xFE	; 254
    2174:	08 f0       	brcs	.+2      	; 0x2178 <__addsf3x+0x9a>
    2176:	b0 cf       	rjmp	.-160    	; 0x20d8 <__addsf3+0x28>
    2178:	93 95       	inc	r25
    217a:	88 0f       	add	r24, r24
    217c:	08 f0       	brcs	.+2      	; 0x2180 <__addsf3x+0xa2>
    217e:	99 27       	eor	r25, r25
    2180:	ee 0f       	add	r30, r30
    2182:	97 95       	ror	r25
    2184:	87 95       	ror	r24
    2186:	08 95       	ret

00002188 <__cmpsf2>:
    2188:	0e 94 a7 11 	call	0x234e	; 0x234e <__fp_cmp>
    218c:	08 f4       	brcc	.+2      	; 0x2190 <__cmpsf2+0x8>
    218e:	81 e0       	ldi	r24, 0x01	; 1
    2190:	08 95       	ret

00002192 <__divsf3>:
    2192:	0e 94 dd 10 	call	0x21ba	; 0x21ba <__divsf3x>
    2196:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__fp_round>
    219a:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__fp_pscB>
    219e:	58 f0       	brcs	.+22     	; 0x21b6 <__divsf3+0x24>
    21a0:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__fp_pscA>
    21a4:	40 f0       	brcs	.+16     	; 0x21b6 <__divsf3+0x24>
    21a6:	29 f4       	brne	.+10     	; 0x21b2 <__divsf3+0x20>
    21a8:	5f 3f       	cpi	r21, 0xFF	; 255
    21aa:	29 f0       	breq	.+10     	; 0x21b6 <__divsf3+0x24>
    21ac:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    21b0:	51 11       	cpse	r21, r1
    21b2:	0c 94 16 12 	jmp	0x242c	; 0x242c <__fp_szero>
    21b6:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>

000021ba <__divsf3x>:
    21ba:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__fp_split3>
    21be:	68 f3       	brcs	.-38     	; 0x219a <__divsf3+0x8>

000021c0 <__divsf3_pse>:
    21c0:	99 23       	and	r25, r25
    21c2:	b1 f3       	breq	.-20     	; 0x21b0 <__divsf3+0x1e>
    21c4:	55 23       	and	r21, r21
    21c6:	91 f3       	breq	.-28     	; 0x21ac <__divsf3+0x1a>
    21c8:	95 1b       	sub	r25, r21
    21ca:	55 0b       	sbc	r21, r21
    21cc:	bb 27       	eor	r27, r27
    21ce:	aa 27       	eor	r26, r26
    21d0:	62 17       	cp	r22, r18
    21d2:	73 07       	cpc	r23, r19
    21d4:	84 07       	cpc	r24, r20
    21d6:	38 f0       	brcs	.+14     	; 0x21e6 <__divsf3_pse+0x26>
    21d8:	9f 5f       	subi	r25, 0xFF	; 255
    21da:	5f 4f       	sbci	r21, 0xFF	; 255
    21dc:	22 0f       	add	r18, r18
    21de:	33 1f       	adc	r19, r19
    21e0:	44 1f       	adc	r20, r20
    21e2:	aa 1f       	adc	r26, r26
    21e4:	a9 f3       	breq	.-22     	; 0x21d0 <__divsf3_pse+0x10>
    21e6:	35 d0       	rcall	.+106    	; 0x2252 <__divsf3_pse+0x92>
    21e8:	0e 2e       	mov	r0, r30
    21ea:	3a f0       	brmi	.+14     	; 0x21fa <__divsf3_pse+0x3a>
    21ec:	e0 e8       	ldi	r30, 0x80	; 128
    21ee:	32 d0       	rcall	.+100    	; 0x2254 <__divsf3_pse+0x94>
    21f0:	91 50       	subi	r25, 0x01	; 1
    21f2:	50 40       	sbci	r21, 0x00	; 0
    21f4:	e6 95       	lsr	r30
    21f6:	00 1c       	adc	r0, r0
    21f8:	ca f7       	brpl	.-14     	; 0x21ec <__divsf3_pse+0x2c>
    21fa:	2b d0       	rcall	.+86     	; 0x2252 <__divsf3_pse+0x92>
    21fc:	fe 2f       	mov	r31, r30
    21fe:	29 d0       	rcall	.+82     	; 0x2252 <__divsf3_pse+0x92>
    2200:	66 0f       	add	r22, r22
    2202:	77 1f       	adc	r23, r23
    2204:	88 1f       	adc	r24, r24
    2206:	bb 1f       	adc	r27, r27
    2208:	26 17       	cp	r18, r22
    220a:	37 07       	cpc	r19, r23
    220c:	48 07       	cpc	r20, r24
    220e:	ab 07       	cpc	r26, r27
    2210:	b0 e8       	ldi	r27, 0x80	; 128
    2212:	09 f0       	breq	.+2      	; 0x2216 <__divsf3_pse+0x56>
    2214:	bb 0b       	sbc	r27, r27
    2216:	80 2d       	mov	r24, r0
    2218:	bf 01       	movw	r22, r30
    221a:	ff 27       	eor	r31, r31
    221c:	93 58       	subi	r25, 0x83	; 131
    221e:	5f 4f       	sbci	r21, 0xFF	; 255
    2220:	3a f0       	brmi	.+14     	; 0x2230 <__divsf3_pse+0x70>
    2222:	9e 3f       	cpi	r25, 0xFE	; 254
    2224:	51 05       	cpc	r21, r1
    2226:	78 f0       	brcs	.+30     	; 0x2246 <__divsf3_pse+0x86>
    2228:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    222c:	0c 94 16 12 	jmp	0x242c	; 0x242c <__fp_szero>
    2230:	5f 3f       	cpi	r21, 0xFF	; 255
    2232:	e4 f3       	brlt	.-8      	; 0x222c <__divsf3_pse+0x6c>
    2234:	98 3e       	cpi	r25, 0xE8	; 232
    2236:	d4 f3       	brlt	.-12     	; 0x222c <__divsf3_pse+0x6c>
    2238:	86 95       	lsr	r24
    223a:	77 95       	ror	r23
    223c:	67 95       	ror	r22
    223e:	b7 95       	ror	r27
    2240:	f7 95       	ror	r31
    2242:	9f 5f       	subi	r25, 0xFF	; 255
    2244:	c9 f7       	brne	.-14     	; 0x2238 <__divsf3_pse+0x78>
    2246:	88 0f       	add	r24, r24
    2248:	91 1d       	adc	r25, r1
    224a:	96 95       	lsr	r25
    224c:	87 95       	ror	r24
    224e:	97 f9       	bld	r25, 7
    2250:	08 95       	ret
    2252:	e1 e0       	ldi	r30, 0x01	; 1
    2254:	66 0f       	add	r22, r22
    2256:	77 1f       	adc	r23, r23
    2258:	88 1f       	adc	r24, r24
    225a:	bb 1f       	adc	r27, r27
    225c:	62 17       	cp	r22, r18
    225e:	73 07       	cpc	r23, r19
    2260:	84 07       	cpc	r24, r20
    2262:	ba 07       	cpc	r27, r26
    2264:	20 f0       	brcs	.+8      	; 0x226e <__divsf3_pse+0xae>
    2266:	62 1b       	sub	r22, r18
    2268:	73 0b       	sbc	r23, r19
    226a:	84 0b       	sbc	r24, r20
    226c:	ba 0b       	sbc	r27, r26
    226e:	ee 1f       	adc	r30, r30
    2270:	88 f7       	brcc	.-30     	; 0x2254 <__divsf3_pse+0x94>
    2272:	e0 95       	com	r30
    2274:	08 95       	ret

00002276 <__fixunssfsi>:
    2276:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__fp_splitA>
    227a:	88 f0       	brcs	.+34     	; 0x229e <__fixunssfsi+0x28>
    227c:	9f 57       	subi	r25, 0x7F	; 127
    227e:	98 f0       	brcs	.+38     	; 0x22a6 <__fixunssfsi+0x30>
    2280:	b9 2f       	mov	r27, r25
    2282:	99 27       	eor	r25, r25
    2284:	b7 51       	subi	r27, 0x17	; 23
    2286:	b0 f0       	brcs	.+44     	; 0x22b4 <__fixunssfsi+0x3e>
    2288:	e1 f0       	breq	.+56     	; 0x22c2 <__fixunssfsi+0x4c>
    228a:	66 0f       	add	r22, r22
    228c:	77 1f       	adc	r23, r23
    228e:	88 1f       	adc	r24, r24
    2290:	99 1f       	adc	r25, r25
    2292:	1a f0       	brmi	.+6      	; 0x229a <__fixunssfsi+0x24>
    2294:	ba 95       	dec	r27
    2296:	c9 f7       	brne	.-14     	; 0x228a <__fixunssfsi+0x14>
    2298:	14 c0       	rjmp	.+40     	; 0x22c2 <__fixunssfsi+0x4c>
    229a:	b1 30       	cpi	r27, 0x01	; 1
    229c:	91 f0       	breq	.+36     	; 0x22c2 <__fixunssfsi+0x4c>
    229e:	0e 94 15 12 	call	0x242a	; 0x242a <__fp_zero>
    22a2:	b1 e0       	ldi	r27, 0x01	; 1
    22a4:	08 95       	ret
    22a6:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_zero>
    22aa:	67 2f       	mov	r22, r23
    22ac:	78 2f       	mov	r23, r24
    22ae:	88 27       	eor	r24, r24
    22b0:	b8 5f       	subi	r27, 0xF8	; 248
    22b2:	39 f0       	breq	.+14     	; 0x22c2 <__fixunssfsi+0x4c>
    22b4:	b9 3f       	cpi	r27, 0xF9	; 249
    22b6:	cc f3       	brlt	.-14     	; 0x22aa <__fixunssfsi+0x34>
    22b8:	86 95       	lsr	r24
    22ba:	77 95       	ror	r23
    22bc:	67 95       	ror	r22
    22be:	b3 95       	inc	r27
    22c0:	d9 f7       	brne	.-10     	; 0x22b8 <__fixunssfsi+0x42>
    22c2:	3e f4       	brtc	.+14     	; 0x22d2 <__fixunssfsi+0x5c>
    22c4:	90 95       	com	r25
    22c6:	80 95       	com	r24
    22c8:	70 95       	com	r23
    22ca:	61 95       	neg	r22
    22cc:	7f 4f       	sbci	r23, 0xFF	; 255
    22ce:	8f 4f       	sbci	r24, 0xFF	; 255
    22d0:	9f 4f       	sbci	r25, 0xFF	; 255
    22d2:	08 95       	ret

000022d4 <__floatunsisf>:
    22d4:	e8 94       	clt
    22d6:	09 c0       	rjmp	.+18     	; 0x22ea <__floatsisf+0x12>

000022d8 <__floatsisf>:
    22d8:	97 fb       	bst	r25, 7
    22da:	3e f4       	brtc	.+14     	; 0x22ea <__floatsisf+0x12>
    22dc:	90 95       	com	r25
    22de:	80 95       	com	r24
    22e0:	70 95       	com	r23
    22e2:	61 95       	neg	r22
    22e4:	7f 4f       	sbci	r23, 0xFF	; 255
    22e6:	8f 4f       	sbci	r24, 0xFF	; 255
    22e8:	9f 4f       	sbci	r25, 0xFF	; 255
    22ea:	99 23       	and	r25, r25
    22ec:	a9 f0       	breq	.+42     	; 0x2318 <__floatsisf+0x40>
    22ee:	f9 2f       	mov	r31, r25
    22f0:	96 e9       	ldi	r25, 0x96	; 150
    22f2:	bb 27       	eor	r27, r27
    22f4:	93 95       	inc	r25
    22f6:	f6 95       	lsr	r31
    22f8:	87 95       	ror	r24
    22fa:	77 95       	ror	r23
    22fc:	67 95       	ror	r22
    22fe:	b7 95       	ror	r27
    2300:	f1 11       	cpse	r31, r1
    2302:	f8 cf       	rjmp	.-16     	; 0x22f4 <__floatsisf+0x1c>
    2304:	fa f4       	brpl	.+62     	; 0x2344 <__floatsisf+0x6c>
    2306:	bb 0f       	add	r27, r27
    2308:	11 f4       	brne	.+4      	; 0x230e <__floatsisf+0x36>
    230a:	60 ff       	sbrs	r22, 0
    230c:	1b c0       	rjmp	.+54     	; 0x2344 <__floatsisf+0x6c>
    230e:	6f 5f       	subi	r22, 0xFF	; 255
    2310:	7f 4f       	sbci	r23, 0xFF	; 255
    2312:	8f 4f       	sbci	r24, 0xFF	; 255
    2314:	9f 4f       	sbci	r25, 0xFF	; 255
    2316:	16 c0       	rjmp	.+44     	; 0x2344 <__floatsisf+0x6c>
    2318:	88 23       	and	r24, r24
    231a:	11 f0       	breq	.+4      	; 0x2320 <__floatsisf+0x48>
    231c:	96 e9       	ldi	r25, 0x96	; 150
    231e:	11 c0       	rjmp	.+34     	; 0x2342 <__floatsisf+0x6a>
    2320:	77 23       	and	r23, r23
    2322:	21 f0       	breq	.+8      	; 0x232c <__floatsisf+0x54>
    2324:	9e e8       	ldi	r25, 0x8E	; 142
    2326:	87 2f       	mov	r24, r23
    2328:	76 2f       	mov	r23, r22
    232a:	05 c0       	rjmp	.+10     	; 0x2336 <__floatsisf+0x5e>
    232c:	66 23       	and	r22, r22
    232e:	71 f0       	breq	.+28     	; 0x234c <__floatsisf+0x74>
    2330:	96 e8       	ldi	r25, 0x86	; 134
    2332:	86 2f       	mov	r24, r22
    2334:	70 e0       	ldi	r23, 0x00	; 0
    2336:	60 e0       	ldi	r22, 0x00	; 0
    2338:	2a f0       	brmi	.+10     	; 0x2344 <__floatsisf+0x6c>
    233a:	9a 95       	dec	r25
    233c:	66 0f       	add	r22, r22
    233e:	77 1f       	adc	r23, r23
    2340:	88 1f       	adc	r24, r24
    2342:	da f7       	brpl	.-10     	; 0x233a <__floatsisf+0x62>
    2344:	88 0f       	add	r24, r24
    2346:	96 95       	lsr	r25
    2348:	87 95       	ror	r24
    234a:	97 f9       	bld	r25, 7
    234c:	08 95       	ret

0000234e <__fp_cmp>:
    234e:	99 0f       	add	r25, r25
    2350:	00 08       	sbc	r0, r0
    2352:	55 0f       	add	r21, r21
    2354:	aa 0b       	sbc	r26, r26
    2356:	e0 e8       	ldi	r30, 0x80	; 128
    2358:	fe ef       	ldi	r31, 0xFE	; 254
    235a:	16 16       	cp	r1, r22
    235c:	17 06       	cpc	r1, r23
    235e:	e8 07       	cpc	r30, r24
    2360:	f9 07       	cpc	r31, r25
    2362:	c0 f0       	brcs	.+48     	; 0x2394 <__fp_cmp+0x46>
    2364:	12 16       	cp	r1, r18
    2366:	13 06       	cpc	r1, r19
    2368:	e4 07       	cpc	r30, r20
    236a:	f5 07       	cpc	r31, r21
    236c:	98 f0       	brcs	.+38     	; 0x2394 <__fp_cmp+0x46>
    236e:	62 1b       	sub	r22, r18
    2370:	73 0b       	sbc	r23, r19
    2372:	84 0b       	sbc	r24, r20
    2374:	95 0b       	sbc	r25, r21
    2376:	39 f4       	brne	.+14     	; 0x2386 <__fp_cmp+0x38>
    2378:	0a 26       	eor	r0, r26
    237a:	61 f0       	breq	.+24     	; 0x2394 <__fp_cmp+0x46>
    237c:	23 2b       	or	r18, r19
    237e:	24 2b       	or	r18, r20
    2380:	25 2b       	or	r18, r21
    2382:	21 f4       	brne	.+8      	; 0x238c <__fp_cmp+0x3e>
    2384:	08 95       	ret
    2386:	0a 26       	eor	r0, r26
    2388:	09 f4       	brne	.+2      	; 0x238c <__fp_cmp+0x3e>
    238a:	a1 40       	sbci	r26, 0x01	; 1
    238c:	a6 95       	lsr	r26
    238e:	8f ef       	ldi	r24, 0xFF	; 255
    2390:	81 1d       	adc	r24, r1
    2392:	81 1d       	adc	r24, r1
    2394:	08 95       	ret

00002396 <__fp_inf>:
    2396:	97 f9       	bld	r25, 7
    2398:	9f 67       	ori	r25, 0x7F	; 127
    239a:	80 e8       	ldi	r24, 0x80	; 128
    239c:	70 e0       	ldi	r23, 0x00	; 0
    239e:	60 e0       	ldi	r22, 0x00	; 0
    23a0:	08 95       	ret

000023a2 <__fp_nan>:
    23a2:	9f ef       	ldi	r25, 0xFF	; 255
    23a4:	80 ec       	ldi	r24, 0xC0	; 192
    23a6:	08 95       	ret

000023a8 <__fp_pscA>:
    23a8:	00 24       	eor	r0, r0
    23aa:	0a 94       	dec	r0
    23ac:	16 16       	cp	r1, r22
    23ae:	17 06       	cpc	r1, r23
    23b0:	18 06       	cpc	r1, r24
    23b2:	09 06       	cpc	r0, r25
    23b4:	08 95       	ret

000023b6 <__fp_pscB>:
    23b6:	00 24       	eor	r0, r0
    23b8:	0a 94       	dec	r0
    23ba:	12 16       	cp	r1, r18
    23bc:	13 06       	cpc	r1, r19
    23be:	14 06       	cpc	r1, r20
    23c0:	05 06       	cpc	r0, r21
    23c2:	08 95       	ret

000023c4 <__fp_round>:
    23c4:	09 2e       	mov	r0, r25
    23c6:	03 94       	inc	r0
    23c8:	00 0c       	add	r0, r0
    23ca:	11 f4       	brne	.+4      	; 0x23d0 <__fp_round+0xc>
    23cc:	88 23       	and	r24, r24
    23ce:	52 f0       	brmi	.+20     	; 0x23e4 <__fp_round+0x20>
    23d0:	bb 0f       	add	r27, r27
    23d2:	40 f4       	brcc	.+16     	; 0x23e4 <__fp_round+0x20>
    23d4:	bf 2b       	or	r27, r31
    23d6:	11 f4       	brne	.+4      	; 0x23dc <__fp_round+0x18>
    23d8:	60 ff       	sbrs	r22, 0
    23da:	04 c0       	rjmp	.+8      	; 0x23e4 <__fp_round+0x20>
    23dc:	6f 5f       	subi	r22, 0xFF	; 255
    23de:	7f 4f       	sbci	r23, 0xFF	; 255
    23e0:	8f 4f       	sbci	r24, 0xFF	; 255
    23e2:	9f 4f       	sbci	r25, 0xFF	; 255
    23e4:	08 95       	ret

000023e6 <__fp_split3>:
    23e6:	57 fd       	sbrc	r21, 7
    23e8:	90 58       	subi	r25, 0x80	; 128
    23ea:	44 0f       	add	r20, r20
    23ec:	55 1f       	adc	r21, r21
    23ee:	59 f0       	breq	.+22     	; 0x2406 <__fp_splitA+0x10>
    23f0:	5f 3f       	cpi	r21, 0xFF	; 255
    23f2:	71 f0       	breq	.+28     	; 0x2410 <__fp_splitA+0x1a>
    23f4:	47 95       	ror	r20

000023f6 <__fp_splitA>:
    23f6:	88 0f       	add	r24, r24
    23f8:	97 fb       	bst	r25, 7
    23fa:	99 1f       	adc	r25, r25
    23fc:	61 f0       	breq	.+24     	; 0x2416 <__fp_splitA+0x20>
    23fe:	9f 3f       	cpi	r25, 0xFF	; 255
    2400:	79 f0       	breq	.+30     	; 0x2420 <__fp_splitA+0x2a>
    2402:	87 95       	ror	r24
    2404:	08 95       	ret
    2406:	12 16       	cp	r1, r18
    2408:	13 06       	cpc	r1, r19
    240a:	14 06       	cpc	r1, r20
    240c:	55 1f       	adc	r21, r21
    240e:	f2 cf       	rjmp	.-28     	; 0x23f4 <__fp_split3+0xe>
    2410:	46 95       	lsr	r20
    2412:	f1 df       	rcall	.-30     	; 0x23f6 <__fp_splitA>
    2414:	08 c0       	rjmp	.+16     	; 0x2426 <__fp_splitA+0x30>
    2416:	16 16       	cp	r1, r22
    2418:	17 06       	cpc	r1, r23
    241a:	18 06       	cpc	r1, r24
    241c:	99 1f       	adc	r25, r25
    241e:	f1 cf       	rjmp	.-30     	; 0x2402 <__fp_splitA+0xc>
    2420:	86 95       	lsr	r24
    2422:	71 05       	cpc	r23, r1
    2424:	61 05       	cpc	r22, r1
    2426:	08 94       	sec
    2428:	08 95       	ret

0000242a <__fp_zero>:
    242a:	e8 94       	clt

0000242c <__fp_szero>:
    242c:	bb 27       	eor	r27, r27
    242e:	66 27       	eor	r22, r22
    2430:	77 27       	eor	r23, r23
    2432:	cb 01       	movw	r24, r22
    2434:	97 f9       	bld	r25, 7
    2436:	08 95       	ret

00002438 <__gesf2>:
    2438:	0e 94 a7 11 	call	0x234e	; 0x234e <__fp_cmp>
    243c:	08 f4       	brcc	.+2      	; 0x2440 <__gesf2+0x8>
    243e:	8f ef       	ldi	r24, 0xFF	; 255
    2440:	08 95       	ret

00002442 <__mulsf3>:
    2442:	0e 94 34 12 	call	0x2468	; 0x2468 <__mulsf3x>
    2446:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__fp_round>
    244a:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <__fp_pscA>
    244e:	38 f0       	brcs	.+14     	; 0x245e <__mulsf3+0x1c>
    2450:	0e 94 db 11 	call	0x23b6	; 0x23b6 <__fp_pscB>
    2454:	20 f0       	brcs	.+8      	; 0x245e <__mulsf3+0x1c>
    2456:	95 23       	and	r25, r21
    2458:	11 f0       	breq	.+4      	; 0x245e <__mulsf3+0x1c>
    245a:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    245e:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>
    2462:	11 24       	eor	r1, r1
    2464:	0c 94 16 12 	jmp	0x242c	; 0x242c <__fp_szero>

00002468 <__mulsf3x>:
    2468:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <__fp_split3>
    246c:	70 f3       	brcs	.-36     	; 0x244a <__mulsf3+0x8>

0000246e <__mulsf3_pse>:
    246e:	95 9f       	mul	r25, r21
    2470:	c1 f3       	breq	.-16     	; 0x2462 <__mulsf3+0x20>
    2472:	95 0f       	add	r25, r21
    2474:	50 e0       	ldi	r21, 0x00	; 0
    2476:	55 1f       	adc	r21, r21
    2478:	62 9f       	mul	r22, r18
    247a:	f0 01       	movw	r30, r0
    247c:	72 9f       	mul	r23, r18
    247e:	bb 27       	eor	r27, r27
    2480:	f0 0d       	add	r31, r0
    2482:	b1 1d       	adc	r27, r1
    2484:	63 9f       	mul	r22, r19
    2486:	aa 27       	eor	r26, r26
    2488:	f0 0d       	add	r31, r0
    248a:	b1 1d       	adc	r27, r1
    248c:	aa 1f       	adc	r26, r26
    248e:	64 9f       	mul	r22, r20
    2490:	66 27       	eor	r22, r22
    2492:	b0 0d       	add	r27, r0
    2494:	a1 1d       	adc	r26, r1
    2496:	66 1f       	adc	r22, r22
    2498:	82 9f       	mul	r24, r18
    249a:	22 27       	eor	r18, r18
    249c:	b0 0d       	add	r27, r0
    249e:	a1 1d       	adc	r26, r1
    24a0:	62 1f       	adc	r22, r18
    24a2:	73 9f       	mul	r23, r19
    24a4:	b0 0d       	add	r27, r0
    24a6:	a1 1d       	adc	r26, r1
    24a8:	62 1f       	adc	r22, r18
    24aa:	83 9f       	mul	r24, r19
    24ac:	a0 0d       	add	r26, r0
    24ae:	61 1d       	adc	r22, r1
    24b0:	22 1f       	adc	r18, r18
    24b2:	74 9f       	mul	r23, r20
    24b4:	33 27       	eor	r19, r19
    24b6:	a0 0d       	add	r26, r0
    24b8:	61 1d       	adc	r22, r1
    24ba:	23 1f       	adc	r18, r19
    24bc:	84 9f       	mul	r24, r20
    24be:	60 0d       	add	r22, r0
    24c0:	21 1d       	adc	r18, r1
    24c2:	82 2f       	mov	r24, r18
    24c4:	76 2f       	mov	r23, r22
    24c6:	6a 2f       	mov	r22, r26
    24c8:	11 24       	eor	r1, r1
    24ca:	9f 57       	subi	r25, 0x7F	; 127
    24cc:	50 40       	sbci	r21, 0x00	; 0
    24ce:	9a f0       	brmi	.+38     	; 0x24f6 <__mulsf3_pse+0x88>
    24d0:	f1 f0       	breq	.+60     	; 0x250e <__mulsf3_pse+0xa0>
    24d2:	88 23       	and	r24, r24
    24d4:	4a f0       	brmi	.+18     	; 0x24e8 <__mulsf3_pse+0x7a>
    24d6:	ee 0f       	add	r30, r30
    24d8:	ff 1f       	adc	r31, r31
    24da:	bb 1f       	adc	r27, r27
    24dc:	66 1f       	adc	r22, r22
    24de:	77 1f       	adc	r23, r23
    24e0:	88 1f       	adc	r24, r24
    24e2:	91 50       	subi	r25, 0x01	; 1
    24e4:	50 40       	sbci	r21, 0x00	; 0
    24e6:	a9 f7       	brne	.-22     	; 0x24d2 <__mulsf3_pse+0x64>
    24e8:	9e 3f       	cpi	r25, 0xFE	; 254
    24ea:	51 05       	cpc	r21, r1
    24ec:	80 f0       	brcs	.+32     	; 0x250e <__mulsf3_pse+0xa0>
    24ee:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    24f2:	0c 94 16 12 	jmp	0x242c	; 0x242c <__fp_szero>
    24f6:	5f 3f       	cpi	r21, 0xFF	; 255
    24f8:	e4 f3       	brlt	.-8      	; 0x24f2 <__mulsf3_pse+0x84>
    24fa:	98 3e       	cpi	r25, 0xE8	; 232
    24fc:	d4 f3       	brlt	.-12     	; 0x24f2 <__mulsf3_pse+0x84>
    24fe:	86 95       	lsr	r24
    2500:	77 95       	ror	r23
    2502:	67 95       	ror	r22
    2504:	b7 95       	ror	r27
    2506:	f7 95       	ror	r31
    2508:	e7 95       	ror	r30
    250a:	9f 5f       	subi	r25, 0xFF	; 255
    250c:	c1 f7       	brne	.-16     	; 0x24fe <__mulsf3_pse+0x90>
    250e:	fe 2b       	or	r31, r30
    2510:	88 0f       	add	r24, r24
    2512:	91 1d       	adc	r25, r1
    2514:	96 95       	lsr	r25
    2516:	87 95       	ror	r24
    2518:	97 f9       	bld	r25, 7
    251a:	08 95       	ret

0000251c <pow>:
    251c:	fa 01       	movw	r30, r20
    251e:	ee 0f       	add	r30, r30
    2520:	ff 1f       	adc	r31, r31
    2522:	30 96       	adiw	r30, 0x00	; 0
    2524:	21 05       	cpc	r18, r1
    2526:	31 05       	cpc	r19, r1
    2528:	a1 f1       	breq	.+104    	; 0x2592 <pow+0x76>
    252a:	61 15       	cp	r22, r1
    252c:	71 05       	cpc	r23, r1
    252e:	61 f4       	brne	.+24     	; 0x2548 <pow+0x2c>
    2530:	80 38       	cpi	r24, 0x80	; 128
    2532:	bf e3       	ldi	r27, 0x3F	; 63
    2534:	9b 07       	cpc	r25, r27
    2536:	49 f1       	breq	.+82     	; 0x258a <pow+0x6e>
    2538:	68 94       	set
    253a:	90 38       	cpi	r25, 0x80	; 128
    253c:	81 05       	cpc	r24, r1
    253e:	61 f0       	breq	.+24     	; 0x2558 <pow+0x3c>
    2540:	80 38       	cpi	r24, 0x80	; 128
    2542:	bf ef       	ldi	r27, 0xFF	; 255
    2544:	9b 07       	cpc	r25, r27
    2546:	41 f0       	breq	.+16     	; 0x2558 <pow+0x3c>
    2548:	99 23       	and	r25, r25
    254a:	4a f5       	brpl	.+82     	; 0x259e <pow+0x82>
    254c:	ff 3f       	cpi	r31, 0xFF	; 255
    254e:	e1 05       	cpc	r30, r1
    2550:	31 05       	cpc	r19, r1
    2552:	21 05       	cpc	r18, r1
    2554:	19 f1       	breq	.+70     	; 0x259c <pow+0x80>
    2556:	e8 94       	clt
    2558:	08 94       	sec
    255a:	e7 95       	ror	r30
    255c:	d9 01       	movw	r26, r18
    255e:	aa 23       	and	r26, r26
    2560:	29 f4       	brne	.+10     	; 0x256c <pow+0x50>
    2562:	ab 2f       	mov	r26, r27
    2564:	be 2f       	mov	r27, r30
    2566:	f8 5f       	subi	r31, 0xF8	; 248
    2568:	d0 f3       	brcs	.-12     	; 0x255e <pow+0x42>
    256a:	10 c0       	rjmp	.+32     	; 0x258c <pow+0x70>
    256c:	ff 5f       	subi	r31, 0xFF	; 255
    256e:	70 f4       	brcc	.+28     	; 0x258c <pow+0x70>
    2570:	a6 95       	lsr	r26
    2572:	e0 f7       	brcc	.-8      	; 0x256c <pow+0x50>
    2574:	f7 39       	cpi	r31, 0x97	; 151
    2576:	50 f0       	brcs	.+20     	; 0x258c <pow+0x70>
    2578:	19 f0       	breq	.+6      	; 0x2580 <pow+0x64>
    257a:	ff 3a       	cpi	r31, 0xAF	; 175
    257c:	38 f4       	brcc	.+14     	; 0x258c <pow+0x70>
    257e:	9f 77       	andi	r25, 0x7F	; 127
    2580:	9f 93       	push	r25
    2582:	0d d0       	rcall	.+26     	; 0x259e <pow+0x82>
    2584:	0f 90       	pop	r0
    2586:	07 fc       	sbrc	r0, 7
    2588:	90 58       	subi	r25, 0x80	; 128
    258a:	08 95       	ret
    258c:	46 f0       	brts	.+16     	; 0x259e <pow+0x82>
    258e:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>
    2592:	60 e0       	ldi	r22, 0x00	; 0
    2594:	70 e0       	ldi	r23, 0x00	; 0
    2596:	80 e8       	ldi	r24, 0x80	; 128
    2598:	9f e3       	ldi	r25, 0x3F	; 63
    259a:	08 95       	ret
    259c:	4f e7       	ldi	r20, 0x7F	; 127
    259e:	9f 77       	andi	r25, 0x7F	; 127
    25a0:	5f 93       	push	r21
    25a2:	4f 93       	push	r20
    25a4:	3f 93       	push	r19
    25a6:	2f 93       	push	r18
    25a8:	0e 94 89 13 	call	0x2712	; 0x2712 <log>
    25ac:	2f 91       	pop	r18
    25ae:	3f 91       	pop	r19
    25b0:	4f 91       	pop	r20
    25b2:	5f 91       	pop	r21
    25b4:	0e 94 21 12 	call	0x2442	; 0x2442 <__mulsf3>
    25b8:	0c 94 e6 12 	jmp	0x25cc	; 0x25cc <exp>
    25bc:	29 f4       	brne	.+10     	; 0x25c8 <pow+0xac>
    25be:	16 f0       	brts	.+4      	; 0x25c4 <pow+0xa8>
    25c0:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    25c4:	0c 94 15 12 	jmp	0x242a	; 0x242a <__fp_zero>
    25c8:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>

000025cc <exp>:
    25cc:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__fp_splitA>
    25d0:	a8 f3       	brcs	.-22     	; 0x25bc <pow+0xa0>
    25d2:	96 38       	cpi	r25, 0x86	; 134
    25d4:	a0 f7       	brcc	.-24     	; 0x25be <pow+0xa2>
    25d6:	07 f8       	bld	r0, 7
    25d8:	0f 92       	push	r0
    25da:	e8 94       	clt
    25dc:	2b e3       	ldi	r18, 0x3B	; 59
    25de:	3a ea       	ldi	r19, 0xAA	; 170
    25e0:	48 eb       	ldi	r20, 0xB8	; 184
    25e2:	5f e7       	ldi	r21, 0x7F	; 127
    25e4:	0e 94 37 12 	call	0x246e	; 0x246e <__mulsf3_pse>
    25e8:	0f 92       	push	r0
    25ea:	0f 92       	push	r0
    25ec:	0f 92       	push	r0
    25ee:	4d b7       	in	r20, 0x3d	; 61
    25f0:	5e b7       	in	r21, 0x3e	; 62
    25f2:	0f 92       	push	r0
    25f4:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <modf>
    25f8:	e4 e5       	ldi	r30, 0x54	; 84
    25fa:	f0 e0       	ldi	r31, 0x00	; 0
    25fc:	0e 94 18 13 	call	0x2630	; 0x2630 <__fp_powser>
    2600:	4f 91       	pop	r20
    2602:	5f 91       	pop	r21
    2604:	ef 91       	pop	r30
    2606:	ff 91       	pop	r31
    2608:	e5 95       	asr	r30
    260a:	ee 1f       	adc	r30, r30
    260c:	ff 1f       	adc	r31, r31
    260e:	49 f0       	breq	.+18     	; 0x2622 <exp+0x56>
    2610:	fe 57       	subi	r31, 0x7E	; 126
    2612:	e0 68       	ori	r30, 0x80	; 128
    2614:	44 27       	eor	r20, r20
    2616:	ee 0f       	add	r30, r30
    2618:	44 1f       	adc	r20, r20
    261a:	fa 95       	dec	r31
    261c:	e1 f7       	brne	.-8      	; 0x2616 <exp+0x4a>
    261e:	41 95       	neg	r20
    2620:	55 0b       	sbc	r21, r21
    2622:	0e 94 4b 13 	call	0x2696	; 0x2696 <ldexp>
    2626:	0f 90       	pop	r0
    2628:	07 fe       	sbrs	r0, 7
    262a:	0c 94 3f 13 	jmp	0x267e	; 0x267e <inverse>
    262e:	08 95       	ret

00002630 <__fp_powser>:
    2630:	df 93       	push	r29
    2632:	cf 93       	push	r28
    2634:	1f 93       	push	r17
    2636:	0f 93       	push	r16
    2638:	ff 92       	push	r15
    263a:	ef 92       	push	r14
    263c:	df 92       	push	r13
    263e:	7b 01       	movw	r14, r22
    2640:	8c 01       	movw	r16, r24
    2642:	68 94       	set
    2644:	06 c0       	rjmp	.+12     	; 0x2652 <__fp_powser+0x22>
    2646:	da 2e       	mov	r13, r26
    2648:	ef 01       	movw	r28, r30
    264a:	0e 94 34 12 	call	0x2468	; 0x2468 <__mulsf3x>
    264e:	fe 01       	movw	r30, r28
    2650:	e8 94       	clt
    2652:	a5 91       	lpm	r26, Z+
    2654:	25 91       	lpm	r18, Z+
    2656:	35 91       	lpm	r19, Z+
    2658:	45 91       	lpm	r20, Z+
    265a:	55 91       	lpm	r21, Z+
    265c:	a6 f3       	brts	.-24     	; 0x2646 <__fp_powser+0x16>
    265e:	ef 01       	movw	r28, r30
    2660:	0e 94 6f 10 	call	0x20de	; 0x20de <__addsf3x>
    2664:	fe 01       	movw	r30, r28
    2666:	97 01       	movw	r18, r14
    2668:	a8 01       	movw	r20, r16
    266a:	da 94       	dec	r13
    266c:	69 f7       	brne	.-38     	; 0x2648 <__fp_powser+0x18>
    266e:	df 90       	pop	r13
    2670:	ef 90       	pop	r14
    2672:	ff 90       	pop	r15
    2674:	0f 91       	pop	r16
    2676:	1f 91       	pop	r17
    2678:	cf 91       	pop	r28
    267a:	df 91       	pop	r29
    267c:	08 95       	ret

0000267e <inverse>:
    267e:	9b 01       	movw	r18, r22
    2680:	ac 01       	movw	r20, r24
    2682:	60 e0       	ldi	r22, 0x00	; 0
    2684:	70 e0       	ldi	r23, 0x00	; 0
    2686:	80 e8       	ldi	r24, 0x80	; 128
    2688:	9f e3       	ldi	r25, 0x3F	; 63
    268a:	0c 94 c9 10 	jmp	0x2192	; 0x2192 <__divsf3>
    268e:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>
    2692:	0c 94 05 14 	jmp	0x280a	; 0x280a <__fp_mpack>

00002696 <ldexp>:
    2696:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__fp_splitA>
    269a:	d8 f3       	brcs	.-10     	; 0x2692 <inverse+0x14>
    269c:	99 23       	and	r25, r25
    269e:	c9 f3       	breq	.-14     	; 0x2692 <inverse+0x14>
    26a0:	94 0f       	add	r25, r20
    26a2:	51 1d       	adc	r21, r1
    26a4:	a3 f3       	brvs	.-24     	; 0x268e <inverse+0x10>
    26a6:	91 50       	subi	r25, 0x01	; 1
    26a8:	50 40       	sbci	r21, 0x00	; 0
    26aa:	94 f0       	brlt	.+36     	; 0x26d0 <ldexp+0x3a>
    26ac:	59 f0       	breq	.+22     	; 0x26c4 <ldexp+0x2e>
    26ae:	88 23       	and	r24, r24
    26b0:	32 f0       	brmi	.+12     	; 0x26be <ldexp+0x28>
    26b2:	66 0f       	add	r22, r22
    26b4:	77 1f       	adc	r23, r23
    26b6:	88 1f       	adc	r24, r24
    26b8:	91 50       	subi	r25, 0x01	; 1
    26ba:	50 40       	sbci	r21, 0x00	; 0
    26bc:	c1 f7       	brne	.-16     	; 0x26ae <ldexp+0x18>
    26be:	9e 3f       	cpi	r25, 0xFE	; 254
    26c0:	51 05       	cpc	r21, r1
    26c2:	2c f7       	brge	.-54     	; 0x268e <inverse+0x10>
    26c4:	88 0f       	add	r24, r24
    26c6:	91 1d       	adc	r25, r1
    26c8:	96 95       	lsr	r25
    26ca:	87 95       	ror	r24
    26cc:	97 f9       	bld	r25, 7
    26ce:	08 95       	ret
    26d0:	5f 3f       	cpi	r21, 0xFF	; 255
    26d2:	ac f0       	brlt	.+42     	; 0x26fe <ldexp+0x68>
    26d4:	98 3e       	cpi	r25, 0xE8	; 232
    26d6:	9c f0       	brlt	.+38     	; 0x26fe <ldexp+0x68>
    26d8:	bb 27       	eor	r27, r27
    26da:	86 95       	lsr	r24
    26dc:	77 95       	ror	r23
    26de:	67 95       	ror	r22
    26e0:	b7 95       	ror	r27
    26e2:	08 f4       	brcc	.+2      	; 0x26e6 <ldexp+0x50>
    26e4:	b1 60       	ori	r27, 0x01	; 1
    26e6:	93 95       	inc	r25
    26e8:	c1 f7       	brne	.-16     	; 0x26da <ldexp+0x44>
    26ea:	bb 0f       	add	r27, r27
    26ec:	58 f7       	brcc	.-42     	; 0x26c4 <ldexp+0x2e>
    26ee:	11 f4       	brne	.+4      	; 0x26f4 <ldexp+0x5e>
    26f0:	60 ff       	sbrs	r22, 0
    26f2:	e8 cf       	rjmp	.-48     	; 0x26c4 <ldexp+0x2e>
    26f4:	6f 5f       	subi	r22, 0xFF	; 255
    26f6:	7f 4f       	sbci	r23, 0xFF	; 255
    26f8:	8f 4f       	sbci	r24, 0xFF	; 255
    26fa:	9f 4f       	sbci	r25, 0xFF	; 255
    26fc:	e3 cf       	rjmp	.-58     	; 0x26c4 <ldexp+0x2e>
    26fe:	0c 94 16 12 	jmp	0x242c	; 0x242c <__fp_szero>
    2702:	16 f0       	brts	.+4      	; 0x2708 <ldexp+0x72>
    2704:	0c 94 05 14 	jmp	0x280a	; 0x280a <__fp_mpack>
    2708:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <__fp_nan>
    270c:	68 94       	set
    270e:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <__fp_inf>

00002712 <log>:
    2712:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__fp_splitA>
    2716:	a8 f3       	brcs	.-22     	; 0x2702 <ldexp+0x6c>
    2718:	99 23       	and	r25, r25
    271a:	c1 f3       	breq	.-16     	; 0x270c <ldexp+0x76>
    271c:	ae f3       	brts	.-22     	; 0x2708 <ldexp+0x72>
    271e:	df 93       	push	r29
    2720:	cf 93       	push	r28
    2722:	1f 93       	push	r17
    2724:	0f 93       	push	r16
    2726:	ff 92       	push	r15
    2728:	c9 2f       	mov	r28, r25
    272a:	dd 27       	eor	r29, r29
    272c:	88 23       	and	r24, r24
    272e:	2a f0       	brmi	.+10     	; 0x273a <log+0x28>
    2730:	21 97       	sbiw	r28, 0x01	; 1
    2732:	66 0f       	add	r22, r22
    2734:	77 1f       	adc	r23, r23
    2736:	88 1f       	adc	r24, r24
    2738:	da f7       	brpl	.-10     	; 0x2730 <log+0x1e>
    273a:	20 e0       	ldi	r18, 0x00	; 0
    273c:	30 e0       	ldi	r19, 0x00	; 0
    273e:	40 e8       	ldi	r20, 0x80	; 128
    2740:	5f eb       	ldi	r21, 0xBF	; 191
    2742:	9f e3       	ldi	r25, 0x3F	; 63
    2744:	88 39       	cpi	r24, 0x98	; 152
    2746:	20 f0       	brcs	.+8      	; 0x2750 <log+0x3e>
    2748:	80 3e       	cpi	r24, 0xE0	; 224
    274a:	38 f0       	brcs	.+14     	; 0x275a <log+0x48>
    274c:	21 96       	adiw	r28, 0x01	; 1
    274e:	8f 77       	andi	r24, 0x7F	; 127
    2750:	0e 94 58 10 	call	0x20b0	; 0x20b0 <__addsf3>
    2754:	ec e7       	ldi	r30, 0x7C	; 124
    2756:	f0 e0       	ldi	r31, 0x00	; 0
    2758:	04 c0       	rjmp	.+8      	; 0x2762 <log+0x50>
    275a:	0e 94 58 10 	call	0x20b0	; 0x20b0 <__addsf3>
    275e:	e9 ea       	ldi	r30, 0xA9	; 169
    2760:	f0 e0       	ldi	r31, 0x00	; 0
    2762:	0e 94 18 13 	call	0x2630	; 0x2630 <__fp_powser>
    2766:	8b 01       	movw	r16, r22
    2768:	be 01       	movw	r22, r28
    276a:	ec 01       	movw	r28, r24
    276c:	fb 2e       	mov	r15, r27
    276e:	6f 57       	subi	r22, 0x7F	; 127
    2770:	71 09       	sbc	r23, r1
    2772:	75 95       	asr	r23
    2774:	77 1f       	adc	r23, r23
    2776:	88 0b       	sbc	r24, r24
    2778:	99 0b       	sbc	r25, r25
    277a:	0e 94 6c 11 	call	0x22d8	; 0x22d8 <__floatsisf>
    277e:	28 e1       	ldi	r18, 0x18	; 24
    2780:	32 e7       	ldi	r19, 0x72	; 114
    2782:	41 e3       	ldi	r20, 0x31	; 49
    2784:	5f e3       	ldi	r21, 0x3F	; 63
    2786:	0e 94 34 12 	call	0x2468	; 0x2468 <__mulsf3x>
    278a:	af 2d       	mov	r26, r15
    278c:	98 01       	movw	r18, r16
    278e:	ae 01       	movw	r20, r28
    2790:	ff 90       	pop	r15
    2792:	0f 91       	pop	r16
    2794:	1f 91       	pop	r17
    2796:	cf 91       	pop	r28
    2798:	df 91       	pop	r29
    279a:	0e 94 6f 10 	call	0x20de	; 0x20de <__addsf3x>
    279e:	0c 94 e2 11 	jmp	0x23c4	; 0x23c4 <__fp_round>

000027a2 <modf>:
    27a2:	fa 01       	movw	r30, r20
    27a4:	dc 01       	movw	r26, r24
    27a6:	aa 0f       	add	r26, r26
    27a8:	bb 1f       	adc	r27, r27
    27aa:	9b 01       	movw	r18, r22
    27ac:	ac 01       	movw	r20, r24
    27ae:	bf 57       	subi	r27, 0x7F	; 127
    27b0:	28 f4       	brcc	.+10     	; 0x27bc <modf+0x1a>
    27b2:	22 27       	eor	r18, r18
    27b4:	33 27       	eor	r19, r19
    27b6:	44 27       	eor	r20, r20
    27b8:	50 78       	andi	r21, 0x80	; 128
    27ba:	20 c0       	rjmp	.+64     	; 0x27fc <modf+0x5a>
    27bc:	b7 51       	subi	r27, 0x17	; 23
    27be:	90 f4       	brcc	.+36     	; 0x27e4 <modf+0x42>
    27c0:	ab 2f       	mov	r26, r27
    27c2:	00 24       	eor	r0, r0
    27c4:	46 95       	lsr	r20
    27c6:	37 95       	ror	r19
    27c8:	27 95       	ror	r18
    27ca:	01 1c       	adc	r0, r1
    27cc:	a3 95       	inc	r26
    27ce:	d2 f3       	brmi	.-12     	; 0x27c4 <modf+0x22>
    27d0:	00 20       	and	r0, r0
    27d2:	71 f0       	breq	.+28     	; 0x27f0 <modf+0x4e>
    27d4:	22 0f       	add	r18, r18
    27d6:	33 1f       	adc	r19, r19
    27d8:	44 1f       	adc	r20, r20
    27da:	b3 95       	inc	r27
    27dc:	da f3       	brmi	.-10     	; 0x27d4 <modf+0x32>
    27de:	0e d0       	rcall	.+28     	; 0x27fc <modf+0x5a>
    27e0:	0c 94 57 10 	jmp	0x20ae	; 0x20ae <__subsf3>
    27e4:	61 30       	cpi	r22, 0x01	; 1
    27e6:	71 05       	cpc	r23, r1
    27e8:	a0 e8       	ldi	r26, 0x80	; 128
    27ea:	8a 07       	cpc	r24, r26
    27ec:	b9 46       	sbci	r27, 0x69	; 105
    27ee:	30 f4       	brcc	.+12     	; 0x27fc <modf+0x5a>
    27f0:	9b 01       	movw	r18, r22
    27f2:	ac 01       	movw	r20, r24
    27f4:	66 27       	eor	r22, r22
    27f6:	77 27       	eor	r23, r23
    27f8:	88 27       	eor	r24, r24
    27fa:	90 78       	andi	r25, 0x80	; 128
    27fc:	30 96       	adiw	r30, 0x00	; 0
    27fe:	21 f0       	breq	.+8      	; 0x2808 <modf+0x66>
    2800:	20 83       	st	Z, r18
    2802:	31 83       	std	Z+1, r19	; 0x01
    2804:	42 83       	std	Z+2, r20	; 0x02
    2806:	53 83       	std	Z+3, r21	; 0x03
    2808:	08 95       	ret

0000280a <__fp_mpack>:
    280a:	9f 3f       	cpi	r25, 0xFF	; 255
    280c:	31 f0       	breq	.+12     	; 0x281a <__fp_mpack_finite+0xc>

0000280e <__fp_mpack_finite>:
    280e:	91 50       	subi	r25, 0x01	; 1
    2810:	20 f4       	brcc	.+8      	; 0x281a <__fp_mpack_finite+0xc>
    2812:	87 95       	ror	r24
    2814:	77 95       	ror	r23
    2816:	67 95       	ror	r22
    2818:	b7 95       	ror	r27
    281a:	88 0f       	add	r24, r24
    281c:	91 1d       	adc	r25, r1
    281e:	96 95       	lsr	r25
    2820:	87 95       	ror	r24
    2822:	97 f9       	bld	r25, 7
    2824:	08 95       	ret

00002826 <strcmp>:
    2826:	fb 01       	movw	r30, r22
    2828:	dc 01       	movw	r26, r24
    282a:	8d 91       	ld	r24, X+
    282c:	01 90       	ld	r0, Z+
    282e:	80 19       	sub	r24, r0
    2830:	01 10       	cpse	r0, r1
    2832:	d9 f3       	breq	.-10     	; 0x282a <strcmp+0x4>
    2834:	99 0b       	sbc	r25, r25
    2836:	08 95       	ret

00002838 <_exit>:
    2838:	f8 94       	cli

0000283a <__stop_program>:
    283a:	ff cf       	rjmp	.-2      	; 0x283a <__stop_program>
