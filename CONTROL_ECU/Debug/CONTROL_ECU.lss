
CONTROL_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002942  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000076  00800060  00002942  000029d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008e  008000d6  008000d6  00002a4c  2**0
                  ALLOC
  3 .stab         000032d0  00000000  00000000  00002a4c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001599  00000000  00000000  00005d1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000072b5  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000072c8  2**2
                  CONTENTS, READONLY
  7 .debug_info   0000052e  00000000  00000000  00007304  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004e7  00000000  00000000  00007832  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00007d19  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001af  00000000  00000000  00007d33  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 16 09 	jmp	0x122c	; 0x122c <__vector_3>
      10:	0c 94 4d 09 	jmp	0x129a	; 0x129a <__vector_4>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 df 08 	jmp	0x11be	; 0x11be <__vector_6>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 a8 08 	jmp	0x1150	; 0x1150 <__vector_8>
      24:	0c 94 71 08 	jmp	0x10e2	; 0x10e2 <__vector_9>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <__vector_19>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	std	Y+40, r29	; 0x28
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	std	Y+56, r1	; 0x38
      62:	ba ab       	std	Y+50, r27	; 0x32
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	std	Y+54, r27	; 0x36
      96:	aa aa       	std	Y+50, r10	; 0x32
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	ldd	r30, Z+49	; 0x31
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__stack+0x471>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d4 e0       	ldi	r29, 0x04	; 4
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	e2 e4       	ldi	r30, 0x42	; 66
      ea:	f9 e2       	ldi	r31, 0x29	; 41
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	a6 3d       	cpi	r26, 0xD6	; 214
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	21 e0       	ldi	r18, 0x01	; 1
      fa:	a6 ed       	ldi	r26, 0xD6	; 214
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	a4 36       	cpi	r26, 0x64	; 100
     104:	b2 07       	cpc	r27, r18
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 8a 00 	call	0x114	; 0x114 <main>
     10c:	0c 94 9f 14 	jmp	0x293e	; 0x293e <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <main>:
uint8 count_password_tring=0;
uint8 data_temp;


int main(void)
{
     114:	0f 93       	push	r16
     116:	1f 93       	push	r17
     118:	cf 93       	push	r28
     11a:	df 93       	push	r29
     11c:	cd b7       	in	r28, 0x3d	; 61
     11e:	de b7       	in	r29, 0x3e	; 62
     120:	c2 58       	subi	r28, 0x82	; 130
     122:	d1 09       	sbc	r29, r1
     124:	0f b6       	in	r0, 0x3f	; 63
     126:	f8 94       	cli
     128:	de bf       	out	0x3e, r29	; 62
     12a:	0f be       	out	0x3f, r0	; 63
     12c:	cd bf       	out	0x3d, r28	; 61
	SREG|=(1<<7); /*Global interrupt enable */
     12e:	8f e5       	ldi	r24, 0x5F	; 95
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	2f e5       	ldi	r18, 0x5F	; 95
     134:	30 e0       	ldi	r19, 0x00	; 0
     136:	f9 01       	movw	r30, r18
     138:	20 81       	ld	r18, Z
     13a:	20 68       	ori	r18, 0x80	; 128
     13c:	fc 01       	movw	r30, r24
     13e:	20 83       	st	Z, r18
/*	initialize peripheral  */

	/* UART initialization */
		UART_configurationType UART_config ;
		UART_config.buadRate=9600;
     140:	9e 01       	movw	r18, r28
     142:	2b 5a       	subi	r18, 0xAB	; 171
     144:	3f 4f       	sbci	r19, 0xFF	; 255
     146:	80 e8       	ldi	r24, 0x80	; 128
     148:	95 e2       	ldi	r25, 0x25	; 37
     14a:	a0 e0       	ldi	r26, 0x00	; 0
     14c:	b0 e0       	ldi	r27, 0x00	; 0
     14e:	f9 01       	movw	r30, r18
     150:	81 83       	std	Z+1, r24	; 0x01
     152:	92 83       	std	Z+2, r25	; 0x02
     154:	a3 83       	std	Z+3, r26	; 0x03
     156:	b4 83       	std	Z+4, r27	; 0x04
			UART_config.character_size=8;
     158:	ce 01       	movw	r24, r28
     15a:	8b 5a       	subi	r24, 0xAB	; 171
     15c:	9f 4f       	sbci	r25, 0xFF	; 255
     15e:	28 e0       	ldi	r18, 0x08	; 8
     160:	fc 01       	movw	r30, r24
     162:	20 83       	st	Z, r18
			strcpy(UART_config.mode,"double speed");
     164:	ce 01       	movw	r24, r28
     166:	8b 5a       	subi	r24, 0xAB	; 171
     168:	9f 4f       	sbci	r25, 0xFF	; 255
     16a:	05 96       	adiw	r24, 0x05	; 5
     16c:	2d e0       	ldi	r18, 0x0D	; 13
     16e:	e0 e6       	ldi	r30, 0x60	; 96
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	dc 01       	movw	r26, r24
     174:	01 90       	ld	r0, Z+
     176:	0d 92       	st	X+, r0
     178:	2a 95       	dec	r18
     17a:	e1 f7       	brne	.-8      	; 0x174 <main+0x60>
			strcpy(UART_config.parity,"disable");
     17c:	ce 01       	movw	r24, r28
     17e:	8b 5a       	subi	r24, 0xAB	; 171
     180:	9f 4f       	sbci	r25, 0xFF	; 255
     182:	49 96       	adiw	r24, 0x19	; 25
     184:	28 e0       	ldi	r18, 0x08	; 8
     186:	ed e6       	ldi	r30, 0x6D	; 109
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	dc 01       	movw	r26, r24
     18c:	01 90       	ld	r0, Z+
     18e:	0d 92       	st	X+, r0
     190:	2a 95       	dec	r18
     192:	e1 f7       	brne	.-8      	; 0x18c <main+0x78>
			UART_config.stop_bit_number=1;
     194:	ce 01       	movw	r24, r28
     196:	8b 5a       	subi	r24, 0xAB	; 171
     198:	9f 4f       	sbci	r25, 0xFF	; 255
     19a:	21 e0       	ldi	r18, 0x01	; 1
     19c:	fc 01       	movw	r30, r24
     19e:	25 a7       	std	Z+45, r18	; 0x2d
			UART_init(&UART_config);
     1a0:	ce 01       	movw	r24, r28
     1a2:	8b 5a       	subi	r24, 0xAB	; 171
     1a4:	9f 4f       	sbci	r25, 0xFF	; 255
     1a6:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <UART_init>
	/*EEPROM initialization */
		EEPROM_init();
     1aa:	0e 94 7f 05 	call	0xafe	; 0xafe <EEPROM_init>

	/* TIMER configuration which set in actuators module */
		timer_set();
     1ae:	0e 94 af 04 	call	0x95e	; 0x95e <timer_set>
     1b2:	80 e0       	ldi	r24, 0x00	; 0
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	a8 ec       	ldi	r26, 0xC8	; 200
     1b8:	b2 e4       	ldi	r27, 0x42	; 66
     1ba:	8d 8b       	std	Y+21, r24	; 0x15
     1bc:	9e 8b       	std	Y+22, r25	; 0x16
     1be:	af 8b       	std	Y+23, r26	; 0x17
     1c0:	b8 8f       	std	Y+24, r27	; 0x18

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     1c2:	20 e0       	ldi	r18, 0x00	; 0
     1c4:	30 e0       	ldi	r19, 0x00	; 0
     1c6:	4a ef       	ldi	r20, 0xFA	; 250
     1c8:	54 e4       	ldi	r21, 0x44	; 68
     1ca:	6d 89       	ldd	r22, Y+21	; 0x15
     1cc:	7e 89       	ldd	r23, Y+22	; 0x16
     1ce:	8f 89       	ldd	r24, Y+23	; 0x17
     1d0:	98 8d       	ldd	r25, Y+24	; 0x18
     1d2:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     1d6:	dc 01       	movw	r26, r24
     1d8:	cb 01       	movw	r24, r22
     1da:	89 8f       	std	Y+25, r24	; 0x19
     1dc:	9a 8f       	std	Y+26, r25	; 0x1a
     1de:	ab 8f       	std	Y+27, r26	; 0x1b
     1e0:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     1e2:	20 e0       	ldi	r18, 0x00	; 0
     1e4:	30 e0       	ldi	r19, 0x00	; 0
     1e6:	40 e8       	ldi	r20, 0x80	; 128
     1e8:	5f e3       	ldi	r21, 0x3F	; 63
     1ea:	69 8d       	ldd	r22, Y+25	; 0x19
     1ec:	7a 8d       	ldd	r23, Y+26	; 0x1a
     1ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
     1f0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     1f2:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     1f6:	88 23       	and	r24, r24
     1f8:	2c f4       	brge	.+10     	; 0x204 <main+0xf0>
		__ticks = 1;
     1fa:	81 e0       	ldi	r24, 0x01	; 1
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	9e 8f       	std	Y+30, r25	; 0x1e
     200:	8d 8f       	std	Y+29, r24	; 0x1d
     202:	3f c0       	rjmp	.+126    	; 0x282 <main+0x16e>
	else if (__tmp > 65535)
     204:	20 e0       	ldi	r18, 0x00	; 0
     206:	3f ef       	ldi	r19, 0xFF	; 255
     208:	4f e7       	ldi	r20, 0x7F	; 127
     20a:	57 e4       	ldi	r21, 0x47	; 71
     20c:	69 8d       	ldd	r22, Y+25	; 0x19
     20e:	7a 8d       	ldd	r23, Y+26	; 0x1a
     210:	8b 8d       	ldd	r24, Y+27	; 0x1b
     212:	9c 8d       	ldd	r25, Y+28	; 0x1c
     214:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     218:	18 16       	cp	r1, r24
     21a:	4c f5       	brge	.+82     	; 0x26e <main+0x15a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	40 e2       	ldi	r20, 0x20	; 32
     222:	51 e4       	ldi	r21, 0x41	; 65
     224:	6d 89       	ldd	r22, Y+21	; 0x15
     226:	7e 89       	ldd	r23, Y+22	; 0x16
     228:	8f 89       	ldd	r24, Y+23	; 0x17
     22a:	98 8d       	ldd	r25, Y+24	; 0x18
     22c:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     230:	dc 01       	movw	r26, r24
     232:	cb 01       	movw	r24, r22
     234:	bc 01       	movw	r22, r24
     236:	cd 01       	movw	r24, r26
     238:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     23c:	dc 01       	movw	r26, r24
     23e:	cb 01       	movw	r24, r22
     240:	9e 8f       	std	Y+30, r25	; 0x1e
     242:	8d 8f       	std	Y+29, r24	; 0x1d
     244:	0f c0       	rjmp	.+30     	; 0x264 <main+0x150>
     246:	88 ec       	ldi	r24, 0xC8	; 200
     248:	90 e0       	ldi	r25, 0x00	; 0
     24a:	98 a3       	std	Y+32, r25	; 0x20
     24c:	8f 8f       	std	Y+31, r24	; 0x1f
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     24e:	8f 8d       	ldd	r24, Y+31	; 0x1f
     250:	98 a1       	ldd	r25, Y+32	; 0x20
     252:	01 97       	sbiw	r24, 0x01	; 1
     254:	f1 f7       	brne	.-4      	; 0x252 <main+0x13e>
     256:	98 a3       	std	Y+32, r25	; 0x20
     258:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     25a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     25c:	9e 8d       	ldd	r25, Y+30	; 0x1e
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9e 8f       	std	Y+30, r25	; 0x1e
     262:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     264:	8d 8d       	ldd	r24, Y+29	; 0x1d
     266:	9e 8d       	ldd	r25, Y+30	; 0x1e
     268:	89 2b       	or	r24, r25
     26a:	69 f7       	brne	.-38     	; 0x246 <main+0x132>
     26c:	14 c0       	rjmp	.+40     	; 0x296 <main+0x182>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     26e:	69 8d       	ldd	r22, Y+25	; 0x19
     270:	7a 8d       	ldd	r23, Y+26	; 0x1a
     272:	8b 8d       	ldd	r24, Y+27	; 0x1b
     274:	9c 8d       	ldd	r25, Y+28	; 0x1c
     276:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     27a:	dc 01       	movw	r26, r24
     27c:	cb 01       	movw	r24, r22
     27e:	9e 8f       	std	Y+30, r25	; 0x1e
     280:	8d 8f       	std	Y+29, r24	; 0x1d
     282:	8d 8d       	ldd	r24, Y+29	; 0x1d
     284:	9e 8d       	ldd	r25, Y+30	; 0x1e
     286:	9a a3       	std	Y+34, r25	; 0x22
     288:	89 a3       	std	Y+33, r24	; 0x21
     28a:	89 a1       	ldd	r24, Y+33	; 0x21
     28c:	9a a1       	ldd	r25, Y+34	; 0x22
     28e:	01 97       	sbiw	r24, 0x01	; 1
     290:	f1 f7       	brne	.-4      	; 0x28e <main+0x17a>
     292:	9a a3       	std	Y+34, r25	; 0x22
     294:	89 a3       	std	Y+33, r24	; 0x21
 	   	_delay_ms(100); /* delay to force UART in control_ECU synchronize with HMI_ECU */


 	   	/*check on a password stored flag if it equal predefine pattern=0xAA in specified address 0x0011
 	  */
    	EEPROM_readByte(0x0011,&password_stored_flag);
     296:	6e ef       	ldi	r22, 0xFE	; 254
     298:	70 e0       	ldi	r23, 0x00	; 0
     29a:	81 e1       	ldi	r24, 0x11	; 17
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <EEPROM_readByte>

/***************************************************************
* 		CASE 0 : password already set	*
* *************************************************************
*/
    	if(((password_stored_flag ==0xAA)&&(count_password_tring<3)&&(set_password_now_flag==0)&&(!block_buzzer_scope)))
     2a2:	80 91 fe 00 	lds	r24, 0x00FE	; 0x8000fe <password_stored_flag>
     2a6:	8a 3a       	cpi	r24, 0xAA	; 170
     2a8:	09 f0       	breq	.+2      	; 0x2ac <main+0x198>
     2aa:	a0 c1       	rjmp	.+832    	; 0x5ec <__stack+0x18d>
     2ac:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <count_password_tring>
     2b0:	83 30       	cpi	r24, 0x03	; 3
     2b2:	08 f0       	brcs	.+2      	; 0x2b6 <main+0x1a2>
     2b4:	9b c1       	rjmp	.+822    	; 0x5ec <__stack+0x18d>
     2b6:	80 91 ff 00 	lds	r24, 0x00FF	; 0x8000ff <set_password_now_flag>
     2ba:	88 23       	and	r24, r24
     2bc:	09 f0       	breq	.+2      	; 0x2c0 <main+0x1ac>
     2be:	96 c1       	rjmp	.+812    	; 0x5ec <__stack+0x18d>
     2c0:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <block_buzzer_scope>
     2c4:	88 23       	and	r24, r24
     2c6:	09 f0       	breq	.+2      	; 0x2ca <main+0x1b6>
     2c8:	91 c1       	rjmp	.+802    	; 0x5ec <__stack+0x18d>
 * is stored in EEPROM and
 *  not exceeded 3 times trying to enter password
 * user dosent set the password now as no need to check password
 * waiting 1 minutes until finishing waring
 */
    		UART_sendByte('e'); /* send 'e' point to enter password */
     2ca:	85 e6       	ldi	r24, 0x65	; 101
     2cc:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>
     2d0:	80 e0       	ldi	r24, 0x00	; 0
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	a0 e2       	ldi	r26, 0x20	; 32
     2d6:	b1 e4       	ldi	r27, 0x41	; 65
     2d8:	89 87       	std	Y+9, r24	; 0x09
     2da:	9a 87       	std	Y+10, r25	; 0x0a
     2dc:	ab 87       	std	Y+11, r26	; 0x0b
     2de:	bc 87       	std	Y+12, r27	; 0x0c

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	30 e0       	ldi	r19, 0x00	; 0
     2e4:	4a ef       	ldi	r20, 0xFA	; 250
     2e6:	54 e4       	ldi	r21, 0x44	; 68
     2e8:	69 85       	ldd	r22, Y+9	; 0x09
     2ea:	7a 85       	ldd	r23, Y+10	; 0x0a
     2ec:	8b 85       	ldd	r24, Y+11	; 0x0b
     2ee:	9c 85       	ldd	r25, Y+12	; 0x0c
     2f0:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     2f4:	dc 01       	movw	r26, r24
     2f6:	cb 01       	movw	r24, r22
     2f8:	8f ab       	std	Y+55, r24	; 0x37
     2fa:	98 af       	std	Y+56, r25	; 0x38
     2fc:	a9 af       	std	Y+57, r26	; 0x39
     2fe:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
     300:	20 e0       	ldi	r18, 0x00	; 0
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	40 e8       	ldi	r20, 0x80	; 128
     306:	5f e3       	ldi	r21, 0x3F	; 63
     308:	6f a9       	ldd	r22, Y+55	; 0x37
     30a:	78 ad       	ldd	r23, Y+56	; 0x38
     30c:	89 ad       	ldd	r24, Y+57	; 0x39
     30e:	9a ad       	ldd	r25, Y+58	; 0x3a
     310:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     314:	88 23       	and	r24, r24
     316:	2c f4       	brge	.+10     	; 0x322 <main+0x20e>
		__ticks = 1;
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	9c af       	std	Y+60, r25	; 0x3c
     31e:	8b af       	std	Y+59, r24	; 0x3b
     320:	3f c0       	rjmp	.+126    	; 0x3a0 <main+0x28c>
	else if (__tmp > 65535)
     322:	20 e0       	ldi	r18, 0x00	; 0
     324:	3f ef       	ldi	r19, 0xFF	; 255
     326:	4f e7       	ldi	r20, 0x7F	; 127
     328:	57 e4       	ldi	r21, 0x47	; 71
     32a:	6f a9       	ldd	r22, Y+55	; 0x37
     32c:	78 ad       	ldd	r23, Y+56	; 0x38
     32e:	89 ad       	ldd	r24, Y+57	; 0x39
     330:	9a ad       	ldd	r25, Y+58	; 0x3a
     332:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     336:	18 16       	cp	r1, r24
     338:	4c f5       	brge	.+82     	; 0x38c <main+0x278>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     33a:	20 e0       	ldi	r18, 0x00	; 0
     33c:	30 e0       	ldi	r19, 0x00	; 0
     33e:	40 e2       	ldi	r20, 0x20	; 32
     340:	51 e4       	ldi	r21, 0x41	; 65
     342:	69 85       	ldd	r22, Y+9	; 0x09
     344:	7a 85       	ldd	r23, Y+10	; 0x0a
     346:	8b 85       	ldd	r24, Y+11	; 0x0b
     348:	9c 85       	ldd	r25, Y+12	; 0x0c
     34a:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     34e:	dc 01       	movw	r26, r24
     350:	cb 01       	movw	r24, r22
     352:	bc 01       	movw	r22, r24
     354:	cd 01       	movw	r24, r26
     356:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     35a:	dc 01       	movw	r26, r24
     35c:	cb 01       	movw	r24, r22
     35e:	9c af       	std	Y+60, r25	; 0x3c
     360:	8b af       	std	Y+59, r24	; 0x3b
     362:	0f c0       	rjmp	.+30     	; 0x382 <main+0x26e>
     364:	88 ec       	ldi	r24, 0xC8	; 200
     366:	90 e0       	ldi	r25, 0x00	; 0
     368:	9e af       	std	Y+62, r25	; 0x3e
     36a:	8d af       	std	Y+61, r24	; 0x3d
     36c:	8d ad       	ldd	r24, Y+61	; 0x3d
     36e:	9e ad       	ldd	r25, Y+62	; 0x3e
     370:	01 97       	sbiw	r24, 0x01	; 1
     372:	f1 f7       	brne	.-4      	; 0x370 <main+0x25c>
     374:	9e af       	std	Y+62, r25	; 0x3e
     376:	8d af       	std	Y+61, r24	; 0x3d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     378:	8b ad       	ldd	r24, Y+59	; 0x3b
     37a:	9c ad       	ldd	r25, Y+60	; 0x3c
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	9c af       	std	Y+60, r25	; 0x3c
     380:	8b af       	std	Y+59, r24	; 0x3b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     382:	8b ad       	ldd	r24, Y+59	; 0x3b
     384:	9c ad       	ldd	r25, Y+60	; 0x3c
     386:	89 2b       	or	r24, r25
     388:	69 f7       	brne	.-38     	; 0x364 <main+0x250>
     38a:	1e c0       	rjmp	.+60     	; 0x3c8 <main+0x2b4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     38c:	6f a9       	ldd	r22, Y+55	; 0x37
     38e:	78 ad       	ldd	r23, Y+56	; 0x38
     390:	89 ad       	ldd	r24, Y+57	; 0x39
     392:	9a ad       	ldd	r25, Y+58	; 0x3a
     394:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     398:	dc 01       	movw	r26, r24
     39a:	cb 01       	movw	r24, r22
     39c:	9c af       	std	Y+60, r25	; 0x3c
     39e:	8b af       	std	Y+59, r24	; 0x3b
     3a0:	2b ad       	ldd	r18, Y+59	; 0x3b
     3a2:	3c ad       	ldd	r19, Y+60	; 0x3c
     3a4:	ce 01       	movw	r24, r28
     3a6:	cf 96       	adiw	r24, 0x3f	; 63
     3a8:	fc 01       	movw	r30, r24
     3aa:	31 83       	std	Z+1, r19	; 0x01
     3ac:	20 83       	st	Z, r18
     3ae:	ce 01       	movw	r24, r28
     3b0:	cf 96       	adiw	r24, 0x3f	; 63
     3b2:	fc 01       	movw	r30, r24
     3b4:	80 81       	ld	r24, Z
     3b6:	91 81       	ldd	r25, Z+1	; 0x01
     3b8:	01 97       	sbiw	r24, 0x01	; 1
     3ba:	f1 f7       	brne	.-4      	; 0x3b8 <main+0x2a4>
     3bc:	9e 01       	movw	r18, r28
     3be:	21 5c       	subi	r18, 0xC1	; 193
     3c0:	3f 4f       	sbci	r19, 0xFF	; 255
     3c2:	f9 01       	movw	r30, r18
     3c4:	91 83       	std	Z+1, r25	; 0x01
     3c6:	80 83       	st	Z, r24
     	   	_delay_ms(10);
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
     3c8:	8a ee       	ldi	r24, 0xEA	; 234
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <UART_receiveString>
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	a0 e2       	ldi	r26, 0x20	; 32
     3d6:	b1 e4       	ldi	r27, 0x41	; 65
     3d8:	8d 87       	std	Y+13, r24	; 0x0d
     3da:	9e 87       	std	Y+14, r25	; 0x0e
     3dc:	af 87       	std	Y+15, r26	; 0x0f
     3de:	b8 8b       	std	Y+16, r27	; 0x10

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     3e0:	20 e0       	ldi	r18, 0x00	; 0
     3e2:	30 e0       	ldi	r19, 0x00	; 0
     3e4:	4a ef       	ldi	r20, 0xFA	; 250
     3e6:	54 e4       	ldi	r21, 0x44	; 68
     3e8:	6d 85       	ldd	r22, Y+13	; 0x0d
     3ea:	7e 85       	ldd	r23, Y+14	; 0x0e
     3ec:	8f 85       	ldd	r24, Y+15	; 0x0f
     3ee:	98 89       	ldd	r25, Y+16	; 0x10
     3f0:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     3f4:	dc 01       	movw	r26, r24
     3f6:	cb 01       	movw	r24, r22
     3f8:	8d a7       	std	Y+45, r24	; 0x2d
     3fa:	9e a7       	std	Y+46, r25	; 0x2e
     3fc:	af a7       	std	Y+47, r26	; 0x2f
     3fe:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
     400:	20 e0       	ldi	r18, 0x00	; 0
     402:	30 e0       	ldi	r19, 0x00	; 0
     404:	40 e8       	ldi	r20, 0x80	; 128
     406:	5f e3       	ldi	r21, 0x3F	; 63
     408:	6d a5       	ldd	r22, Y+45	; 0x2d
     40a:	7e a5       	ldd	r23, Y+46	; 0x2e
     40c:	8f a5       	ldd	r24, Y+47	; 0x2f
     40e:	98 a9       	ldd	r25, Y+48	; 0x30
     410:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     414:	88 23       	and	r24, r24
     416:	2c f4       	brge	.+10     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
		__ticks = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a ab       	std	Y+50, r25	; 0x32
     41e:	89 ab       	std	Y+49, r24	; 0x31
     420:	3f c0       	rjmp	.+126    	; 0x4a0 <__stack+0x41>
	else if (__tmp > 65535)
     422:	20 e0       	ldi	r18, 0x00	; 0
     424:	3f ef       	ldi	r19, 0xFF	; 255
     426:	4f e7       	ldi	r20, 0x7F	; 127
     428:	57 e4       	ldi	r21, 0x47	; 71
     42a:	6d a5       	ldd	r22, Y+45	; 0x2d
     42c:	7e a5       	ldd	r23, Y+46	; 0x2e
     42e:	8f a5       	ldd	r24, Y+47	; 0x2f
     430:	98 a9       	ldd	r25, Y+48	; 0x30
     432:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     436:	18 16       	cp	r1, r24
     438:	4c f5       	brge	.+82     	; 0x48c <__stack+0x2d>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     43a:	20 e0       	ldi	r18, 0x00	; 0
     43c:	30 e0       	ldi	r19, 0x00	; 0
     43e:	40 e2       	ldi	r20, 0x20	; 32
     440:	51 e4       	ldi	r21, 0x41	; 65
     442:	6d 85       	ldd	r22, Y+13	; 0x0d
     444:	7e 85       	ldd	r23, Y+14	; 0x0e
     446:	8f 85       	ldd	r24, Y+15	; 0x0f
     448:	98 89       	ldd	r25, Y+16	; 0x10
     44a:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     44e:	dc 01       	movw	r26, r24
     450:	cb 01       	movw	r24, r22
     452:	bc 01       	movw	r22, r24
     454:	cd 01       	movw	r24, r26
     456:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     45a:	dc 01       	movw	r26, r24
     45c:	cb 01       	movw	r24, r22
     45e:	9a ab       	std	Y+50, r25	; 0x32
     460:	89 ab       	std	Y+49, r24	; 0x31
     462:	0f c0       	rjmp	.+30     	; 0x482 <__stack+0x23>
     464:	88 ec       	ldi	r24, 0xC8	; 200
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	9c ab       	std	Y+52, r25	; 0x34
     46a:	8b ab       	std	Y+51, r24	; 0x33
     46c:	8b a9       	ldd	r24, Y+51	; 0x33
     46e:	9c a9       	ldd	r25, Y+52	; 0x34
     470:	01 97       	sbiw	r24, 0x01	; 1
     472:	f1 f7       	brne	.-4      	; 0x470 <__stack+0x11>
     474:	9c ab       	std	Y+52, r25	; 0x34
     476:	8b ab       	std	Y+51, r24	; 0x33
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     478:	89 a9       	ldd	r24, Y+49	; 0x31
     47a:	9a a9       	ldd	r25, Y+50	; 0x32
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9a ab       	std	Y+50, r25	; 0x32
     480:	89 ab       	std	Y+49, r24	; 0x31
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     482:	89 a9       	ldd	r24, Y+49	; 0x31
     484:	9a a9       	ldd	r25, Y+50	; 0x32
     486:	89 2b       	or	r24, r25
     488:	69 f7       	brne	.-38     	; 0x464 <__stack+0x5>
     48a:	14 c0       	rjmp	.+40     	; 0x4b4 <__stack+0x55>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     48c:	6d a5       	ldd	r22, Y+45	; 0x2d
     48e:	7e a5       	ldd	r23, Y+46	; 0x2e
     490:	8f a5       	ldd	r24, Y+47	; 0x2f
     492:	98 a9       	ldd	r25, Y+48	; 0x30
     494:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     498:	dc 01       	movw	r26, r24
     49a:	cb 01       	movw	r24, r22
     49c:	9a ab       	std	Y+50, r25	; 0x32
     49e:	89 ab       	std	Y+49, r24	; 0x31
     4a0:	89 a9       	ldd	r24, Y+49	; 0x31
     4a2:	9a a9       	ldd	r25, Y+50	; 0x32
     4a4:	9e ab       	std	Y+54, r25	; 0x36
     4a6:	8d ab       	std	Y+53, r24	; 0x35
     4a8:	8d a9       	ldd	r24, Y+53	; 0x35
     4aa:	9e a9       	ldd	r25, Y+54	; 0x36
     4ac:	01 97       	sbiw	r24, 0x01	; 1
     4ae:	f1 f7       	brne	.-4      	; 0x4ac <__stack+0x4d>
     4b0:	9e ab       	std	Y+54, r25	; 0x36
     4b2:	8d ab       	std	Y+53, r24	; 0x35
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
     4b4:	66 ed       	ldi	r22, 0xD6	; 214
     4b6:	70 e0       	ldi	r23, 0x00	; 0
     4b8:	82 e1       	ldi	r24, 0x12	; 18
     4ba:	95 e0       	ldi	r25, 0x05	; 5
     4bc:	0e 94 f1 06 	call	0xde2	; 0xde2 <EEPROM_readString>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	a0 e2       	ldi	r26, 0x20	; 32
     4c6:	b1 e4       	ldi	r27, 0x41	; 65
     4c8:	89 83       	std	Y+1, r24	; 0x01
     4ca:	9a 83       	std	Y+2, r25	; 0x02
     4cc:	ab 83       	std	Y+3, r26	; 0x03
     4ce:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     4d0:	20 e0       	ldi	r18, 0x00	; 0
     4d2:	30 e0       	ldi	r19, 0x00	; 0
     4d4:	4a ef       	ldi	r20, 0xFA	; 250
     4d6:	54 e4       	ldi	r21, 0x44	; 68
     4d8:	69 81       	ldd	r22, Y+1	; 0x01
     4da:	7a 81       	ldd	r23, Y+2	; 0x02
     4dc:	8b 81       	ldd	r24, Y+3	; 0x03
     4de:	9c 81       	ldd	r25, Y+4	; 0x04
     4e0:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     4e4:	dc 01       	movw	r26, r24
     4e6:	cb 01       	movw	r24, r22
     4e8:	8b a3       	std	Y+35, r24	; 0x23
     4ea:	9c a3       	std	Y+36, r25	; 0x24
     4ec:	ad a3       	std	Y+37, r26	; 0x25
     4ee:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	30 e0       	ldi	r19, 0x00	; 0
     4f4:	40 e8       	ldi	r20, 0x80	; 128
     4f6:	5f e3       	ldi	r21, 0x3F	; 63
     4f8:	6b a1       	ldd	r22, Y+35	; 0x23
     4fa:	7c a1       	ldd	r23, Y+36	; 0x24
     4fc:	8d a1       	ldd	r24, Y+37	; 0x25
     4fe:	9e a1       	ldd	r25, Y+38	; 0x26
     500:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     504:	88 23       	and	r24, r24
     506:	2c f4       	brge	.+10     	; 0x512 <__stack+0xb3>
		__ticks = 1;
     508:	81 e0       	ldi	r24, 0x01	; 1
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	98 a7       	std	Y+40, r25	; 0x28
     50e:	8f a3       	std	Y+39, r24	; 0x27
     510:	3f c0       	rjmp	.+126    	; 0x590 <__stack+0x131>
	else if (__tmp > 65535)
     512:	20 e0       	ldi	r18, 0x00	; 0
     514:	3f ef       	ldi	r19, 0xFF	; 255
     516:	4f e7       	ldi	r20, 0x7F	; 127
     518:	57 e4       	ldi	r21, 0x47	; 71
     51a:	6b a1       	ldd	r22, Y+35	; 0x23
     51c:	7c a1       	ldd	r23, Y+36	; 0x24
     51e:	8d a1       	ldd	r24, Y+37	; 0x25
     520:	9e a1       	ldd	r25, Y+38	; 0x26
     522:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     526:	18 16       	cp	r1, r24
     528:	4c f5       	brge	.+82     	; 0x57c <__stack+0x11d>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     52a:	20 e0       	ldi	r18, 0x00	; 0
     52c:	30 e0       	ldi	r19, 0x00	; 0
     52e:	40 e2       	ldi	r20, 0x20	; 32
     530:	51 e4       	ldi	r21, 0x41	; 65
     532:	69 81       	ldd	r22, Y+1	; 0x01
     534:	7a 81       	ldd	r23, Y+2	; 0x02
     536:	8b 81       	ldd	r24, Y+3	; 0x03
     538:	9c 81       	ldd	r25, Y+4	; 0x04
     53a:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     53e:	dc 01       	movw	r26, r24
     540:	cb 01       	movw	r24, r22
     542:	bc 01       	movw	r22, r24
     544:	cd 01       	movw	r24, r26
     546:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     54a:	dc 01       	movw	r26, r24
     54c:	cb 01       	movw	r24, r22
     54e:	98 a7       	std	Y+40, r25	; 0x28
     550:	8f a3       	std	Y+39, r24	; 0x27
     552:	0f c0       	rjmp	.+30     	; 0x572 <__stack+0x113>
     554:	88 ec       	ldi	r24, 0xC8	; 200
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	9a a7       	std	Y+42, r25	; 0x2a
     55a:	89 a7       	std	Y+41, r24	; 0x29
     55c:	89 a5       	ldd	r24, Y+41	; 0x29
     55e:	9a a5       	ldd	r25, Y+42	; 0x2a
     560:	01 97       	sbiw	r24, 0x01	; 1
     562:	f1 f7       	brne	.-4      	; 0x560 <__stack+0x101>
     564:	9a a7       	std	Y+42, r25	; 0x2a
     566:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     568:	8f a1       	ldd	r24, Y+39	; 0x27
     56a:	98 a5       	ldd	r25, Y+40	; 0x28
     56c:	01 97       	sbiw	r24, 0x01	; 1
     56e:	98 a7       	std	Y+40, r25	; 0x28
     570:	8f a3       	std	Y+39, r24	; 0x27
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     572:	8f a1       	ldd	r24, Y+39	; 0x27
     574:	98 a5       	ldd	r25, Y+40	; 0x28
     576:	89 2b       	or	r24, r25
     578:	69 f7       	brne	.-38     	; 0x554 <__stack+0xf5>
     57a:	14 c0       	rjmp	.+40     	; 0x5a4 <__stack+0x145>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     57c:	6b a1       	ldd	r22, Y+35	; 0x23
     57e:	7c a1       	ldd	r23, Y+36	; 0x24
     580:	8d a1       	ldd	r24, Y+37	; 0x25
     582:	9e a1       	ldd	r25, Y+38	; 0x26
     584:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     588:	dc 01       	movw	r26, r24
     58a:	cb 01       	movw	r24, r22
     58c:	98 a7       	std	Y+40, r25	; 0x28
     58e:	8f a3       	std	Y+39, r24	; 0x27
     590:	8f a1       	ldd	r24, Y+39	; 0x27
     592:	98 a5       	ldd	r25, Y+40	; 0x28
     594:	9c a7       	std	Y+44, r25	; 0x2c
     596:	8b a7       	std	Y+43, r24	; 0x2b
     598:	8b a5       	ldd	r24, Y+43	; 0x2b
     59a:	9c a5       	ldd	r25, Y+44	; 0x2c
     59c:	01 97       	sbiw	r24, 0x01	; 1
     59e:	f1 f7       	brne	.-4      	; 0x59c <__stack+0x13d>
     5a0:	9c a7       	std	Y+44, r25	; 0x2c
     5a2:	8b a7       	std	Y+43, r24	; 0x2b
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5a4:	66 ed       	ldi	r22, 0xD6	; 214
     5a6:	70 e0       	ldi	r23, 0x00	; 0
     5a8:	8a ee       	ldi	r24, 0xEA	; 234
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
     5b0:	89 2b       	or	r24, r25
     5b2:	b1 f4       	brne	.+44     	; 0x5e0 <__stack+0x181>
    		{ /* if entered and stored password are typical
    		 	give user 2 option by sending 'w':
    		 	open door (o)
    		 	reset the password (reset the password (s)
    		 	*/
        		UART_sendByte('w');
     5b4:	87 e7       	ldi	r24, 0x77	; 119
     5b6:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>
        		data_temp=UART_receiveByte();
     5ba:	0e 94 11 10 	call	0x2022	; 0x2022 <UART_receiveByte>
     5be:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <data_temp>
        		if(data_temp=='s')
     5c2:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <data_temp>
     5c6:	83 37       	cpi	r24, 0x73	; 115
     5c8:	21 f4       	brne	.+8      	; 0x5d2 <__stack+0x173>
        			force_set=1;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <force_set>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5d0:	28 c0       	rjmp	.+80     	; 0x622 <__stack+0x1c3>
    		 	*/
        		UART_sendByte('w');
        		data_temp=UART_receiveByte();
        		if(data_temp=='s')
        			force_set=1;
        		else if(data_temp=='o')
     5d2:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <data_temp>
     5d6:	8f 36       	cpi	r24, 0x6F	; 111
     5d8:	21 f5       	brne	.+72     	; 0x622 <__stack+0x1c3>
        		{
        			 motor_run();
     5da:	0e 94 cd 04 	call	0x99a	; 0x99a <motor_run>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5de:	21 c0       	rjmp	.+66     	; 0x622 <__stack+0x1c3>
        		}
    		 }
    		else
    		{
    			/* count how many user try enter the password */
    			count_password_tring++;
     5e0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <count_password_tring>
     5e4:	8f 5f       	subi	r24, 0xFF	; 255
     5e6:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <count_password_tring>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5ea:	1b c0       	rjmp	.+54     	; 0x622 <__stack+0x1c3>
/*******************************************************************************
* 		CASE 1 : password already set and user try enter password than 3 times	*
* ******************************************************************************
*/

    	else if((password_stored_flag ==0xAA)&&(count_password_tring>=3)&&(set_password_now_flag==0)&&(!block_buzzer_scope))
     5ec:	80 91 fe 00 	lds	r24, 0x00FE	; 0x8000fe <password_stored_flag>
     5f0:	8a 3a       	cpi	r24, 0xAA	; 170
     5f2:	c1 f4       	brne	.+48     	; 0x624 <__stack+0x1c5>
     5f4:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <count_password_tring>
     5f8:	83 30       	cpi	r24, 0x03	; 3
     5fa:	a0 f0       	brcs	.+40     	; 0x624 <__stack+0x1c5>
     5fc:	80 91 ff 00 	lds	r24, 0x00FF	; 0x8000ff <set_password_now_flag>
     600:	88 23       	and	r24, r24
     602:	81 f4       	brne	.+32     	; 0x624 <__stack+0x1c5>
     604:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <block_buzzer_scope>
     608:	88 23       	and	r24, r24
     60a:	61 f4       	brne	.+24     	; 0x624 <__stack+0x1c5>
    		 * user dosent set the password now as no need to check password
    		 * waiting 1 minutes until finishing waring
    		 */


    		UART_sendByte('B'); /* send 'B' to HMI ECU TO Clear the screan */
     60c:	82 e4       	ldi	r24, 0x42	; 66
     60e:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>
    		buzzer(); /* run buzzer warning */
     612:	0e 94 37 05 	call	0xa6e	; 0xa6e <buzzer>
    		block_buzzer_scope=1; /* block this scope until timer spend 1 minute and the timer ISR will return it to zero*/
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <block_buzzer_scope>
    		count_password_tring=0; /*restart the operation */
     61c:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <count_password_tring>
     620:	01 c0       	rjmp	.+2      	; 0x624 <__stack+0x1c5>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     622:	00 00       	nop
    	/***************************************************************
    	* 		CASE 2 : first time and user should set password	*
    	* *************************************************************
    	*/

    	if(((password_stored_flag !=0xAA)&&(set_password_now_flag==0))||force_set)
     624:	80 91 fe 00 	lds	r24, 0x00FE	; 0x8000fe <password_stored_flag>
     628:	8a 3a       	cpi	r24, 0xAA	; 170
     62a:	21 f0       	breq	.+8      	; 0x634 <__stack+0x1d5>
     62c:	80 91 ff 00 	lds	r24, 0x00FF	; 0x8000ff <set_password_now_flag>
     630:	88 23       	and	r24, r24
     632:	29 f0       	breq	.+10     	; 0x63e <__stack+0x1df>
     634:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <force_set>
     638:	88 23       	and	r24, r24
     63a:	09 f4       	brne	.+2      	; 0x63e <__stack+0x1df>
     63c:	ba cd       	rjmp	.-1164   	; 0x1b2 <main+0x9e>
    		/* condition to enter this case
    		 *  password is not stored in EEPROM
    		 * user dosent set the password now as no need to reset the password
    		 */

        	UART_sendByte('s'); /*send 's' to tell HMI ECU that CONTROL ECU  ready to store the new password */
     63e:	83 e7       	ldi	r24, 0x73	; 115
     640:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>
    	UART_receiveString(password_stored);
     644:	88 e0       	ldi	r24, 0x08	; 8
     646:	91 e0       	ldi	r25, 0x01	; 1
     648:	0e 94 74 10 	call	0x20e8	; 0x20e8 <UART_receiveString>
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	a8 ec       	ldi	r26, 0xC8	; 200
     652:	b2 e4       	ldi	r27, 0x42	; 66
     654:	89 8b       	std	Y+17, r24	; 0x11
     656:	9a 8b       	std	Y+18, r25	; 0x12
     658:	ab 8b       	std	Y+19, r26	; 0x13
     65a:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     65c:	8e 01       	movw	r16, r28
     65e:	05 5b       	subi	r16, 0xB5	; 181
     660:	1f 4f       	sbci	r17, 0xFF	; 255
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	4a ef       	ldi	r20, 0xFA	; 250
     668:	54 e4       	ldi	r21, 0x44	; 68
     66a:	69 89       	ldd	r22, Y+17	; 0x11
     66c:	7a 89       	ldd	r23, Y+18	; 0x12
     66e:	8b 89       	ldd	r24, Y+19	; 0x13
     670:	9c 89       	ldd	r25, Y+20	; 0x14
     672:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     676:	dc 01       	movw	r26, r24
     678:	cb 01       	movw	r24, r22
     67a:	f8 01       	movw	r30, r16
     67c:	80 83       	st	Z, r24
     67e:	91 83       	std	Z+1, r25	; 0x01
     680:	a2 83       	std	Z+2, r26	; 0x02
     682:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     684:	ce 01       	movw	r24, r28
     686:	85 5b       	subi	r24, 0xB5	; 181
     688:	9f 4f       	sbci	r25, 0xFF	; 255
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	40 e8       	ldi	r20, 0x80	; 128
     690:	5f e3       	ldi	r21, 0x3F	; 63
     692:	fc 01       	movw	r30, r24
     694:	60 81       	ld	r22, Z
     696:	71 81       	ldd	r23, Z+1	; 0x01
     698:	82 81       	ldd	r24, Z+2	; 0x02
     69a:	93 81       	ldd	r25, Z+3	; 0x03
     69c:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     6a0:	88 23       	and	r24, r24
     6a2:	4c f4       	brge	.+18     	; 0x6b6 <__stack+0x257>
		__ticks = 1;
     6a4:	ce 01       	movw	r24, r28
     6a6:	81 5b       	subi	r24, 0xB1	; 177
     6a8:	9f 4f       	sbci	r25, 0xFF	; 255
     6aa:	21 e0       	ldi	r18, 0x01	; 1
     6ac:	30 e0       	ldi	r19, 0x00	; 0
     6ae:	fc 01       	movw	r30, r24
     6b0:	31 83       	std	Z+1, r19	; 0x01
     6b2:	20 83       	st	Z, r18
     6b4:	69 c0       	rjmp	.+210    	; 0x788 <__stack+0x329>
	else if (__tmp > 65535)
     6b6:	ce 01       	movw	r24, r28
     6b8:	85 5b       	subi	r24, 0xB5	; 181
     6ba:	9f 4f       	sbci	r25, 0xFF	; 255
     6bc:	20 e0       	ldi	r18, 0x00	; 0
     6be:	3f ef       	ldi	r19, 0xFF	; 255
     6c0:	4f e7       	ldi	r20, 0x7F	; 127
     6c2:	57 e4       	ldi	r21, 0x47	; 71
     6c4:	fc 01       	movw	r30, r24
     6c6:	60 81       	ld	r22, Z
     6c8:	71 81       	ldd	r23, Z+1	; 0x01
     6ca:	82 81       	ldd	r24, Z+2	; 0x02
     6cc:	93 81       	ldd	r25, Z+3	; 0x03
     6ce:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     6d2:	18 16       	cp	r1, r24
     6d4:	0c f0       	brlt	.+2      	; 0x6d8 <__stack+0x279>
     6d6:	46 c0       	rjmp	.+140    	; 0x764 <__stack+0x305>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     6d8:	20 e0       	ldi	r18, 0x00	; 0
     6da:	30 e0       	ldi	r19, 0x00	; 0
     6dc:	40 e2       	ldi	r20, 0x20	; 32
     6de:	51 e4       	ldi	r21, 0x41	; 65
     6e0:	69 89       	ldd	r22, Y+17	; 0x11
     6e2:	7a 89       	ldd	r23, Y+18	; 0x12
     6e4:	8b 89       	ldd	r24, Y+19	; 0x13
     6e6:	9c 89       	ldd	r25, Y+20	; 0x14
     6e8:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     6ec:	dc 01       	movw	r26, r24
     6ee:	cb 01       	movw	r24, r22
     6f0:	8e 01       	movw	r16, r28
     6f2:	01 5b       	subi	r16, 0xB1	; 177
     6f4:	1f 4f       	sbci	r17, 0xFF	; 255
     6f6:	bc 01       	movw	r22, r24
     6f8:	cd 01       	movw	r24, r26
     6fa:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     6fe:	dc 01       	movw	r26, r24
     700:	cb 01       	movw	r24, r22
     702:	f8 01       	movw	r30, r16
     704:	91 83       	std	Z+1, r25	; 0x01
     706:	80 83       	st	Z, r24
     708:	24 c0       	rjmp	.+72     	; 0x752 <__stack+0x2f3>
     70a:	ce 01       	movw	r24, r28
     70c:	8f 5a       	subi	r24, 0xAF	; 175
     70e:	9f 4f       	sbci	r25, 0xFF	; 255
     710:	28 ec       	ldi	r18, 0xC8	; 200
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	fc 01       	movw	r30, r24
     716:	31 83       	std	Z+1, r19	; 0x01
     718:	20 83       	st	Z, r18
     71a:	ce 01       	movw	r24, r28
     71c:	8f 5a       	subi	r24, 0xAF	; 175
     71e:	9f 4f       	sbci	r25, 0xFF	; 255
     720:	fc 01       	movw	r30, r24
     722:	80 81       	ld	r24, Z
     724:	91 81       	ldd	r25, Z+1	; 0x01
     726:	01 97       	sbiw	r24, 0x01	; 1
     728:	f1 f7       	brne	.-4      	; 0x726 <__stack+0x2c7>
     72a:	9e 01       	movw	r18, r28
     72c:	2f 5a       	subi	r18, 0xAF	; 175
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
     730:	f9 01       	movw	r30, r18
     732:	91 83       	std	Z+1, r25	; 0x01
     734:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     736:	ce 01       	movw	r24, r28
     738:	81 5b       	subi	r24, 0xB1	; 177
     73a:	9f 4f       	sbci	r25, 0xFF	; 255
     73c:	9e 01       	movw	r18, r28
     73e:	21 5b       	subi	r18, 0xB1	; 177
     740:	3f 4f       	sbci	r19, 0xFF	; 255
     742:	f9 01       	movw	r30, r18
     744:	20 81       	ld	r18, Z
     746:	31 81       	ldd	r19, Z+1	; 0x01
     748:	21 50       	subi	r18, 0x01	; 1
     74a:	31 09       	sbc	r19, r1
     74c:	fc 01       	movw	r30, r24
     74e:	31 83       	std	Z+1, r19	; 0x01
     750:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     752:	ce 01       	movw	r24, r28
     754:	81 5b       	subi	r24, 0xB1	; 177
     756:	9f 4f       	sbci	r25, 0xFF	; 255
     758:	fc 01       	movw	r30, r24
     75a:	80 81       	ld	r24, Z
     75c:	91 81       	ldd	r25, Z+1	; 0x01
     75e:	89 2b       	or	r24, r25
     760:	a1 f6       	brne	.-88     	; 0x70a <__stack+0x2ab>
     762:	2c c0       	rjmp	.+88     	; 0x7bc <__stack+0x35d>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     764:	8e 01       	movw	r16, r28
     766:	01 5b       	subi	r16, 0xB1	; 177
     768:	1f 4f       	sbci	r17, 0xFF	; 255
     76a:	ce 01       	movw	r24, r28
     76c:	85 5b       	subi	r24, 0xB5	; 181
     76e:	9f 4f       	sbci	r25, 0xFF	; 255
     770:	fc 01       	movw	r30, r24
     772:	60 81       	ld	r22, Z
     774:	71 81       	ldd	r23, Z+1	; 0x01
     776:	82 81       	ldd	r24, Z+2	; 0x02
     778:	93 81       	ldd	r25, Z+3	; 0x03
     77a:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     77e:	dc 01       	movw	r26, r24
     780:	cb 01       	movw	r24, r22
     782:	f8 01       	movw	r30, r16
     784:	91 83       	std	Z+1, r25	; 0x01
     786:	80 83       	st	Z, r24
     788:	ce 01       	movw	r24, r28
     78a:	8d 5a       	subi	r24, 0xAD	; 173
     78c:	9f 4f       	sbci	r25, 0xFF	; 255
     78e:	9e 01       	movw	r18, r28
     790:	21 5b       	subi	r18, 0xB1	; 177
     792:	3f 4f       	sbci	r19, 0xFF	; 255
     794:	f9 01       	movw	r30, r18
     796:	20 81       	ld	r18, Z
     798:	31 81       	ldd	r19, Z+1	; 0x01
     79a:	fc 01       	movw	r30, r24
     79c:	31 83       	std	Z+1, r19	; 0x01
     79e:	20 83       	st	Z, r18
     7a0:	ce 01       	movw	r24, r28
     7a2:	8d 5a       	subi	r24, 0xAD	; 173
     7a4:	9f 4f       	sbci	r25, 0xFF	; 255
     7a6:	fc 01       	movw	r30, r24
     7a8:	80 81       	ld	r24, Z
     7aa:	91 81       	ldd	r25, Z+1	; 0x01
     7ac:	01 97       	sbiw	r24, 0x01	; 1
     7ae:	f1 f7       	brne	.-4      	; 0x7ac <__stack+0x34d>
     7b0:	9e 01       	movw	r18, r28
     7b2:	2d 5a       	subi	r18, 0xAD	; 173
     7b4:	3f 4f       	sbci	r19, 0xFF	; 255
     7b6:	f9 01       	movw	r30, r18
     7b8:	91 83       	std	Z+1, r25	; 0x01
     7ba:	80 83       	st	Z, r24
        	_delay_ms(100);
    	EEPROM_writeString(0x0512,password_stored); /* overwrite on old password  in EEPROM*/
     7bc:	68 e0       	ldi	r22, 0x08	; 8
     7be:	71 e0       	ldi	r23, 0x01	; 1
     7c0:	82 e1       	ldi	r24, 0x12	; 18
     7c2:	95 e0       	ldi	r25, 0x05	; 5
     7c4:	0e 94 38 06 	call	0xc70	; 0xc70 <EEPROM_writeString>
     7c8:	80 e0       	ldi	r24, 0x00	; 0
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	a0 e2       	ldi	r26, 0x20	; 32
     7ce:	b1 e4       	ldi	r27, 0x41	; 65
     7d0:	8d 83       	std	Y+5, r24	; 0x05
     7d2:	9e 83       	std	Y+6, r25	; 0x06
     7d4:	af 83       	std	Y+7, r26	; 0x07
     7d6:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     7d8:	8e 01       	movw	r16, r28
     7da:	0f 5b       	subi	r16, 0xBF	; 191
     7dc:	1f 4f       	sbci	r17, 0xFF	; 255
     7de:	20 e0       	ldi	r18, 0x00	; 0
     7e0:	30 e0       	ldi	r19, 0x00	; 0
     7e2:	4a ef       	ldi	r20, 0xFA	; 250
     7e4:	54 e4       	ldi	r21, 0x44	; 68
     7e6:	6d 81       	ldd	r22, Y+5	; 0x05
     7e8:	7e 81       	ldd	r23, Y+6	; 0x06
     7ea:	8f 81       	ldd	r24, Y+7	; 0x07
     7ec:	98 85       	ldd	r25, Y+8	; 0x08
     7ee:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     7f2:	dc 01       	movw	r26, r24
     7f4:	cb 01       	movw	r24, r22
     7f6:	f8 01       	movw	r30, r16
     7f8:	80 83       	st	Z, r24
     7fa:	91 83       	std	Z+1, r25	; 0x01
     7fc:	a2 83       	std	Z+2, r26	; 0x02
     7fe:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     800:	ce 01       	movw	r24, r28
     802:	8f 5b       	subi	r24, 0xBF	; 191
     804:	9f 4f       	sbci	r25, 0xFF	; 255
     806:	20 e0       	ldi	r18, 0x00	; 0
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	40 e8       	ldi	r20, 0x80	; 128
     80c:	5f e3       	ldi	r21, 0x3F	; 63
     80e:	fc 01       	movw	r30, r24
     810:	60 81       	ld	r22, Z
     812:	71 81       	ldd	r23, Z+1	; 0x01
     814:	82 81       	ldd	r24, Z+2	; 0x02
     816:	93 81       	ldd	r25, Z+3	; 0x03
     818:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     81c:	88 23       	and	r24, r24
     81e:	4c f4       	brge	.+18     	; 0x832 <__stack+0x3d3>
		__ticks = 1;
     820:	ce 01       	movw	r24, r28
     822:	8b 5b       	subi	r24, 0xBB	; 187
     824:	9f 4f       	sbci	r25, 0xFF	; 255
     826:	21 e0       	ldi	r18, 0x01	; 1
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	fc 01       	movw	r30, r24
     82c:	31 83       	std	Z+1, r19	; 0x01
     82e:	20 83       	st	Z, r18
     830:	69 c0       	rjmp	.+210    	; 0x904 <__stack+0x4a5>
	else if (__tmp > 65535)
     832:	ce 01       	movw	r24, r28
     834:	8f 5b       	subi	r24, 0xBF	; 191
     836:	9f 4f       	sbci	r25, 0xFF	; 255
     838:	20 e0       	ldi	r18, 0x00	; 0
     83a:	3f ef       	ldi	r19, 0xFF	; 255
     83c:	4f e7       	ldi	r20, 0x7F	; 127
     83e:	57 e4       	ldi	r21, 0x47	; 71
     840:	fc 01       	movw	r30, r24
     842:	60 81       	ld	r22, Z
     844:	71 81       	ldd	r23, Z+1	; 0x01
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     84e:	18 16       	cp	r1, r24
     850:	0c f0       	brlt	.+2      	; 0x854 <__stack+0x3f5>
     852:	46 c0       	rjmp	.+140    	; 0x8e0 <__stack+0x481>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     854:	20 e0       	ldi	r18, 0x00	; 0
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	40 e2       	ldi	r20, 0x20	; 32
     85a:	51 e4       	ldi	r21, 0x41	; 65
     85c:	6d 81       	ldd	r22, Y+5	; 0x05
     85e:	7e 81       	ldd	r23, Y+6	; 0x06
     860:	8f 81       	ldd	r24, Y+7	; 0x07
     862:	98 85       	ldd	r25, Y+8	; 0x08
     864:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     868:	dc 01       	movw	r26, r24
     86a:	cb 01       	movw	r24, r22
     86c:	8e 01       	movw	r16, r28
     86e:	0b 5b       	subi	r16, 0xBB	; 187
     870:	1f 4f       	sbci	r17, 0xFF	; 255
     872:	bc 01       	movw	r22, r24
     874:	cd 01       	movw	r24, r26
     876:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     87a:	dc 01       	movw	r26, r24
     87c:	cb 01       	movw	r24, r22
     87e:	f8 01       	movw	r30, r16
     880:	91 83       	std	Z+1, r25	; 0x01
     882:	80 83       	st	Z, r24
     884:	24 c0       	rjmp	.+72     	; 0x8ce <__stack+0x46f>
     886:	ce 01       	movw	r24, r28
     888:	89 5b       	subi	r24, 0xB9	; 185
     88a:	9f 4f       	sbci	r25, 0xFF	; 255
     88c:	28 ec       	ldi	r18, 0xC8	; 200
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	fc 01       	movw	r30, r24
     892:	31 83       	std	Z+1, r19	; 0x01
     894:	20 83       	st	Z, r18
     896:	ce 01       	movw	r24, r28
     898:	89 5b       	subi	r24, 0xB9	; 185
     89a:	9f 4f       	sbci	r25, 0xFF	; 255
     89c:	fc 01       	movw	r30, r24
     89e:	80 81       	ld	r24, Z
     8a0:	91 81       	ldd	r25, Z+1	; 0x01
     8a2:	01 97       	sbiw	r24, 0x01	; 1
     8a4:	f1 f7       	brne	.-4      	; 0x8a2 <__stack+0x443>
     8a6:	9e 01       	movw	r18, r28
     8a8:	29 5b       	subi	r18, 0xB9	; 185
     8aa:	3f 4f       	sbci	r19, 0xFF	; 255
     8ac:	f9 01       	movw	r30, r18
     8ae:	91 83       	std	Z+1, r25	; 0x01
     8b0:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8b2:	ce 01       	movw	r24, r28
     8b4:	8b 5b       	subi	r24, 0xBB	; 187
     8b6:	9f 4f       	sbci	r25, 0xFF	; 255
     8b8:	9e 01       	movw	r18, r28
     8ba:	2b 5b       	subi	r18, 0xBB	; 187
     8bc:	3f 4f       	sbci	r19, 0xFF	; 255
     8be:	f9 01       	movw	r30, r18
     8c0:	20 81       	ld	r18, Z
     8c2:	31 81       	ldd	r19, Z+1	; 0x01
     8c4:	21 50       	subi	r18, 0x01	; 1
     8c6:	31 09       	sbc	r19, r1
     8c8:	fc 01       	movw	r30, r24
     8ca:	31 83       	std	Z+1, r19	; 0x01
     8cc:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8ce:	ce 01       	movw	r24, r28
     8d0:	8b 5b       	subi	r24, 0xBB	; 187
     8d2:	9f 4f       	sbci	r25, 0xFF	; 255
     8d4:	fc 01       	movw	r30, r24
     8d6:	80 81       	ld	r24, Z
     8d8:	91 81       	ldd	r25, Z+1	; 0x01
     8da:	89 2b       	or	r24, r25
     8dc:	a1 f6       	brne	.-88     	; 0x886 <__stack+0x427>
     8de:	2c c0       	rjmp	.+88     	; 0x938 <__stack+0x4d9>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8e0:	8e 01       	movw	r16, r28
     8e2:	0b 5b       	subi	r16, 0xBB	; 187
     8e4:	1f 4f       	sbci	r17, 0xFF	; 255
     8e6:	ce 01       	movw	r24, r28
     8e8:	8f 5b       	subi	r24, 0xBF	; 191
     8ea:	9f 4f       	sbci	r25, 0xFF	; 255
     8ec:	fc 01       	movw	r30, r24
     8ee:	60 81       	ld	r22, Z
     8f0:	71 81       	ldd	r23, Z+1	; 0x01
     8f2:	82 81       	ldd	r24, Z+2	; 0x02
     8f4:	93 81       	ldd	r25, Z+3	; 0x03
     8f6:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     8fa:	dc 01       	movw	r26, r24
     8fc:	cb 01       	movw	r24, r22
     8fe:	f8 01       	movw	r30, r16
     900:	91 83       	std	Z+1, r25	; 0x01
     902:	80 83       	st	Z, r24
     904:	ce 01       	movw	r24, r28
     906:	87 5b       	subi	r24, 0xB7	; 183
     908:	9f 4f       	sbci	r25, 0xFF	; 255
     90a:	9e 01       	movw	r18, r28
     90c:	2b 5b       	subi	r18, 0xBB	; 187
     90e:	3f 4f       	sbci	r19, 0xFF	; 255
     910:	f9 01       	movw	r30, r18
     912:	20 81       	ld	r18, Z
     914:	31 81       	ldd	r19, Z+1	; 0x01
     916:	fc 01       	movw	r30, r24
     918:	31 83       	std	Z+1, r19	; 0x01
     91a:	20 83       	st	Z, r18
     91c:	ce 01       	movw	r24, r28
     91e:	87 5b       	subi	r24, 0xB7	; 183
     920:	9f 4f       	sbci	r25, 0xFF	; 255
     922:	fc 01       	movw	r30, r24
     924:	80 81       	ld	r24, Z
     926:	91 81       	ldd	r25, Z+1	; 0x01
     928:	01 97       	sbiw	r24, 0x01	; 1
     92a:	f1 f7       	brne	.-4      	; 0x928 <__stack+0x4c9>
     92c:	9e 01       	movw	r18, r28
     92e:	27 5b       	subi	r18, 0xB7	; 183
     930:	3f 4f       	sbci	r19, 0xFF	; 255
     932:	f9 01       	movw	r30, r18
     934:	91 83       	std	Z+1, r25	; 0x01
     936:	80 83       	st	Z, r24
    	_delay_ms(10);
    	EEPROM_writeByte(0X0011,0xAA); /* write in password_stored_flag address in EEPROM */
     938:	6a ea       	ldi	r22, 0xAA	; 170
     93a:	81 e1       	ldi	r24, 0x11	; 17
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	0e 94 9c 05 	call	0xb38	; 0xb38 <EEPROM_writeByte>
    	password_stored_flag=0xAA;/*change password_stored_flag  in data segment in ram */
     942:	8a ea       	ldi	r24, 0xAA	; 170
     944:	80 93 fe 00 	sts	0x00FE, r24	; 0x8000fe <password_stored_flag>
    	set_password_now_flag=0xAA;  /* prevent the program from requesting from user reenter or reset password */
     948:	8a ea       	ldi	r24, 0xAA	; 170
     94a:	80 93 ff 00 	sts	0x00FF, r24	; 0x8000ff <set_password_now_flag>
    	if(UART_receiveByte()=='o') /* give user option to open the door */
     94e:	0e 94 11 10 	call	0x2022	; 0x2022 <UART_receiveByte>
     952:	8f 36       	cpi	r24, 0x6F	; 111
     954:	09 f0       	breq	.+2      	; 0x958 <__stack+0x4f9>
     956:	2d cc       	rjmp	.-1958   	; 0x1b2 <main+0x9e>
    		 motor_run();
     958:	0e 94 cd 04 	call	0x99a	; 0x99a <motor_run>

    	}

    }
     95c:	2a cc       	rjmp	.-1964   	; 0x1b2 <main+0x9e>

0000095e <timer_set>:
 *      Author: hesham
 */
#include"actuators.h"

void timer_set(void)
{
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
     962:	cd b7       	in	r28, 0x3d	; 61
     964:	de b7       	in	r29, 0x3e	; 62
timer_config.timerNumber=1;
     966:	81 e0       	ldi	r24, 0x01	; 1
     968:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <timer_config>
		strcpy(timer_config.mode,"compare");
     96c:	88 e0       	ldi	r24, 0x08	; 8
     96e:	e5 e7       	ldi	r30, 0x75	; 117
     970:	f0 e0       	ldi	r31, 0x00	; 0
     972:	ad e1       	ldi	r26, 0x1D	; 29
     974:	b1 e0       	ldi	r27, 0x01	; 1
     976:	01 90       	ld	r0, Z+
     978:	0d 92       	st	X+, r0
     97a:	8a 95       	dec	r24
     97c:	e1 f7       	brne	.-8      	; 0x976 <timer_set+0x18>
		timer_config.prescaler=1024;
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	94 e0       	ldi	r25, 0x04	; 4
     982:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <timer_config+0x16>
     986:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <timer_config+0x15>
		TIMER_init(&timer_config);
     98a:	8c e1       	ldi	r24, 0x1C	; 28
     98c:	91 e0       	ldi	r25, 0x01	; 1
     98e:	0e 94 84 09 	call	0x1308	; 0x1308 <TIMER_init>
}
     992:	00 00       	nop
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	08 95       	ret

0000099a <motor_run>:


void motor_run(void)
{
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	cd b7       	in	r28, 0x3d	; 61
     9a0:	de b7       	in	r29, 0x3e	; 62

TIMER_setCompare(8000);
     9a2:	80 e4       	ldi	r24, 0x40	; 64
     9a4:	9f e1       	ldi	r25, 0x1F	; 31
     9a6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <TIMER_setCompare>
TIMER_setCallBackPtr(change_motor_dirction);
     9aa:	8d ed       	ldi	r24, 0xDD	; 221
     9ac:	94 e0       	ldi	r25, 0x04	; 4
     9ae:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <TIMER_setCallBackPtr>


}
     9b2:	00 00       	nop
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <change_motor_dirction>:
void change_motor_dirction(void)
{
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	cd b7       	in	r28, 0x3d	; 61
     9c0:	de b7       	in	r29, 0x3e	; 62

	static uint8 count=0;
	if(count==0)
     9c2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <count.1911>
     9c6:	88 23       	and	r24, r24
     9c8:	29 f5       	brne	.+74     	; 0xa14 <change_motor_dirction+0x5a>
	{
		DDRB|=(1<<0)|(1<<1);
     9ca:	87 e3       	ldi	r24, 0x37	; 55
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	27 e3       	ldi	r18, 0x37	; 55
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	f9 01       	movw	r30, r18
     9d4:	20 81       	ld	r18, Z
     9d6:	23 60       	ori	r18, 0x03	; 3
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
		PORTB&=~(1<<0)&~(1<<1);
     9dc:	88 e3       	ldi	r24, 0x38	; 56
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	28 e3       	ldi	r18, 0x38	; 56
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	f9 01       	movw	r30, r18
     9e6:	20 81       	ld	r18, Z
     9e8:	2c 7f       	andi	r18, 0xFC	; 252
     9ea:	fc 01       	movw	r30, r24
     9ec:	20 83       	st	Z, r18
		CLEAR_BIT(PORTB,1);
     9ee:	88 e3       	ldi	r24, 0x38	; 56
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	28 e3       	ldi	r18, 0x38	; 56
     9f4:	30 e0       	ldi	r19, 0x00	; 0
     9f6:	f9 01       	movw	r30, r18
     9f8:	20 81       	ld	r18, Z
     9fa:	2d 7f       	andi	r18, 0xFD	; 253
     9fc:	fc 01       	movw	r30, r24
     9fe:	20 83       	st	Z, r18
		SET_BIT(PORTB,0);
     a00:	88 e3       	ldi	r24, 0x38	; 56
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	28 e3       	ldi	r18, 0x38	; 56
     a06:	30 e0       	ldi	r19, 0x00	; 0
     a08:	f9 01       	movw	r30, r18
     a0a:	20 81       	ld	r18, Z
     a0c:	21 60       	ori	r18, 0x01	; 1
     a0e:	fc 01       	movw	r30, r24
     a10:	20 83       	st	Z, r18
     a12:	24 c0       	rjmp	.+72     	; 0xa5c <change_motor_dirction+0xa2>
	}
	else if(count>=2)
     a14:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <count.1911>
     a18:	82 30       	cpi	r24, 0x02	; 2
     a1a:	60 f0       	brcs	.+24     	; 0xa34 <change_motor_dirction+0x7a>
{
	PORTB&=~(1<<0)&~(1<<1);
     a1c:	88 e3       	ldi	r24, 0x38	; 56
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	28 e3       	ldi	r18, 0x38	; 56
     a22:	30 e0       	ldi	r19, 0x00	; 0
     a24:	f9 01       	movw	r30, r18
     a26:	20 81       	ld	r18, Z
     a28:	2c 7f       	andi	r18, 0xFC	; 252
     a2a:	fc 01       	movw	r30, r24
     a2c:	20 83       	st	Z, r18

	TIMER_stop();
     a2e:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <TIMER_stop>
     a32:	14 c0       	rjmp	.+40     	; 0xa5c <change_motor_dirction+0xa2>
}
else
{
	TOGGLE_BIT(PORTB,1);
     a34:	88 e3       	ldi	r24, 0x38	; 56
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	28 e3       	ldi	r18, 0x38	; 56
     a3a:	30 e0       	ldi	r19, 0x00	; 0
     a3c:	f9 01       	movw	r30, r18
     a3e:	30 81       	ld	r19, Z
     a40:	22 e0       	ldi	r18, 0x02	; 2
     a42:	23 27       	eor	r18, r19
     a44:	fc 01       	movw	r30, r24
     a46:	20 83       	st	Z, r18
	TOGGLE_BIT(PORTB,0);
     a48:	88 e3       	ldi	r24, 0x38	; 56
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	28 e3       	ldi	r18, 0x38	; 56
     a4e:	30 e0       	ldi	r19, 0x00	; 0
     a50:	f9 01       	movw	r30, r18
     a52:	30 81       	ld	r19, Z
     a54:	21 e0       	ldi	r18, 0x01	; 1
     a56:	23 27       	eor	r18, r19
     a58:	fc 01       	movw	r30, r24
     a5a:	20 83       	st	Z, r18
}
	count++;
     a5c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <count.1911>
     a60:	8f 5f       	subi	r24, 0xFF	; 255
     a62:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <count.1911>

}
     a66:	00 00       	nop
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <buzzer>:
void buzzer(void)
{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	cd b7       	in	r28, 0x3d	; 61
     a74:	de b7       	in	r29, 0x3e	; 62

	TIMER_setCompare(60000);
     a76:	80 e6       	ldi	r24, 0x60	; 96
     a78:	9a ee       	ldi	r25, 0xEA	; 234
     a7a:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <TIMER_setCompare>
	TIMER_setCallBackPtr(buzzer_call);
     a7e:	87 e4       	ldi	r24, 0x47	; 71
     a80:	95 e0       	ldi	r25, 0x05	; 5
     a82:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <TIMER_setCallBackPtr>
}
     a86:	00 00       	nop
     a88:	df 91       	pop	r29
     a8a:	cf 91       	pop	r28
     a8c:	08 95       	ret

00000a8e <buzzer_call>:
void buzzer_call(void)
{	static uint8 count=0;
     a8e:	cf 93       	push	r28
     a90:	df 93       	push	r29
     a92:	cd b7       	in	r28, 0x3d	; 61
     a94:	de b7       	in	r29, 0x3e	; 62
if(count==0)
     a96:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <count.1918>
     a9a:	88 23       	and	r24, r24
     a9c:	99 f4       	brne	.+38     	; 0xac4 <buzzer_call+0x36>
{
	SET_BIT(DDRC,5);
     a9e:	84 e3       	ldi	r24, 0x34	; 52
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	24 e3       	ldi	r18, 0x34	; 52
     aa4:	30 e0       	ldi	r19, 0x00	; 0
     aa6:	f9 01       	movw	r30, r18
     aa8:	20 81       	ld	r18, Z
     aaa:	20 62       	ori	r18, 0x20	; 32
     aac:	fc 01       	movw	r30, r24
     aae:	20 83       	st	Z, r18
		SET_BIT(PORTC,5);
     ab0:	85 e3       	ldi	r24, 0x35	; 53
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	25 e3       	ldi	r18, 0x35	; 53
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	f9 01       	movw	r30, r18
     aba:	20 81       	ld	r18, Z
     abc:	20 62       	ori	r18, 0x20	; 32
     abe:	fc 01       	movw	r30, r24
     ac0:	20 83       	st	Z, r18
     ac2:	14 c0       	rjmp	.+40     	; 0xaec <buzzer_call+0x5e>
}


else if(count==8)
     ac4:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <count.1918>
     ac8:	88 30       	cpi	r24, 0x08	; 8
     aca:	81 f4       	brne	.+32     	; 0xaec <buzzer_call+0x5e>
{
	CLEAR_BIT(PORTC,5);
     acc:	85 e3       	ldi	r24, 0x35	; 53
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	25 e3       	ldi	r18, 0x35	; 53
     ad2:	30 e0       	ldi	r19, 0x00	; 0
     ad4:	f9 01       	movw	r30, r18
     ad6:	20 81       	ld	r18, Z
     ad8:	2f 7d       	andi	r18, 0xDF	; 223
     ada:	fc 01       	movw	r30, r24
     adc:	20 83       	st	Z, r18
	buzzer_flag=1;
     ade:	81 e0       	ldi	r24, 0x01	; 1
     ae0:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <buzzer_flag>
	block_buzzer_scope=0;
     ae4:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <block_buzzer_scope>
	TIMER_stop();
     ae8:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <TIMER_stop>
}
count++;
     aec:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <count.1918>
     af0:	8f 5f       	subi	r24, 0xFF	; 255
     af2:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <count.1918>


}
     af6:	00 00       	nop
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <EEPROM_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void EEPROM_init(void)
{ /* determine the parameter which will pass to I2C driver to communicate with EEPROM */
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	cd b7       	in	r28, 0x3d	; 61
     b04:	de b7       	in	r29, 0x3e	; 62
	TWI_config.baudRate=400000; /* baud rate which EEPROM work on */
     b06:	80 e8       	ldi	r24, 0x80	; 128
     b08:	9a e1       	ldi	r25, 0x1A	; 26
     b0a:	a6 e0       	ldi	r26, 0x06	; 6
     b0c:	b0 e0       	ldi	r27, 0x00	; 0
     b0e:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <TWI_config>
     b12:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <TWI_config+0x1>
     b16:	a0 93 60 01 	sts	0x0160, r26	; 0x800160 <TWI_config+0x2>
     b1a:	b0 93 61 01 	sts	0x0161, r27	; 0x800161 <TWI_config+0x3>
	TWI_config.prescasler=0;
     b1e:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <TWI_config+0x4>
	TWI_config.slave_address=0b00001011; /* the address of master when receive data from (as slave) form other slaves */
     b22:	8b e0       	ldi	r24, 0x0B	; 11
     b24:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <TWI_config+0x5>

	/* passing I2C configuration structure by reference to I2C initialization function */
TWI_init(&TWI_config);
     b28:	8e e5       	ldi	r24, 0x5E	; 94
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	0e 94 3b 07 	call	0xe76	; 0xe76 <TWI_init>
}
     b30:	00 00       	nop
     b32:	df 91       	pop	r29
     b34:	cf 91       	pop	r28
     b36:	08 95       	ret

00000b38 <EEPROM_writeByte>:

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	00 d0       	rcall	.+0      	; 0xb3e <EEPROM_writeByte+0x6>
     b3e:	1f 92       	push	r1
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
     b44:	9a 83       	std	Y+2, r25	; 0x02
     b46:	89 83       	std	Y+1, r24	; 0x01
     b48:	6b 83       	std	Y+3, r22	; 0x03
/* send start bit */
	TWI_start();
     b4a:	0e 94 c3 07 	call	0xf86	; 0xf86 <TWI_start>
	if(TWI_getStatus()!=TW_START) /* check the start done */
     b4e:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     b52:	88 30       	cpi	r24, 0x08	; 8
     b54:	11 f0       	breq	.+4      	; 0xb5a <EEPROM_writeByte+0x22>
	return ERROR; /* return error if doenst send start bit */
     b56:	80 e0       	ldi	r24, 0x00	; 0
     b58:	27 c0       	rjmp	.+78     	; 0xba8 <EEPROM_writeByte+0x70>

	/* to avoid sending 3 bytes 1  byte for EEPROM address  and 2 bytes  for memory location address
	 * combine address of EEPROM address (in our case 24c16 EEPROM----->>0XA0 ) and last 3 bits of memory location address
	 * memory location address for 24c16 EEPROM is 11 bits as memory size 2kByte and the memory width is 1 K byte
	 */
	TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     b5a:	89 81       	ldd	r24, Y+1	; 0x01
     b5c:	9a 81       	ldd	r25, Y+2	; 0x02
     b5e:	88 27       	eor	r24, r24
     b60:	97 70       	andi	r25, 0x07	; 7
     b62:	88 0f       	add	r24, r24
     b64:	89 2f       	mov	r24, r25
     b66:	88 1f       	adc	r24, r24
     b68:	99 0b       	sbc	r25, r25
     b6a:	91 95       	neg	r25
     b6c:	80 6a       	ori	r24, 0xA0	; 160
     b6e:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
	if(TWI_getStatus()!=TW_MT_SLA_W_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b72:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     b76:	88 31       	cpi	r24, 0x18	; 24
     b78:	11 f0       	breq	.+4      	; 0xb7e <EEPROM_writeByte+0x46>
		return ERROR;
     b7a:	80 e0       	ldi	r24, 0x00	; 0
     b7c:	15 c0       	rjmp	.+42     	; 0xba8 <EEPROM_writeByte+0x70>

/* send the remaining of memory location address =11-3=8 bits */
	TWI_write((uint8)u16addr);
     b7e:	89 81       	ldd	r24, Y+1	; 0x01
     b80:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) DATA (DATA) acknowledge (ACK) */
     b84:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     b88:	88 32       	cpi	r24, 0x28	; 40
     b8a:	11 f0       	breq	.+4      	; 0xb90 <EEPROM_writeByte+0x58>
			return ERROR;
     b8c:	80 e0       	ldi	r24, 0x00	; 0
     b8e:	0c c0       	rjmp	.+24     	; 0xba8 <EEPROM_writeByte+0x70>


	TWI_write(u8data);
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b96:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     b9a:	88 32       	cpi	r24, 0x28	; 40
     b9c:	11 f0       	breq	.+4      	; 0xba2 <EEPROM_writeByte+0x6a>
			return ERROR;
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	03 c0       	rjmp	.+6      	; 0xba8 <EEPROM_writeByte+0x70>

	TWI_stop(); /* end the frame */
     ba2:	0e 94 d7 07 	call	0xfae	; 0xfae <TWI_stop>
	return SUCCESS; /* send success if the frame is completed by reach this line */
     ba6:	81 e0       	ldi	r24, 0x01	; 1
}
     ba8:	0f 90       	pop	r0
     baa:	0f 90       	pop	r0
     bac:	0f 90       	pop	r0
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
     bb4:	cf 93       	push	r28
     bb6:	df 93       	push	r29
     bb8:	00 d0       	rcall	.+0      	; 0xbba <EEPROM_readByte+0x6>
     bba:	00 d0       	rcall	.+0      	; 0xbbc <EEPROM_readByte+0x8>
     bbc:	cd b7       	in	r28, 0x3d	; 61
     bbe:	de b7       	in	r29, 0x3e	; 62
     bc0:	9a 83       	std	Y+2, r25	; 0x02
     bc2:	89 83       	std	Y+1, r24	; 0x01
     bc4:	7c 83       	std	Y+4, r23	; 0x04
     bc6:	6b 83       	std	Y+3, r22	; 0x03
	TWI_start();
     bc8:	0e 94 c3 07 	call	0xf86	; 0xf86 <TWI_start>
		if(TWI_getStatus()!=TW_START)
     bcc:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     bd0:	88 30       	cpi	r24, 0x08	; 8
     bd2:	11 f0       	breq	.+4      	; 0xbd8 <EEPROM_readByte+0x24>
		return ERROR;
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	45 c0       	rjmp	.+138    	; 0xc62 <EEPROM_readByte+0xae>

		TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     bd8:	89 81       	ldd	r24, Y+1	; 0x01
     bda:	9a 81       	ldd	r25, Y+2	; 0x02
     bdc:	88 27       	eor	r24, r24
     bde:	97 70       	andi	r25, 0x07	; 7
     be0:	88 0f       	add	r24, r24
     be2:	89 2f       	mov	r24, r25
     be4:	88 1f       	adc	r24, r24
     be6:	99 0b       	sbc	r25, r25
     be8:	91 95       	neg	r25
     bea:	80 6a       	ori	r24, 0xA0	; 160
     bec:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_W_ACK)
     bf0:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     bf4:	88 31       	cpi	r24, 0x18	; 24
     bf6:	11 f0       	breq	.+4      	; 0xbfc <EEPROM_readByte+0x48>
			return ERROR;
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	33 c0       	rjmp	.+102    	; 0xc62 <EEPROM_readByte+0xae>


		TWI_write((uint8)u16addr);
     bfc:	89 81       	ldd	r24, Y+1	; 0x01
     bfe:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
		if(TWI_getStatus()!=TW_MT_DATA_ACK)
     c02:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     c06:	88 32       	cpi	r24, 0x28	; 40
     c08:	11 f0       	breq	.+4      	; 0xc0e <EEPROM_readByte+0x5a>
				return ERROR;
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	2a c0       	rjmp	.+84     	; 0xc62 <EEPROM_readByte+0xae>

/* repeat start the frame as in this case master will read from the slave */
				TWI_start();
     c0e:	0e 94 c3 07 	call	0xf86	; 0xf86 <TWI_start>
		if(TWI_getStatus()!=TW_REP_START) /* check the repeated start done */
     c12:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     c16:	80 31       	cpi	r24, 0x10	; 16
     c18:	11 f0       	breq	.+4      	; 0xc1e <EEPROM_readByte+0x6a>
						return ERROR;
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	22 c0       	rjmp	.+68     	; 0xc62 <EEPROM_readByte+0xae>
/* send the address of EEPROM as slave and set the less significant bit to make master read from the slave */
		TWI_write((uint8)((0xA0)|((u16addr&0X0700)>>7)|1));
     c1e:	89 81       	ldd	r24, Y+1	; 0x01
     c20:	9a 81       	ldd	r25, Y+2	; 0x02
     c22:	88 27       	eor	r24, r24
     c24:	97 70       	andi	r25, 0x07	; 7
     c26:	88 0f       	add	r24, r24
     c28:	89 2f       	mov	r24, r25
     c2a:	88 1f       	adc	r24, r24
     c2c:	99 0b       	sbc	r25, r25
     c2e:	91 95       	neg	r25
     c30:	81 6a       	ori	r24, 0xA1	; 161
     c32:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_R_ACK)  /* check the master (MT) send  to slave (SLA) read (R) acknowledge (ACK) */
     c36:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     c3a:	80 34       	cpi	r24, 0x40	; 64
     c3c:	11 f0       	breq	.+4      	; 0xc42 <EEPROM_readByte+0x8e>
						return ERROR;
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	10 c0       	rjmp	.+32     	; 0xc62 <EEPROM_readByte+0xae>


			*u8data=TWI_read_with_NACK(); /* read the byte */
     c42:	0e 94 17 08 	call	0x102e	; 0x102e <TWI_read_with_NACK>
     c46:	28 2f       	mov	r18, r24
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	fc 01       	movw	r30, r24
     c4e:	20 83       	st	Z, r18
			if(TWI_getStatus()!=TW_MR_DATA_NACK) /* check the master (MT) read the byte  from slave (SLA) read (DATA) acknowledge (ACK) */
     c50:	0e 94 2e 08 	call	0x105c	; 0x105c <TWI_getStatus>
     c54:	88 35       	cpi	r24, 0x58	; 88
     c56:	11 f0       	breq	.+4      	; 0xc5c <EEPROM_readByte+0xa8>
					return ERROR;
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	03 c0       	rjmp	.+6      	; 0xc62 <EEPROM_readByte+0xae>

			TWI_stop();
     c5c:	0e 94 d7 07 	call	0xfae	; 0xfae <TWI_stop>
			return SUCCESS;
     c60:	81 e0       	ldi	r24, 0x01	; 1

}
     c62:	0f 90       	pop	r0
     c64:	0f 90       	pop	r0
     c66:	0f 90       	pop	r0
     c68:	0f 90       	pop	r0
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	08 95       	ret

00000c70 <EEPROM_writeString>:
uint8 EEPROM_writeString(uint16 u16addr, uint8* str)
{
     c70:	cf 93       	push	r28
     c72:	df 93       	push	r29
     c74:	cd b7       	in	r28, 0x3d	; 61
     c76:	de b7       	in	r29, 0x3e	; 62
     c78:	63 97       	sbiw	r28, 0x13	; 19
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	f8 94       	cli
     c7e:	de bf       	out	0x3e, r29	; 62
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	cd bf       	out	0x3d, r28	; 61
     c84:	99 8b       	std	Y+17, r25	; 0x11
     c86:	88 8b       	std	Y+16, r24	; 0x10
     c88:	7b 8b       	std	Y+19, r23	; 0x13
     c8a:	6a 8b       	std	Y+18, r22	; 0x12
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
     c8c:	19 82       	std	Y+1, r1	; 0x01
	for( i=0;str[i]!='\0';i++)
     c8e:	19 82       	std	Y+1, r1	; 0x01
     c90:	88 c0       	rjmp	.+272    	; 0xda2 <EEPROM_writeString+0x132>
{

/* increase the address by base +i */
	EEPROM_writeByte(u16addr+i,str[i]);
     c92:	89 81       	ldd	r24, Y+1	; 0x01
     c94:	88 2f       	mov	r24, r24
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	2a 89       	ldd	r18, Y+18	; 0x12
     c9a:	3b 89       	ldd	r19, Y+19	; 0x13
     c9c:	82 0f       	add	r24, r18
     c9e:	93 1f       	adc	r25, r19
     ca0:	fc 01       	movw	r30, r24
     ca2:	40 81       	ld	r20, Z
     ca4:	89 81       	ldd	r24, Y+1	; 0x01
     ca6:	28 2f       	mov	r18, r24
     ca8:	30 e0       	ldi	r19, 0x00	; 0
     caa:	88 89       	ldd	r24, Y+16	; 0x10
     cac:	99 89       	ldd	r25, Y+17	; 0x11
     cae:	82 0f       	add	r24, r18
     cb0:	93 1f       	adc	r25, r19
     cb2:	64 2f       	mov	r22, r20
     cb4:	0e 94 9c 05 	call	0xb38	; 0xb38 <EEPROM_writeByte>
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	a0 e2       	ldi	r26, 0x20	; 32
     cbe:	b1 e4       	ldi	r27, 0x41	; 65
     cc0:	8a 83       	std	Y+2, r24	; 0x02
     cc2:	9b 83       	std	Y+3, r25	; 0x03
     cc4:	ac 83       	std	Y+4, r26	; 0x04
     cc6:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     cc8:	20 e0       	ldi	r18, 0x00	; 0
     cca:	30 e0       	ldi	r19, 0x00	; 0
     ccc:	4a ef       	ldi	r20, 0xFA	; 250
     cce:	54 e4       	ldi	r21, 0x44	; 68
     cd0:	6a 81       	ldd	r22, Y+2	; 0x02
     cd2:	7b 81       	ldd	r23, Y+3	; 0x03
     cd4:	8c 81       	ldd	r24, Y+4	; 0x04
     cd6:	9d 81       	ldd	r25, Y+5	; 0x05
     cd8:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     cdc:	dc 01       	movw	r26, r24
     cde:	cb 01       	movw	r24, r22
     ce0:	8e 83       	std	Y+6, r24	; 0x06
     ce2:	9f 83       	std	Y+7, r25	; 0x07
     ce4:	a8 87       	std	Y+8, r26	; 0x08
     ce6:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	40 e8       	ldi	r20, 0x80	; 128
     cee:	5f e3       	ldi	r21, 0x3F	; 63
     cf0:	6e 81       	ldd	r22, Y+6	; 0x06
     cf2:	7f 81       	ldd	r23, Y+7	; 0x07
     cf4:	88 85       	ldd	r24, Y+8	; 0x08
     cf6:	99 85       	ldd	r25, Y+9	; 0x09
     cf8:	0e 94 47 11 	call	0x228e	; 0x228e <__cmpsf2>
     cfc:	88 23       	and	r24, r24
     cfe:	2c f4       	brge	.+10     	; 0xd0a <EEPROM_writeString+0x9a>
		__ticks = 1;
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	9b 87       	std	Y+11, r25	; 0x0b
     d06:	8a 87       	std	Y+10, r24	; 0x0a
     d08:	3f c0       	rjmp	.+126    	; 0xd88 <EEPROM_writeString+0x118>
	else if (__tmp > 65535)
     d0a:	20 e0       	ldi	r18, 0x00	; 0
     d0c:	3f ef       	ldi	r19, 0xFF	; 255
     d0e:	4f e7       	ldi	r20, 0x7F	; 127
     d10:	57 e4       	ldi	r21, 0x47	; 71
     d12:	6e 81       	ldd	r22, Y+6	; 0x06
     d14:	7f 81       	ldd	r23, Y+7	; 0x07
     d16:	88 85       	ldd	r24, Y+8	; 0x08
     d18:	99 85       	ldd	r25, Y+9	; 0x09
     d1a:	0e 94 9f 12 	call	0x253e	; 0x253e <__gesf2>
     d1e:	18 16       	cp	r1, r24
     d20:	4c f5       	brge	.+82     	; 0xd74 <EEPROM_writeString+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d22:	20 e0       	ldi	r18, 0x00	; 0
     d24:	30 e0       	ldi	r19, 0x00	; 0
     d26:	40 e2       	ldi	r20, 0x20	; 32
     d28:	51 e4       	ldi	r21, 0x41	; 65
     d2a:	6a 81       	ldd	r22, Y+2	; 0x02
     d2c:	7b 81       	ldd	r23, Y+3	; 0x03
     d2e:	8c 81       	ldd	r24, Y+4	; 0x04
     d30:	9d 81       	ldd	r25, Y+5	; 0x05
     d32:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
     d36:	dc 01       	movw	r26, r24
     d38:	cb 01       	movw	r24, r22
     d3a:	bc 01       	movw	r22, r24
     d3c:	cd 01       	movw	r24, r26
     d3e:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     d42:	dc 01       	movw	r26, r24
     d44:	cb 01       	movw	r24, r22
     d46:	9b 87       	std	Y+11, r25	; 0x0b
     d48:	8a 87       	std	Y+10, r24	; 0x0a
     d4a:	0f c0       	rjmp	.+30     	; 0xd6a <EEPROM_writeString+0xfa>
     d4c:	88 ec       	ldi	r24, 0xC8	; 200
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	9d 87       	std	Y+13, r25	; 0x0d
     d52:	8c 87       	std	Y+12, r24	; 0x0c
     d54:	8c 85       	ldd	r24, Y+12	; 0x0c
     d56:	9d 85       	ldd	r25, Y+13	; 0x0d
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	f1 f7       	brne	.-4      	; 0xd58 <EEPROM_writeString+0xe8>
     d5c:	9d 87       	std	Y+13, r25	; 0x0d
     d5e:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d60:	8a 85       	ldd	r24, Y+10	; 0x0a
     d62:	9b 85       	ldd	r25, Y+11	; 0x0b
     d64:	01 97       	sbiw	r24, 0x01	; 1
     d66:	9b 87       	std	Y+11, r25	; 0x0b
     d68:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d6a:	8a 85       	ldd	r24, Y+10	; 0x0a
     d6c:	9b 85       	ldd	r25, Y+11	; 0x0b
     d6e:	89 2b       	or	r24, r25
     d70:	69 f7       	brne	.-38     	; 0xd4c <EEPROM_writeString+0xdc>
     d72:	14 c0       	rjmp	.+40     	; 0xd9c <EEPROM_writeString+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d74:	6e 81       	ldd	r22, Y+6	; 0x06
     d76:	7f 81       	ldd	r23, Y+7	; 0x07
     d78:	88 85       	ldd	r24, Y+8	; 0x08
     d7a:	99 85       	ldd	r25, Y+9	; 0x09
     d7c:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     d80:	dc 01       	movw	r26, r24
     d82:	cb 01       	movw	r24, r22
     d84:	9b 87       	std	Y+11, r25	; 0x0b
     d86:	8a 87       	std	Y+10, r24	; 0x0a
     d88:	8a 85       	ldd	r24, Y+10	; 0x0a
     d8a:	9b 85       	ldd	r25, Y+11	; 0x0b
     d8c:	9f 87       	std	Y+15, r25	; 0x0f
     d8e:	8e 87       	std	Y+14, r24	; 0x0e
     d90:	8e 85       	ldd	r24, Y+14	; 0x0e
     d92:	9f 85       	ldd	r25, Y+15	; 0x0f
     d94:	01 97       	sbiw	r24, 0x01	; 1
     d96:	f1 f7       	brne	.-4      	; 0xd94 <EEPROM_writeString+0x124>
     d98:	9f 87       	std	Y+15, r25	; 0x0f
     d9a:	8e 87       	std	Y+14, r24	; 0x0e
{
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
	for( i=0;str[i]!='\0';i++)
     d9c:	89 81       	ldd	r24, Y+1	; 0x01
     d9e:	8f 5f       	subi	r24, 0xFF	; 255
     da0:	89 83       	std	Y+1, r24	; 0x01
     da2:	89 81       	ldd	r24, Y+1	; 0x01
     da4:	88 2f       	mov	r24, r24
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	2a 89       	ldd	r18, Y+18	; 0x12
     daa:	3b 89       	ldd	r19, Y+19	; 0x13
     dac:	82 0f       	add	r24, r18
     dae:	93 1f       	adc	r25, r19
     db0:	fc 01       	movw	r30, r24
     db2:	80 81       	ld	r24, Z
     db4:	88 23       	and	r24, r24
     db6:	09 f0       	breq	.+2      	; 0xdba <EEPROM_writeString+0x14a>
     db8:	6c cf       	rjmp	.-296    	; 0xc92 <EEPROM_writeString+0x22>
	EEPROM_writeByte(u16addr+i,str[i]);
	_delay_ms(10);

}

	EEPROM_writeByte(u16addr+i,'\0');
     dba:	89 81       	ldd	r24, Y+1	; 0x01
     dbc:	28 2f       	mov	r18, r24
     dbe:	30 e0       	ldi	r19, 0x00	; 0
     dc0:	88 89       	ldd	r24, Y+16	; 0x10
     dc2:	99 89       	ldd	r25, Y+17	; 0x11
     dc4:	82 0f       	add	r24, r18
     dc6:	93 1f       	adc	r25, r19
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	0e 94 9c 05 	call	0xb38	; 0xb38 <EEPROM_writeByte>


}
     dce:	00 00       	nop
     dd0:	63 96       	adiw	r28, 0x13	; 19
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	0f be       	out	0x3f, r0	; 63
     dda:	cd bf       	out	0x3d, r28	; 61
     ddc:	df 91       	pop	r29
     dde:	cf 91       	pop	r28
     de0:	08 95       	ret

00000de2 <EEPROM_readString>:
uint8 EEPROM_readString(uint16 u16addr, uint8 *str)
{
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	00 d0       	rcall	.+0      	; 0xde8 <EEPROM_readString+0x6>
     de8:	00 d0       	rcall	.+0      	; 0xdea <EEPROM_readString+0x8>
     dea:	1f 92       	push	r1
     dec:	cd b7       	in	r28, 0x3d	; 61
     dee:	de b7       	in	r29, 0x3e	; 62
     df0:	9b 83       	std	Y+3, r25	; 0x03
     df2:	8a 83       	std	Y+2, r24	; 0x02
     df4:	7d 83       	std	Y+5, r23	; 0x05
     df6:	6c 83       	std	Y+4, r22	; 0x04
	then enter the while loop  and receive byte by byte  until reach null
	put null '\0' at the end of string
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
     df8:	19 82       	std	Y+1, r1	; 0x01
		EEPROM_readByte(u16addr, &str[i]);
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	88 2f       	mov	r24, r24
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	2c 81       	ldd	r18, Y+4	; 0x04
     e02:	3d 81       	ldd	r19, Y+5	; 0x05
     e04:	28 0f       	add	r18, r24
     e06:	39 1f       	adc	r19, r25
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	9b 81       	ldd	r25, Y+3	; 0x03
     e0c:	b9 01       	movw	r22, r18
     e0e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <EEPROM_readByte>
		while(str[i]!='\0')
     e12:	14 c0       	rjmp	.+40     	; 0xe3c <EEPROM_readString+0x5a>
		{u16addr++;
     e14:	8a 81       	ldd	r24, Y+2	; 0x02
     e16:	9b 81       	ldd	r25, Y+3	; 0x03
     e18:	01 96       	adiw	r24, 0x01	; 1
     e1a:	9b 83       	std	Y+3, r25	; 0x03
     e1c:	8a 83       	std	Y+2, r24	; 0x02
			i++;
     e1e:	89 81       	ldd	r24, Y+1	; 0x01
     e20:	8f 5f       	subi	r24, 0xFF	; 255
     e22:	89 83       	std	Y+1, r24	; 0x01
			EEPROM_readByte(u16addr, &str[i]);
     e24:	89 81       	ldd	r24, Y+1	; 0x01
     e26:	88 2f       	mov	r24, r24
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	2c 81       	ldd	r18, Y+4	; 0x04
     e2c:	3d 81       	ldd	r19, Y+5	; 0x05
     e2e:	28 0f       	add	r18, r24
     e30:	39 1f       	adc	r19, r25
     e32:	8a 81       	ldd	r24, Y+2	; 0x02
     e34:	9b 81       	ldd	r25, Y+3	; 0x03
     e36:	b9 01       	movw	r22, r18
     e38:	0e 94 da 05 	call	0xbb4	; 0xbb4 <EEPROM_readByte>
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
		EEPROM_readByte(u16addr, &str[i]);
		while(str[i]!='\0')
     e3c:	89 81       	ldd	r24, Y+1	; 0x01
     e3e:	88 2f       	mov	r24, r24
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	2c 81       	ldd	r18, Y+4	; 0x04
     e44:	3d 81       	ldd	r19, Y+5	; 0x05
     e46:	82 0f       	add	r24, r18
     e48:	93 1f       	adc	r25, r19
     e4a:	fc 01       	movw	r30, r24
     e4c:	80 81       	ld	r24, Z
     e4e:	88 23       	and	r24, r24
     e50:	09 f7       	brne	.-62     	; 0xe14 <EEPROM_readString+0x32>
		{u16addr++;
			i++;
			EEPROM_readByte(u16addr, &str[i]);
		}
		str[i]='\0';
     e52:	89 81       	ldd	r24, Y+1	; 0x01
     e54:	88 2f       	mov	r24, r24
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	2c 81       	ldd	r18, Y+4	; 0x04
     e5a:	3d 81       	ldd	r19, Y+5	; 0x05
     e5c:	82 0f       	add	r24, r18
     e5e:	93 1f       	adc	r25, r19
     e60:	fc 01       	movw	r30, r24
     e62:	10 82       	st	Z, r1

}
     e64:	00 00       	nop
     e66:	0f 90       	pop	r0
     e68:	0f 90       	pop	r0
     e6a:	0f 90       	pop	r0
     e6c:	0f 90       	pop	r0
     e6e:	0f 90       	pop	r0
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	08 95       	ret

00000e76 <TWI_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void TWI_init(const TWI_configurationType *config)
{
     e76:	cf 92       	push	r12
     e78:	df 92       	push	r13
     e7a:	ef 92       	push	r14
     e7c:	ff 92       	push	r15
     e7e:	0f 93       	push	r16
     e80:	1f 93       	push	r17
     e82:	cf 93       	push	r28
     e84:	df 93       	push	r29
     e86:	00 d0       	rcall	.+0      	; 0xe88 <TWI_init+0x12>
     e88:	cd b7       	in	r28, 0x3d	; 61
     e8a:	de b7       	in	r29, 0x3e	; 62
     e8c:	9a 83       	std	Y+2, r25	; 0x02
     e8e:	89 83       	std	Y+1, r24	; 0x01
	/* the equation is SCL frequency = CPU clock frequency /(16+2(TWBR)*4^prescaler */
	TWBR=((float)F_CPU/config->baudRate +16)/(2*pow(4,config->prescasler));
     e90:	00 e2       	ldi	r16, 0x20	; 32
     e92:	10 e0       	ldi	r17, 0x00	; 0
     e94:	89 81       	ldd	r24, Y+1	; 0x01
     e96:	9a 81       	ldd	r25, Y+2	; 0x02
     e98:	fc 01       	movw	r30, r24
     e9a:	80 81       	ld	r24, Z
     e9c:	91 81       	ldd	r25, Z+1	; 0x01
     e9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ea0:	b3 81       	ldd	r27, Z+3	; 0x03
     ea2:	bc 01       	movw	r22, r24
     ea4:	cd 01       	movw	r24, r26
     ea6:	0e 94 ed 11 	call	0x23da	; 0x23da <__floatunsisf>
     eaa:	dc 01       	movw	r26, r24
     eac:	cb 01       	movw	r24, r22
     eae:	9c 01       	movw	r18, r24
     eb0:	ad 01       	movw	r20, r26
     eb2:	60 e0       	ldi	r22, 0x00	; 0
     eb4:	74 e2       	ldi	r23, 0x24	; 36
     eb6:	84 ef       	ldi	r24, 0xF4	; 244
     eb8:	9a e4       	ldi	r25, 0x4A	; 74
     eba:	0e 94 4c 11 	call	0x2298	; 0x2298 <__divsf3>
     ebe:	dc 01       	movw	r26, r24
     ec0:	cb 01       	movw	r24, r22
     ec2:	20 e0       	ldi	r18, 0x00	; 0
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	40 e8       	ldi	r20, 0x80	; 128
     ec8:	51 e4       	ldi	r21, 0x41	; 65
     eca:	bc 01       	movw	r22, r24
     ecc:	cd 01       	movw	r24, r26
     ece:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__addsf3>
     ed2:	dc 01       	movw	r26, r24
     ed4:	cb 01       	movw	r24, r22
     ed6:	6c 01       	movw	r12, r24
     ed8:	7d 01       	movw	r14, r26
     eda:	89 81       	ldd	r24, Y+1	; 0x01
     edc:	9a 81       	ldd	r25, Y+2	; 0x02
     ede:	fc 01       	movw	r30, r24
     ee0:	84 81       	ldd	r24, Z+4	; 0x04
     ee2:	88 2f       	mov	r24, r24
     ee4:	90 e0       	ldi	r25, 0x00	; 0
     ee6:	a0 e0       	ldi	r26, 0x00	; 0
     ee8:	b0 e0       	ldi	r27, 0x00	; 0
     eea:	bc 01       	movw	r22, r24
     eec:	cd 01       	movw	r24, r26
     eee:	0e 94 ed 11 	call	0x23da	; 0x23da <__floatunsisf>
     ef2:	dc 01       	movw	r26, r24
     ef4:	cb 01       	movw	r24, r22
     ef6:	9c 01       	movw	r18, r24
     ef8:	ad 01       	movw	r20, r26
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	70 e0       	ldi	r23, 0x00	; 0
     efe:	80 e8       	ldi	r24, 0x80	; 128
     f00:	90 e4       	ldi	r25, 0x40	; 64
     f02:	0e 94 11 13 	call	0x2622	; 0x2622 <pow>
     f06:	dc 01       	movw	r26, r24
     f08:	cb 01       	movw	r24, r22
     f0a:	9c 01       	movw	r18, r24
     f0c:	ad 01       	movw	r20, r26
     f0e:	bc 01       	movw	r22, r24
     f10:	cd 01       	movw	r24, r26
     f12:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__addsf3>
     f16:	dc 01       	movw	r26, r24
     f18:	cb 01       	movw	r24, r22
     f1a:	9c 01       	movw	r18, r24
     f1c:	ad 01       	movw	r20, r26
     f1e:	c7 01       	movw	r24, r14
     f20:	b6 01       	movw	r22, r12
     f22:	0e 94 4c 11 	call	0x2298	; 0x2298 <__divsf3>
     f26:	dc 01       	movw	r26, r24
     f28:	cb 01       	movw	r24, r22
     f2a:	bc 01       	movw	r22, r24
     f2c:	cd 01       	movw	r24, r26
     f2e:	0e 94 be 11 	call	0x237c	; 0x237c <__fixunssfsi>
     f32:	dc 01       	movw	r26, r24
     f34:	cb 01       	movw	r24, r22
     f36:	f8 01       	movw	r30, r16
     f38:	80 83       	st	Z, r24
	 	TWSR=config->prescasler;/*store prescaler  in first 2 bits (TWPS1 and TWPS0) as other bits read only*/
     f3a:	81 e2       	ldi	r24, 0x21	; 33
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	29 81       	ldd	r18, Y+1	; 0x01
     f40:	3a 81       	ldd	r19, Y+2	; 0x02
     f42:	f9 01       	movw	r30, r18
     f44:	24 81       	ldd	r18, Z+4	; 0x04
     f46:	fc 01       	movw	r30, r24
     f48:	20 83       	st	Z, r18
	 TWAR=config->slave_address<<1;/* store slave address (7bits) in the most 7 significant bits
     f4a:	82 e2       	ldi	r24, 0x22	; 34
     f4c:	90 e0       	ldi	r25, 0x00	; 0
     f4e:	29 81       	ldd	r18, Y+1	; 0x01
     f50:	3a 81       	ldd	r19, Y+2	; 0x02
     f52:	f9 01       	movw	r30, r18
     f54:	25 81       	ldd	r18, Z+5	; 0x05
     f56:	22 0f       	add	r18, r18
     f58:	fc 01       	movw	r30, r24
     f5a:	20 83       	st	Z, r18
	  the address of master when receive data from (as slave) form other slaves */
	TWCR|=(1<<TWEN);/* enable TWI module */
     f5c:	86 e5       	ldi	r24, 0x56	; 86
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	26 e5       	ldi	r18, 0x56	; 86
     f62:	30 e0       	ldi	r19, 0x00	; 0
     f64:	f9 01       	movw	r30, r18
     f66:	20 81       	ld	r18, Z
     f68:	24 60       	ori	r18, 0x04	; 4
     f6a:	fc 01       	movw	r30, r24
     f6c:	20 83       	st	Z, r18

}
     f6e:	00 00       	nop
     f70:	0f 90       	pop	r0
     f72:	0f 90       	pop	r0
     f74:	df 91       	pop	r29
     f76:	cf 91       	pop	r28
     f78:	1f 91       	pop	r17
     f7a:	0f 91       	pop	r16
     f7c:	ff 90       	pop	r15
     f7e:	ef 90       	pop	r14
     f80:	df 90       	pop	r13
     f82:	cf 90       	pop	r12
     f84:	08 95       	ret

00000f86 <TWI_start>:
void TWI_start(void)
{
     f86:	cf 93       	push	r28
     f88:	df 93       	push	r29
     f8a:	cd b7       	in	r28, 0x3d	; 61
     f8c:	de b7       	in	r29, 0x3e	; 62
	//make enable again to force other bits in the register to be zero
	//start bit TWSTA and clear finish current job flag TWINT by toggle it
TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     f8e:	86 e5       	ldi	r24, 0x56	; 86
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	24 ea       	ldi	r18, 0xA4	; 164
     f94:	fc 01       	movw	r30, r24
     f96:	20 83       	st	Z, r18
while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     f98:	00 00       	nop
     f9a:	86 e5       	ldi	r24, 0x56	; 86
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	fc 01       	movw	r30, r24
     fa0:	80 81       	ld	r24, Z
     fa2:	88 23       	and	r24, r24
     fa4:	d4 f7       	brge	.-12     	; 0xf9a <TWI_start+0x14>
}
     fa6:	00 00       	nop
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret

00000fae <TWI_stop>:
void TWI_stop(void)
{/*make enable again to force other bits in the register to be zero
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	cd b7       	in	r28, 0x3d	; 61
     fb4:	de b7       	in	r29, 0x3e	; 62
	stop bit TWST0 and clear finish current job flag TWINT by toggle it */
TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     fb6:	86 e5       	ldi	r24, 0x56	; 86
     fb8:	90 e0       	ldi	r25, 0x00	; 0
     fba:	24 e9       	ldi	r18, 0x94	; 148
     fbc:	fc 01       	movw	r30, r24
     fbe:	20 83       	st	Z, r18

//NO NEED TO WAIT TWINT flag as it  is the end of frame
}
     fc0:	00 00       	nop
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	08 95       	ret

00000fc8 <TWI_write>:
void TWI_write(uint8 data)
{
     fc8:	cf 93       	push	r28
     fca:	df 93       	push	r29
     fcc:	1f 92       	push	r1
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
     fd2:	89 83       	std	Y+1, r24	; 0x01
/* store data in TWDR */
	TWDR=data;
     fd4:	83 e2       	ldi	r24, 0x23	; 35
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	29 81       	ldd	r18, Y+1	; 0x01
     fda:	fc 01       	movw	r30, r24
     fdc:	20 83       	st	Z, r18
	/*make enable again to force other bits in the register to be zero
		 clear finish current job flag TWINT by toggle it */
	TWCR=(1<<TWINT)|(1<<TWEN);
     fde:	86 e5       	ldi	r24, 0x56	; 86
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	24 e8       	ldi	r18, 0x84	; 132
     fe4:	fc 01       	movw	r30, r24
     fe6:	20 83       	st	Z, r18

	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     fe8:	00 00       	nop
     fea:	86 e5       	ldi	r24, 0x56	; 86
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	fc 01       	movw	r30, r24
     ff0:	80 81       	ld	r24, Z
     ff2:	88 23       	and	r24, r24
     ff4:	d4 f7       	brge	.-12     	; 0xfea <TWI_write+0x22>

}
     ff6:	00 00       	nop
     ff8:	0f 90       	pop	r0
     ffa:	df 91       	pop	r29
     ffc:	cf 91       	pop	r28
     ffe:	08 95       	ret

00001000 <TWI_read_with_ACK>:
uint8 TWI_read_with_ACK(void)
{/*make enable again to force other bits in the register to be zero
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it
		 enable acknowledge bit TWEA */

	TWCR=(1<<TWINT)|(1<<TWEA)|(1<<TWEN);
    1008:	86 e5       	ldi	r24, 0x56	; 86
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	24 ec       	ldi	r18, 0xC4	; 196
    100e:	fc 01       	movw	r30, r24
    1010:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));
    1012:	00 00       	nop
    1014:	86 e5       	ldi	r24, 0x56	; 86
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	fc 01       	movw	r30, r24
    101a:	80 81       	ld	r24, Z
    101c:	88 23       	and	r24, r24
    101e:	d4 f7       	brge	.-12     	; 0x1014 <TWI_read_with_ACK+0x14>
	//CLEAR flag before or after
	return TWDR;
    1020:	83 e2       	ldi	r24, 0x23	; 35
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	fc 01       	movw	r30, r24
    1026:	80 81       	ld	r24, Z
}
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	08 95       	ret

0000102e <TWI_read_with_NACK>:

uint8 TWI_read_with_NACK(void)
{/*make enable again to force other bits in the register to be zero
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it*/
	TWCR=(1<<TWINT)|(1<<TWEN);
    1036:	86 e5       	ldi	r24, 0x56	; 86
    1038:	90 e0       	ldi	r25, 0x00	; 0
    103a:	24 e8       	ldi	r18, 0x84	; 132
    103c:	fc 01       	movw	r30, r24
    103e:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
    1040:	00 00       	nop
    1042:	86 e5       	ldi	r24, 0x56	; 86
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	fc 01       	movw	r30, r24
    1048:	80 81       	ld	r24, Z
    104a:	88 23       	and	r24, r24
    104c:	d4 f7       	brge	.-12     	; 0x1042 <TWI_read_with_NACK+0x14>

	return TWDR;
    104e:	83 e2       	ldi	r24, 0x23	; 35
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	fc 01       	movw	r30, r24
    1054:	80 81       	ld	r24, Z
}
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	08 95       	ret

0000105c <TWI_getStatus>:
uint8 TWI_getStatus()
{	/*return bits 7:3 in status register TWSR */
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	cd b7       	in	r28, 0x3d	; 61
    1062:	de b7       	in	r29, 0x3e	; 62
	return TWSR&0XF8;
    1064:	81 e2       	ldi	r24, 0x21	; 33
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	fc 01       	movw	r30, r24
    106a:	80 81       	ld	r24, Z
    106c:	88 7f       	andi	r24, 0xF8	; 248
}
    106e:	df 91       	pop	r29
    1070:	cf 91       	pop	r28
    1072:	08 95       	ret

00001074 <__vector_19>:
/***************************************************************
 * 		Interrupt Service Routine functions definition 						*
 * *************************************************************
 */
/*ISR function work with timer 0 compare match mode */
ISR(TIMER0_COMP_vect) {
    1074:	1f 92       	push	r1
    1076:	0f 92       	push	r0
    1078:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    107c:	0f 92       	push	r0
    107e:	11 24       	eor	r1, r1
    1080:	2f 93       	push	r18
    1082:	3f 93       	push	r19
    1084:	4f 93       	push	r20
    1086:	5f 93       	push	r21
    1088:	6f 93       	push	r22
    108a:	7f 93       	push	r23
    108c:	8f 93       	push	r24
    108e:	9f 93       	push	r25
    1090:	af 93       	push	r26
    1092:	bf 93       	push	r27
    1094:	ef 93       	push	r30
    1096:	ff 93       	push	r31
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	cd b7       	in	r28, 0x3d	; 61
    109e:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) /* check that callback function address is passed */
    10a0:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    10a4:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    10a8:	89 2b       	or	r24, r25
    10aa:	31 f0       	breq	.+12     	; 0x10b8 <__vector_19+0x44>
		g_callBackPtr();/* point to callBack function */
    10ac:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    10b0:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    10b4:	fc 01       	movw	r30, r24
    10b6:	09 95       	icall

}
    10b8:	00 00       	nop
    10ba:	df 91       	pop	r29
    10bc:	cf 91       	pop	r28
    10be:	ff 91       	pop	r31
    10c0:	ef 91       	pop	r30
    10c2:	bf 91       	pop	r27
    10c4:	af 91       	pop	r26
    10c6:	9f 91       	pop	r25
    10c8:	8f 91       	pop	r24
    10ca:	7f 91       	pop	r23
    10cc:	6f 91       	pop	r22
    10ce:	5f 91       	pop	r21
    10d0:	4f 91       	pop	r20
    10d2:	3f 91       	pop	r19
    10d4:	2f 91       	pop	r18
    10d6:	0f 90       	pop	r0
    10d8:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10dc:	0f 90       	pop	r0
    10de:	1f 90       	pop	r1
    10e0:	18 95       	reti

000010e2 <__vector_9>:
/*ISR function work with timer 0 normal mode */
ISR(TIMER0_OVF_vect) {
    10e2:	1f 92       	push	r1
    10e4:	0f 92       	push	r0
    10e6:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10ea:	0f 92       	push	r0
    10ec:	11 24       	eor	r1, r1
    10ee:	2f 93       	push	r18
    10f0:	3f 93       	push	r19
    10f2:	4f 93       	push	r20
    10f4:	5f 93       	push	r21
    10f6:	6f 93       	push	r22
    10f8:	7f 93       	push	r23
    10fa:	8f 93       	push	r24
    10fc:	9f 93       	push	r25
    10fe:	af 93       	push	r26
    1100:	bf 93       	push	r27
    1102:	ef 93       	push	r30
    1104:	ff 93       	push	r31
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	cd b7       	in	r28, 0x3d	; 61
    110c:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    110e:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    1112:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    1116:	89 2b       	or	r24, r25
    1118:	31 f0       	breq	.+12     	; 0x1126 <__vector_9+0x44>
		g_callBackPtr();
    111a:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    111e:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    1122:	fc 01       	movw	r30, r24
    1124:	09 95       	icall

}
    1126:	00 00       	nop
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	ff 91       	pop	r31
    112e:	ef 91       	pop	r30
    1130:	bf 91       	pop	r27
    1132:	af 91       	pop	r26
    1134:	9f 91       	pop	r25
    1136:	8f 91       	pop	r24
    1138:	7f 91       	pop	r23
    113a:	6f 91       	pop	r22
    113c:	5f 91       	pop	r21
    113e:	4f 91       	pop	r20
    1140:	3f 91       	pop	r19
    1142:	2f 91       	pop	r18
    1144:	0f 90       	pop	r0
    1146:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    114a:	0f 90       	pop	r0
    114c:	1f 90       	pop	r1
    114e:	18 95       	reti

00001150 <__vector_8>:
/*ISR function work with timer 1 normal mode */
ISR(TIMER1_OVF_vect) {
    1150:	1f 92       	push	r1
    1152:	0f 92       	push	r0
    1154:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1158:	0f 92       	push	r0
    115a:	11 24       	eor	r1, r1
    115c:	2f 93       	push	r18
    115e:	3f 93       	push	r19
    1160:	4f 93       	push	r20
    1162:	5f 93       	push	r21
    1164:	6f 93       	push	r22
    1166:	7f 93       	push	r23
    1168:	8f 93       	push	r24
    116a:	9f 93       	push	r25
    116c:	af 93       	push	r26
    116e:	bf 93       	push	r27
    1170:	ef 93       	push	r30
    1172:	ff 93       	push	r31
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	cd b7       	in	r28, 0x3d	; 61
    117a:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    117c:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    1180:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    1184:	89 2b       	or	r24, r25
    1186:	31 f0       	breq	.+12     	; 0x1194 <__vector_8+0x44>
		g_callBackPtr();
    1188:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    118c:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    1190:	fc 01       	movw	r30, r24
    1192:	09 95       	icall

}
    1194:	00 00       	nop
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	ff 91       	pop	r31
    119c:	ef 91       	pop	r30
    119e:	bf 91       	pop	r27
    11a0:	af 91       	pop	r26
    11a2:	9f 91       	pop	r25
    11a4:	8f 91       	pop	r24
    11a6:	7f 91       	pop	r23
    11a8:	6f 91       	pop	r22
    11aa:	5f 91       	pop	r21
    11ac:	4f 91       	pop	r20
    11ae:	3f 91       	pop	r19
    11b0:	2f 91       	pop	r18
    11b2:	0f 90       	pop	r0
    11b4:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    11b8:	0f 90       	pop	r0
    11ba:	1f 90       	pop	r1
    11bc:	18 95       	reti

000011be <__vector_6>:
/*ISR function work with timer 1A compare match mode */
ISR(TIMER1_COMPA_vect) {
    11be:	1f 92       	push	r1
    11c0:	0f 92       	push	r0
    11c2:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    11c6:	0f 92       	push	r0
    11c8:	11 24       	eor	r1, r1
    11ca:	2f 93       	push	r18
    11cc:	3f 93       	push	r19
    11ce:	4f 93       	push	r20
    11d0:	5f 93       	push	r21
    11d2:	6f 93       	push	r22
    11d4:	7f 93       	push	r23
    11d6:	8f 93       	push	r24
    11d8:	9f 93       	push	r25
    11da:	af 93       	push	r26
    11dc:	bf 93       	push	r27
    11de:	ef 93       	push	r30
    11e0:	ff 93       	push	r31
    11e2:	cf 93       	push	r28
    11e4:	df 93       	push	r29
    11e6:	cd b7       	in	r28, 0x3d	; 61
    11e8:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    11ea:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    11ee:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    11f2:	89 2b       	or	r24, r25
    11f4:	31 f0       	breq	.+12     	; 0x1202 <__vector_6+0x44>
		g_callBackPtr();
    11f6:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    11fa:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    11fe:	fc 01       	movw	r30, r24
    1200:	09 95       	icall
}
    1202:	00 00       	nop
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	ff 91       	pop	r31
    120a:	ef 91       	pop	r30
    120c:	bf 91       	pop	r27
    120e:	af 91       	pop	r26
    1210:	9f 91       	pop	r25
    1212:	8f 91       	pop	r24
    1214:	7f 91       	pop	r23
    1216:	6f 91       	pop	r22
    1218:	5f 91       	pop	r21
    121a:	4f 91       	pop	r20
    121c:	3f 91       	pop	r19
    121e:	2f 91       	pop	r18
    1220:	0f 90       	pop	r0
    1222:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1226:	0f 90       	pop	r0
    1228:	1f 90       	pop	r1
    122a:	18 95       	reti

0000122c <__vector_3>:
/*ISR function work with timer 2 compare match mode */
ISR(TIMER2_COMP_vect) {
    122c:	1f 92       	push	r1
    122e:	0f 92       	push	r0
    1230:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1234:	0f 92       	push	r0
    1236:	11 24       	eor	r1, r1
    1238:	2f 93       	push	r18
    123a:	3f 93       	push	r19
    123c:	4f 93       	push	r20
    123e:	5f 93       	push	r21
    1240:	6f 93       	push	r22
    1242:	7f 93       	push	r23
    1244:	8f 93       	push	r24
    1246:	9f 93       	push	r25
    1248:	af 93       	push	r26
    124a:	bf 93       	push	r27
    124c:	ef 93       	push	r30
    124e:	ff 93       	push	r31
    1250:	cf 93       	push	r28
    1252:	df 93       	push	r29
    1254:	cd b7       	in	r28, 0x3d	; 61
    1256:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    1258:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    125c:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    1260:	89 2b       	or	r24, r25
    1262:	31 f0       	breq	.+12     	; 0x1270 <__vector_3+0x44>
		g_callBackPtr();
    1264:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    1268:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    126c:	fc 01       	movw	r30, r24
    126e:	09 95       	icall

}
    1270:	00 00       	nop
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	ff 91       	pop	r31
    1278:	ef 91       	pop	r30
    127a:	bf 91       	pop	r27
    127c:	af 91       	pop	r26
    127e:	9f 91       	pop	r25
    1280:	8f 91       	pop	r24
    1282:	7f 91       	pop	r23
    1284:	6f 91       	pop	r22
    1286:	5f 91       	pop	r21
    1288:	4f 91       	pop	r20
    128a:	3f 91       	pop	r19
    128c:	2f 91       	pop	r18
    128e:	0f 90       	pop	r0
    1290:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1294:	0f 90       	pop	r0
    1296:	1f 90       	pop	r1
    1298:	18 95       	reti

0000129a <__vector_4>:
/*ISR function work with timer 2 normal mode */
ISR(TIMER2_OVF_vect) {
    129a:	1f 92       	push	r1
    129c:	0f 92       	push	r0
    129e:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    12a2:	0f 92       	push	r0
    12a4:	11 24       	eor	r1, r1
    12a6:	2f 93       	push	r18
    12a8:	3f 93       	push	r19
    12aa:	4f 93       	push	r20
    12ac:	5f 93       	push	r21
    12ae:	6f 93       	push	r22
    12b0:	7f 93       	push	r23
    12b2:	8f 93       	push	r24
    12b4:	9f 93       	push	r25
    12b6:	af 93       	push	r26
    12b8:	bf 93       	push	r27
    12ba:	ef 93       	push	r30
    12bc:	ff 93       	push	r31
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    12c6:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    12ca:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    12ce:	89 2b       	or	r24, r25
    12d0:	31 f0       	breq	.+12     	; 0x12de <__vector_4+0x44>
		g_callBackPtr();
    12d2:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <g_callBackPtr>
    12d6:	90 91 05 01 	lds	r25, 0x0105	; 0x800105 <g_callBackPtr+0x1>
    12da:	fc 01       	movw	r30, r24
    12dc:	09 95       	icall
}
    12de:	00 00       	nop
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	ff 91       	pop	r31
    12e6:	ef 91       	pop	r30
    12e8:	bf 91       	pop	r27
    12ea:	af 91       	pop	r26
    12ec:	9f 91       	pop	r25
    12ee:	8f 91       	pop	r24
    12f0:	7f 91       	pop	r23
    12f2:	6f 91       	pop	r22
    12f4:	5f 91       	pop	r21
    12f6:	4f 91       	pop	r20
    12f8:	3f 91       	pop	r19
    12fa:	2f 91       	pop	r18
    12fc:	0f 90       	pop	r0
    12fe:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1302:	0f 90       	pop	r0
    1304:	1f 90       	pop	r1
    1306:	18 95       	reti

00001308 <TIMER_init>:




/* configurate by passing timer  configuration structure */
void TIMER_init(TIMER_configurationType *config) {
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	00 d0       	rcall	.+0      	; 0x130e <TIMER_init+0x6>
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	9a 83       	std	Y+2, r25	; 0x02
    1314:	89 83       	std	Y+1, r24	; 0x01
	configPtr = config; /* make passed configuration global */
    1316:	89 81       	ldd	r24, Y+1	; 0x01
    1318:	9a 81       	ldd	r25, Y+2	; 0x02
    131a:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <configPtr+0x1>
    131e:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <configPtr>


/***************************************************************
* 						0	TIMER0		*
* *************************************************************/
	if (config->timerNumber == 0) {
    1322:	89 81       	ldd	r24, Y+1	; 0x01
    1324:	9a 81       	ldd	r25, Y+2	; 0x02
    1326:	fc 01       	movw	r30, r24
    1328:	80 81       	ld	r24, Z
    132a:	88 23       	and	r24, r24
    132c:	09 f0       	breq	.+2      	; 0x1330 <TIMER_init+0x28>
    132e:	22 c1       	rjmp	.+580    	; 0x1574 <TIMER_init+0x26c>
		TCCR0 = 0; /* put zeros into all bits in the register */
    1330:	83 e5       	ldi	r24, 0x53	; 83
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	fc 01       	movw	r30, r24
    1336:	10 82       	st	Z, r1
		switch (config->prescaler) {
    1338:	89 81       	ldd	r24, Y+1	; 0x01
    133a:	9a 81       	ldd	r25, Y+2	; 0x02
    133c:	fc 01       	movw	r30, r24
    133e:	85 89       	ldd	r24, Z+21	; 0x15
    1340:	96 89       	ldd	r25, Z+22	; 0x16
    1342:	80 34       	cpi	r24, 0x40	; 64
    1344:	91 05       	cpc	r25, r1
    1346:	c1 f0       	breq	.+48     	; 0x1378 <TIMER_init+0x70>
    1348:	81 34       	cpi	r24, 0x41	; 65
    134a:	91 05       	cpc	r25, r1
    134c:	18 f4       	brcc	.+6      	; 0x1354 <TIMER_init+0x4c>
    134e:	08 97       	sbiw	r24, 0x08	; 8
    1350:	49 f0       	breq	.+18     	; 0x1364 <TIMER_init+0x5c>
    1352:	30 c0       	rjmp	.+96     	; 0x13b4 <TIMER_init+0xac>
    1354:	81 15       	cp	r24, r1
    1356:	f1 e0       	ldi	r31, 0x01	; 1
    1358:	9f 07       	cpc	r25, r31
    135a:	c1 f0       	breq	.+48     	; 0x138c <TIMER_init+0x84>
    135c:	81 15       	cp	r24, r1
    135e:	94 40       	sbci	r25, 0x04	; 4
    1360:	f9 f0       	breq	.+62     	; 0x13a0 <TIMER_init+0x98>
    1362:	28 c0       	rjmp	.+80     	; 0x13b4 <TIMER_init+0xac>
		case 8:
			TCCR0 |= (1 << CS01); /*CS00=0  CS01=1 CS02=0  */
    1364:	83 e5       	ldi	r24, 0x53	; 83
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	23 e5       	ldi	r18, 0x53	; 83
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	f9 01       	movw	r30, r18
    136e:	20 81       	ld	r18, Z
    1370:	22 60       	ori	r18, 0x02	; 2
    1372:	fc 01       	movw	r30, r24
    1374:	20 83       	st	Z, r18
			break;
    1376:	27 c0       	rjmp	.+78     	; 0x13c6 <TIMER_init+0xbe>
		case 64:
			TCCR0 |= (1 << CS00) | (1 << CS01); /*CS00=1  CS01=1 CS02=0  */
    1378:	83 e5       	ldi	r24, 0x53	; 83
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	23 e5       	ldi	r18, 0x53	; 83
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	f9 01       	movw	r30, r18
    1382:	20 81       	ld	r18, Z
    1384:	23 60       	ori	r18, 0x03	; 3
    1386:	fc 01       	movw	r30, r24
    1388:	20 83       	st	Z, r18
			break;
    138a:	1d c0       	rjmp	.+58     	; 0x13c6 <TIMER_init+0xbe>
		case 256:
			TCCR0 |= (1 << CS02); /*CS00=0  CS01=0 CS02=02  */
    138c:	83 e5       	ldi	r24, 0x53	; 83
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	23 e5       	ldi	r18, 0x53	; 83
    1392:	30 e0       	ldi	r19, 0x00	; 0
    1394:	f9 01       	movw	r30, r18
    1396:	20 81       	ld	r18, Z
    1398:	24 60       	ori	r18, 0x04	; 4
    139a:	fc 01       	movw	r30, r24
    139c:	20 83       	st	Z, r18
			break;
    139e:	13 c0       	rjmp	.+38     	; 0x13c6 <TIMER_init+0xbe>
		case 1024:
			TCCR0 |= (1 << CS00) | (1 << CS02); /*CS00=1  CS01=0 CS02=1  */
    13a0:	83 e5       	ldi	r24, 0x53	; 83
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	23 e5       	ldi	r18, 0x53	; 83
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	f9 01       	movw	r30, r18
    13aa:	20 81       	ld	r18, Z
    13ac:	25 60       	ori	r18, 0x05	; 5
    13ae:	fc 01       	movw	r30, r24
    13b0:	20 83       	st	Z, r18
			break;
    13b2:	09 c0       	rjmp	.+18     	; 0x13c6 <TIMER_init+0xbe>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR0 |= (1 << CS00); /*CS00=1  CS01=0 CS02=0  */
    13b4:	83 e5       	ldi	r24, 0x53	; 83
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	23 e5       	ldi	r18, 0x53	; 83
    13ba:	30 e0       	ldi	r19, 0x00	; 0
    13bc:	f9 01       	movw	r30, r18
    13be:	20 81       	ld	r18, Z
    13c0:	21 60       	ori	r18, 0x01	; 1
    13c2:	fc 01       	movw	r30, r24
    13c4:	20 83       	st	Z, r18
		}
/***************************************************************
 * 					0-0 select the mode for TIMER0	*
* *************************************************************
*/
		if (!strcmp(config->mode, "compare"))
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
    13c8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ca:	01 96       	adiw	r24, 0x01	; 1
    13cc:	6d e7       	ldi	r22, 0x7D	; 125
    13ce:	70 e0       	ldi	r23, 0x00	; 0
    13d0:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    13d4:	89 2b       	or	r24, r25
    13d6:	09 f0       	breq	.+2      	; 0x13da <TIMER_init+0xd2>
    13d8:	62 c0       	rjmp	.+196    	; 0x149e <TIMER_init+0x196>
		{
			TCCR0 |= (1 << FOC0) | (1 << WGM01);
    13da:	83 e5       	ldi	r24, 0x53	; 83
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	23 e5       	ldi	r18, 0x53	; 83
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	f9 01       	movw	r30, r18
    13e4:	20 81       	ld	r18, Z
    13e6:	28 68       	ori	r18, 0x88	; 136
    13e8:	fc 01       	movw	r30, r24
    13ea:	20 83       	st	Z, r18
 * 		0-1 compare match output mode for TIMER0	*
 * ***************************************************
 */


				if (!strcmp(config->compareMatchMode, "toggle")) {
    13ec:	89 81       	ldd	r24, Y+1	; 0x01
    13ee:	9a 81       	ldd	r25, Y+2	; 0x02
    13f0:	47 96       	adiw	r24, 0x17	; 23
    13f2:	65 e8       	ldi	r22, 0x85	; 133
    13f4:	70 e0       	ldi	r23, 0x00	; 0
    13f6:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    13fa:	89 2b       	or	r24, r25
    13fc:	99 f4       	brne	.+38     	; 0x1424 <TIMER_init+0x11c>
					TCCR0 |= (1 << COM00); /*COM00=1 AND COM01=0 */
    13fe:	83 e5       	ldi	r24, 0x53	; 83
    1400:	90 e0       	ldi	r25, 0x00	; 0
    1402:	23 e5       	ldi	r18, 0x53	; 83
    1404:	30 e0       	ldi	r19, 0x00	; 0
    1406:	f9 01       	movw	r30, r18
    1408:	20 81       	ld	r18, Z
    140a:	20 61       	ori	r18, 0x10	; 16
    140c:	fc 01       	movw	r30, r24
    140e:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3); /*make OCO AS OUTPUT BIT */
    1410:	87 e3       	ldi	r24, 0x37	; 55
    1412:	90 e0       	ldi	r25, 0x00	; 0
    1414:	27 e3       	ldi	r18, 0x37	; 55
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	f9 01       	movw	r30, r18
    141a:	20 81       	ld	r18, Z
    141c:	28 60       	ori	r18, 0x08	; 8
    141e:	fc 01       	movw	r30, r24
    1420:	20 83       	st	Z, r18
    1422:	37 c0       	rjmp	.+110    	; 0x1492 <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	9a 81       	ldd	r25, Y+2	; 0x02
    1428:	47 96       	adiw	r24, 0x17	; 23
    142a:	6c e8       	ldi	r22, 0x8C	; 140
    142c:	70 e0       	ldi	r23, 0x00	; 0
    142e:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1432:	89 2b       	or	r24, r25
    1434:	99 f4       	brne	.+38     	; 0x145c <TIMER_init+0x154>
					TCCR0 |= (1 << COM01); /*COM00=0 AND COM01=1 */
    1436:	83 e5       	ldi	r24, 0x53	; 83
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	23 e5       	ldi	r18, 0x53	; 83
    143c:	30 e0       	ldi	r19, 0x00	; 0
    143e:	f9 01       	movw	r30, r18
    1440:	20 81       	ld	r18, Z
    1442:	20 62       	ori	r18, 0x20	; 32
    1444:	fc 01       	movw	r30, r24
    1446:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    1448:	87 e3       	ldi	r24, 0x37	; 55
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	27 e3       	ldi	r18, 0x37	; 55
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	f9 01       	movw	r30, r18
    1452:	20 81       	ld	r18, Z
    1454:	28 60       	ori	r18, 0x08	; 8
    1456:	fc 01       	movw	r30, r24
    1458:	20 83       	st	Z, r18
    145a:	1b c0       	rjmp	.+54     	; 0x1492 <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "set")) {
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	9a 81       	ldd	r25, Y+2	; 0x02
    1460:	47 96       	adiw	r24, 0x17	; 23
    1462:	62 e9       	ldi	r22, 0x92	; 146
    1464:	70 e0       	ldi	r23, 0x00	; 0
    1466:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    146a:	89 2b       	or	r24, r25
    146c:	91 f4       	brne	.+36     	; 0x1492 <TIMER_init+0x18a>
					TCCR0 |= (1 << COM01) | (1 << COM00); /*COM00=1 AND COM01=1 */
    146e:	83 e5       	ldi	r24, 0x53	; 83
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	23 e5       	ldi	r18, 0x53	; 83
    1474:	30 e0       	ldi	r19, 0x00	; 0
    1476:	f9 01       	movw	r30, r18
    1478:	20 81       	ld	r18, Z
    147a:	20 63       	ori	r18, 0x30	; 48
    147c:	fc 01       	movw	r30, r24
    147e:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    1480:	87 e3       	ldi	r24, 0x37	; 55
    1482:	90 e0       	ldi	r25, 0x00	; 0
    1484:	27 e3       	ldi	r18, 0x37	; 55
    1486:	30 e0       	ldi	r19, 0x00	; 0
    1488:	f9 01       	movw	r30, r18
    148a:	20 81       	ld	r18, Z
    148c:	28 60       	ori	r18, 0x08	; 8
    148e:	fc 01       	movw	r30, r24
    1490:	20 83       	st	Z, r18
				}
				/* the default case will be normal port operation OCO disconnected
				enable interrupt for compare mode */
				TIMSK = (1 << OCIE0);
    1492:	89 e5       	ldi	r24, 0x59	; 89
    1494:	90 e0       	ldi	r25, 0x00	; 0
    1496:	22 e0       	ldi	r18, 0x02	; 2
    1498:	fc 01       	movw	r30, r24
    149a:	20 83       	st	Z, r18
    149c:	6b c0       	rjmp	.+214    	; 0x1574 <TIMER_init+0x26c>
/****************************************************
 * 		0-2 normal  mode for TIMER0		    *
 * ***************************************************
 */

		else if (!strcmp(config->mode, "normal"))
    149e:	89 81       	ldd	r24, Y+1	; 0x01
    14a0:	9a 81       	ldd	r25, Y+2	; 0x02
    14a2:	01 96       	adiw	r24, 0x01	; 1
    14a4:	66 e9       	ldi	r22, 0x96	; 150
    14a6:	70 e0       	ldi	r23, 0x00	; 0
    14a8:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    14ac:	89 2b       	or	r24, r25
    14ae:	79 f4       	brne	.+30     	; 0x14ce <TIMER_init+0x1c6>
			{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM01=0 and WGM00=0
			 */
			TCCR0 |= (1 << FOC0);
    14b0:	83 e5       	ldi	r24, 0x53	; 83
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	23 e5       	ldi	r18, 0x53	; 83
    14b6:	30 e0       	ldi	r19, 0x00	; 0
    14b8:	f9 01       	movw	r30, r18
    14ba:	20 81       	ld	r18, Z
    14bc:	20 68       	ori	r18, 0x80	; 128
    14be:	fc 01       	movw	r30, r24
    14c0:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE0);
    14c2:	89 e5       	ldi	r24, 0x59	; 89
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	21 e0       	ldi	r18, 0x01	; 1
    14c8:	fc 01       	movw	r30, r24
    14ca:	20 83       	st	Z, r18
    14cc:	53 c0       	rjmp	.+166    	; 0x1574 <TIMER_init+0x26c>
			}
/****************************************************
 * 			0-3 PWM  mode for TIMER0	   *
 * ***************************************************
								 */
		else if (!strcmp(config->mode, "pwm")) {
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
    14d0:	9a 81       	ldd	r25, Y+2	; 0x02
    14d2:	01 96       	adiw	r24, 0x01	; 1
    14d4:	6d e9       	ldi	r22, 0x9D	; 157
    14d6:	70 e0       	ldi	r23, 0x00	; 0
    14d8:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    14dc:	89 2b       	or	r24, r25
    14de:	09 f0       	breq	.+2      	; 0x14e2 <TIMER_init+0x1da>
    14e0:	49 c0       	rjmp	.+146    	; 0x1574 <TIMER_init+0x26c>
			/*
			 * FOC0=0 for  PWM mode
			 * select PWM mode --->> WGM01=1 and WGM00=1
			 */
			TCCR0 |= (1 << WGM00) | (1 << WGM01);
    14e2:	83 e5       	ldi	r24, 0x53	; 83
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	23 e5       	ldi	r18, 0x53	; 83
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	f9 01       	movw	r30, r18
    14ec:	20 81       	ld	r18, Z
    14ee:	28 64       	ori	r18, 0x48	; 72
    14f0:	fc 01       	movw	r30, r24
    14f2:	20 83       	st	Z, r18


			if (!strcmp(config->pwmMode, "inverting")) {
    14f4:	89 81       	ldd	r24, Y+1	; 0x01
    14f6:	9a 81       	ldd	r25, Y+2	; 0x02
    14f8:	8b 96       	adiw	r24, 0x2b	; 43
    14fa:	61 ea       	ldi	r22, 0xA1	; 161
    14fc:	70 e0       	ldi	r23, 0x00	; 0
    14fe:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1502:	89 2b       	or	r24, r25
    1504:	e1 f4       	brne	.+56     	; 0x153e <TIMER_init+0x236>
				/* COM00=1 and COM01=1 */
				TCCR0 |= (1 << COM00);
    1506:	83 e5       	ldi	r24, 0x53	; 83
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	23 e5       	ldi	r18, 0x53	; 83
    150c:	30 e0       	ldi	r19, 0x00	; 0
    150e:	f9 01       	movw	r30, r18
    1510:	20 81       	ld	r18, Z
    1512:	20 61       	ori	r18, 0x10	; 16
    1514:	fc 01       	movw	r30, r24
    1516:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM01);
    1518:	83 e5       	ldi	r24, 0x53	; 83
    151a:	90 e0       	ldi	r25, 0x00	; 0
    151c:	23 e5       	ldi	r18, 0x53	; 83
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	f9 01       	movw	r30, r18
    1522:	20 81       	ld	r18, Z
    1524:	20 62       	ori	r18, 0x20	; 32
    1526:	fc 01       	movw	r30, r24
    1528:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    152a:	87 e3       	ldi	r24, 0x37	; 55
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	27 e3       	ldi	r18, 0x37	; 55
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	f9 01       	movw	r30, r18
    1534:	20 81       	ld	r18, Z
    1536:	28 60       	ori	r18, 0x08	; 8
    1538:	fc 01       	movw	r30, r24
    153a:	20 83       	st	Z, r18
    153c:	1b c0       	rjmp	.+54     	; 0x1574 <TIMER_init+0x26c>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	9a 81       	ldd	r25, Y+2	; 0x02
    1542:	8b 96       	adiw	r24, 0x2b	; 43
    1544:	6b ea       	ldi	r22, 0xAB	; 171
    1546:	70 e0       	ldi	r23, 0x00	; 0
    1548:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    154c:	89 2b       	or	r24, r25
    154e:	91 f4       	brne	.+36     	; 0x1574 <TIMER_init+0x26c>
				/* COM00=0 and COM01=1 */
				TCCR0 |= (1 << COM01);
    1550:	83 e5       	ldi	r24, 0x53	; 83
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	23 e5       	ldi	r18, 0x53	; 83
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	f9 01       	movw	r30, r18
    155a:	20 81       	ld	r18, Z
    155c:	20 62       	ori	r18, 0x20	; 32
    155e:	fc 01       	movw	r30, r24
    1560:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    1562:	87 e3       	ldi	r24, 0x37	; 55
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	27 e3       	ldi	r18, 0x37	; 55
    1568:	30 e0       	ldi	r19, 0x00	; 0
    156a:	f9 01       	movw	r30, r18
    156c:	20 81       	ld	r18, Z
    156e:	28 60       	ori	r18, 0x08	; 8
    1570:	fc 01       	movw	r30, r24
    1572:	20 83       	st	Z, r18
*/

	if (config->timerNumber == 1) {
		/* put zeros into all bits in the registers */
	}
		TCCR1A = 0;
    1574:	8f e4       	ldi	r24, 0x4F	; 79
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	fc 01       	movw	r30, r24
    157a:	10 82       	st	Z, r1
		TCCR1B = 0;
    157c:	8e e4       	ldi	r24, 0x4E	; 78
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	fc 01       	movw	r30, r24
    1582:	10 82       	st	Z, r1

		switch (config->prescaler) {
    1584:	89 81       	ldd	r24, Y+1	; 0x01
    1586:	9a 81       	ldd	r25, Y+2	; 0x02
    1588:	fc 01       	movw	r30, r24
    158a:	85 89       	ldd	r24, Z+21	; 0x15
    158c:	96 89       	ldd	r25, Z+22	; 0x16
    158e:	80 34       	cpi	r24, 0x40	; 64
    1590:	91 05       	cpc	r25, r1
    1592:	c1 f0       	breq	.+48     	; 0x15c4 <TIMER_init+0x2bc>
    1594:	81 34       	cpi	r24, 0x41	; 65
    1596:	91 05       	cpc	r25, r1
    1598:	18 f4       	brcc	.+6      	; 0x15a0 <TIMER_init+0x298>
    159a:	08 97       	sbiw	r24, 0x08	; 8
    159c:	49 f0       	breq	.+18     	; 0x15b0 <TIMER_init+0x2a8>
    159e:	30 c0       	rjmp	.+96     	; 0x1600 <TIMER_init+0x2f8>
    15a0:	81 15       	cp	r24, r1
    15a2:	f1 e0       	ldi	r31, 0x01	; 1
    15a4:	9f 07       	cpc	r25, r31
    15a6:	c1 f0       	breq	.+48     	; 0x15d8 <TIMER_init+0x2d0>
    15a8:	81 15       	cp	r24, r1
    15aa:	94 40       	sbci	r25, 0x04	; 4
    15ac:	f9 f0       	breq	.+62     	; 0x15ec <TIMER_init+0x2e4>
    15ae:	28 c0       	rjmp	.+80     	; 0x1600 <TIMER_init+0x2f8>
		case 8:
			TCCR1B |= (1 << CS11);/*CS10=0  CS11=1 CS12=0  */
    15b0:	8e e4       	ldi	r24, 0x4E	; 78
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	2e e4       	ldi	r18, 0x4E	; 78
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	f9 01       	movw	r30, r18
    15ba:	20 81       	ld	r18, Z
    15bc:	22 60       	ori	r18, 0x02	; 2
    15be:	fc 01       	movw	r30, r24
    15c0:	20 83       	st	Z, r18
			break;
    15c2:	27 c0       	rjmp	.+78     	; 0x1612 <TIMER_init+0x30a>
		case 64:
			TCCR1B |= (1 << CS10) | (1 << CS11); /*CS10=1  CS11=1 CS12=0  */
    15c4:	8e e4       	ldi	r24, 0x4E	; 78
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	2e e4       	ldi	r18, 0x4E	; 78
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	f9 01       	movw	r30, r18
    15ce:	20 81       	ld	r18, Z
    15d0:	23 60       	ori	r18, 0x03	; 3
    15d2:	fc 01       	movw	r30, r24
    15d4:	20 83       	st	Z, r18
			break;
    15d6:	1d c0       	rjmp	.+58     	; 0x1612 <TIMER_init+0x30a>
		case 256:
			TCCR1B |= (1 << CS12);/*CS10=0  CS11=0 CS12=1  */
    15d8:	8e e4       	ldi	r24, 0x4E	; 78
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	2e e4       	ldi	r18, 0x4E	; 78
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	f9 01       	movw	r30, r18
    15e2:	20 81       	ld	r18, Z
    15e4:	24 60       	ori	r18, 0x04	; 4
    15e6:	fc 01       	movw	r30, r24
    15e8:	20 83       	st	Z, r18
			break;
    15ea:	13 c0       	rjmp	.+38     	; 0x1612 <TIMER_init+0x30a>
		case 1024:
			TCCR1B |= (1 << CS10) | (1 << CS12);/*CS10=1  CS11=1 CS12=1  */
    15ec:	8e e4       	ldi	r24, 0x4E	; 78
    15ee:	90 e0       	ldi	r25, 0x00	; 0
    15f0:	2e e4       	ldi	r18, 0x4E	; 78
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	f9 01       	movw	r30, r18
    15f6:	20 81       	ld	r18, Z
    15f8:	25 60       	ori	r18, 0x05	; 5
    15fa:	fc 01       	movw	r30, r24
    15fc:	20 83       	st	Z, r18
			break;
    15fe:	09 c0       	rjmp	.+18     	; 0x1612 <TIMER_init+0x30a>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR1B |= (1 << CS10); /*CS10=1  CS11=0 CS12=0  */
    1600:	8e e4       	ldi	r24, 0x4E	; 78
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	2e e4       	ldi	r18, 0x4E	; 78
    1606:	30 e0       	ldi	r19, 0x00	; 0
    1608:	f9 01       	movw	r30, r18
    160a:	20 81       	ld	r18, Z
    160c:	21 60       	ori	r18, 0x01	; 1
    160e:	fc 01       	movw	r30, r24
    1610:	20 83       	st	Z, r18

/****************************************************
* 		1-1 compare match output mode for TIMER1 A	*
* ***************************************************
*/
		if (!strcmp(config->mode, "compare")) {
    1612:	89 81       	ldd	r24, Y+1	; 0x01
    1614:	9a 81       	ldd	r25, Y+2	; 0x02
    1616:	01 96       	adiw	r24, 0x01	; 1
    1618:	6d e7       	ldi	r22, 0x7D	; 125
    161a:	70 e0       	ldi	r23, 0x00	; 0
    161c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1620:	89 2b       	or	r24, r25
    1622:	09 f0       	breq	.+2      	; 0x1626 <TIMER_init+0x31e>
    1624:	6b c0       	rjmp	.+214    	; 0x16fc <TIMER_init+0x3f4>
			/*
			 * FOC1=1 for non PWM mode
			 * select compare mode --->> /* WGM10=0 ,  WGM11=0 , WGM12=1 and WGM13=0 */
			TCCR1A |= (1 << FOC1A);
    1626:	8f e4       	ldi	r24, 0x4F	; 79
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	2f e4       	ldi	r18, 0x4F	; 79
    162c:	30 e0       	ldi	r19, 0x00	; 0
    162e:	f9 01       	movw	r30, r18
    1630:	20 81       	ld	r18, Z
    1632:	28 60       	ori	r18, 0x08	; 8
    1634:	fc 01       	movw	r30, r24
    1636:	20 83       	st	Z, r18
			TCCR1B |= (1 << WGM12);
    1638:	8e e4       	ldi	r24, 0x4E	; 78
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	2e e4       	ldi	r18, 0x4E	; 78
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	f9 01       	movw	r30, r18
    1642:	20 81       	ld	r18, Z
    1644:	28 60       	ori	r18, 0x08	; 8
    1646:	fc 01       	movw	r30, r24
    1648:	20 83       	st	Z, r18
			if (!strcmp(config->compareMatchMode, "toggle")) {
    164a:	89 81       	ldd	r24, Y+1	; 0x01
    164c:	9a 81       	ldd	r25, Y+2	; 0x02
    164e:	47 96       	adiw	r24, 0x17	; 23
    1650:	65 e8       	ldi	r22, 0x85	; 133
    1652:	70 e0       	ldi	r23, 0x00	; 0
    1654:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1658:	89 2b       	or	r24, r25
    165a:	99 f4       	brne	.+38     	; 0x1682 <TIMER_init+0x37a>
				TCCR1A |= (1 << COM1A0); /*COM1A0=1 AND COM1A1=0 */
    165c:	8f e4       	ldi	r24, 0x4F	; 79
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	2f e4       	ldi	r18, 0x4F	; 79
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	f9 01       	movw	r30, r18
    1666:	20 81       	ld	r18, Z
    1668:	20 64       	ori	r18, 0x40	; 64
    166a:	fc 01       	movw	r30, r24
    166c:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);/*make OCO AS OUTPUT BIT */
    166e:	81 e3       	ldi	r24, 0x31	; 49
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	21 e3       	ldi	r18, 0x31	; 49
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	f9 01       	movw	r30, r18
    1678:	20 81       	ld	r18, Z
    167a:	20 62       	ori	r18, 0x20	; 32
    167c:	fc 01       	movw	r30, r24
    167e:	20 83       	st	Z, r18
    1680:	37 c0       	rjmp	.+110    	; 0x16f0 <TIMER_init+0x3e8>
			} else if (!strcmp(config->compareMatchMode, "clear")) {
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	9a 81       	ldd	r25, Y+2	; 0x02
    1686:	47 96       	adiw	r24, 0x17	; 23
    1688:	6c e8       	ldi	r22, 0x8C	; 140
    168a:	70 e0       	ldi	r23, 0x00	; 0
    168c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1690:	89 2b       	or	r24, r25
    1692:	99 f4       	brne	.+38     	; 0x16ba <TIMER_init+0x3b2>
				TCCR1A |= (1 << COM1A1);/*COM1A0=0 AND COM1A1=1 */
    1694:	8f e4       	ldi	r24, 0x4F	; 79
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	2f e4       	ldi	r18, 0x4F	; 79
    169a:	30 e0       	ldi	r19, 0x00	; 0
    169c:	f9 01       	movw	r30, r18
    169e:	20 81       	ld	r18, Z
    16a0:	20 68       	ori	r18, 0x80	; 128
    16a2:	fc 01       	movw	r30, r24
    16a4:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    16a6:	81 e3       	ldi	r24, 0x31	; 49
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	21 e3       	ldi	r18, 0x31	; 49
    16ac:	30 e0       	ldi	r19, 0x00	; 0
    16ae:	f9 01       	movw	r30, r18
    16b0:	20 81       	ld	r18, Z
    16b2:	20 62       	ori	r18, 0x20	; 32
    16b4:	fc 01       	movw	r30, r24
    16b6:	20 83       	st	Z, r18
    16b8:	1b c0       	rjmp	.+54     	; 0x16f0 <TIMER_init+0x3e8>

			} else if (!strcmp(config->compareMatchMode, "set")) {
    16ba:	89 81       	ldd	r24, Y+1	; 0x01
    16bc:	9a 81       	ldd	r25, Y+2	; 0x02
    16be:	47 96       	adiw	r24, 0x17	; 23
    16c0:	62 e9       	ldi	r22, 0x92	; 146
    16c2:	70 e0       	ldi	r23, 0x00	; 0
    16c4:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    16c8:	89 2b       	or	r24, r25
    16ca:	91 f4       	brne	.+36     	; 0x16f0 <TIMER_init+0x3e8>
				TCCR1A |= (1 << COM1A1) | (1 << COM1A0);/*COM1A0=1 AND COM1A1=1 */
    16cc:	8f e4       	ldi	r24, 0x4F	; 79
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	2f e4       	ldi	r18, 0x4F	; 79
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	f9 01       	movw	r30, r18
    16d6:	20 81       	ld	r18, Z
    16d8:	20 6c       	ori	r18, 0xC0	; 192
    16da:	fc 01       	movw	r30, r24
    16dc:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    16de:	81 e3       	ldi	r24, 0x31	; 49
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	21 e3       	ldi	r18, 0x31	; 49
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	f9 01       	movw	r30, r18
    16e8:	20 81       	ld	r18, Z
    16ea:	20 62       	ori	r18, 0x20	; 32
    16ec:	fc 01       	movw	r30, r24
    16ee:	20 83       	st	Z, r18

			}
			/* the default case will be normal port operation OCO disconnected
							enable interrupt for compare mode */
			TIMSK = (1 << OCIE1A);
    16f0:	89 e5       	ldi	r24, 0x59	; 89
    16f2:	90 e0       	ldi	r25, 0x00	; 0
    16f4:	20 e1       	ldi	r18, 0x10	; 16
    16f6:	fc 01       	movw	r30, r24
    16f8:	20 83       	st	Z, r18
    16fa:	6b c0       	rjmp	.+214    	; 0x17d2 <TIMER_init+0x4ca>
/****************************************************
* 		1-2 normal  mode for TIMER1		      *
* ***************************************************
*/
		} else if (!strcmp(config->mode, "normal"))
    16fc:	89 81       	ldd	r24, Y+1	; 0x01
    16fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1700:	01 96       	adiw	r24, 0x01	; 1
    1702:	66 e9       	ldi	r22, 0x96	; 150
    1704:	70 e0       	ldi	r23, 0x00	; 0
    1706:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    170a:	89 2b       	or	r24, r25
    170c:	79 f4       	brne	.+30     	; 0x172c <TIMER_init+0x424>
		{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM11=0 and WGM10=0
						 */
			TCCR1A |= (1 << FOC1A);
    170e:	8f e4       	ldi	r24, 0x4F	; 79
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	2f e4       	ldi	r18, 0x4F	; 79
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	f9 01       	movw	r30, r18
    1718:	20 81       	ld	r18, Z
    171a:	28 60       	ori	r18, 0x08	; 8
    171c:	fc 01       	movw	r30, r24
    171e:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE1);
    1720:	89 e5       	ldi	r24, 0x59	; 89
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	24 e0       	ldi	r18, 0x04	; 4
    1726:	fc 01       	movw	r30, r24
    1728:	20 83       	st	Z, r18
    172a:	53 c0       	rjmp	.+166    	; 0x17d2 <TIMER_init+0x4ca>


/****************************************************
 * 			1-3 PWM  mode for TIMER1 A		  *
 * ***************************************************/
		} else if (!strcmp(config->mode, "pwm")) {
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	9a 81       	ldd	r25, Y+2	; 0x02
    1730:	01 96       	adiw	r24, 0x01	; 1
    1732:	6d e9       	ldi	r22, 0x9D	; 157
    1734:	70 e0       	ldi	r23, 0x00	; 0
    1736:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    173a:	89 2b       	or	r24, r25
    173c:	09 f0       	breq	.+2      	; 0x1740 <TIMER_init+0x438>
    173e:	49 c0       	rjmp	.+146    	; 0x17d2 <TIMER_init+0x4ca>
			/* WGM10=1 ,  WGM11=1 , WGM12=1 and WGM13=1 */
			TCCR0 |= (1 << WGM10) | (1 << WGM11)| (1 << WGM12)| (1 << WGM13);
    1740:	83 e5       	ldi	r24, 0x53	; 83
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	23 e5       	ldi	r18, 0x53	; 83
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	f9 01       	movw	r30, r18
    174a:	20 81       	ld	r18, Z
    174c:	2b 61       	ori	r18, 0x1B	; 27
    174e:	fc 01       	movw	r30, r24
    1750:	20 83       	st	Z, r18
			if (!strcmp(config->pwmMode, "inverting")) {
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	9a 81       	ldd	r25, Y+2	; 0x02
    1756:	8b 96       	adiw	r24, 0x2b	; 43
    1758:	61 ea       	ldi	r22, 0xA1	; 161
    175a:	70 e0       	ldi	r23, 0x00	; 0
    175c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1760:	89 2b       	or	r24, r25
    1762:	e1 f4       	brne	.+56     	; 0x179c <TIMER_init+0x494>
				TCCR0 |= (1 << COM1A0);/* COM1A0=1 and COM1A1=1 */
    1764:	83 e5       	ldi	r24, 0x53	; 83
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	23 e5       	ldi	r18, 0x53	; 83
    176a:	30 e0       	ldi	r19, 0x00	; 0
    176c:	f9 01       	movw	r30, r18
    176e:	20 81       	ld	r18, Z
    1770:	20 64       	ori	r18, 0x40	; 64
    1772:	fc 01       	movw	r30, r24
    1774:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM1A1);
    1776:	83 e5       	ldi	r24, 0x53	; 83
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	23 e5       	ldi	r18, 0x53	; 83
    177c:	30 e0       	ldi	r19, 0x00	; 0
    177e:	f9 01       	movw	r30, r18
    1780:	20 81       	ld	r18, Z
    1782:	20 68       	ori	r18, 0x80	; 128
    1784:	fc 01       	movw	r30, r24
    1786:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    1788:	87 e3       	ldi	r24, 0x37	; 55
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	27 e3       	ldi	r18, 0x37	; 55
    178e:	30 e0       	ldi	r19, 0x00	; 0
    1790:	f9 01       	movw	r30, r18
    1792:	20 81       	ld	r18, Z
    1794:	28 60       	ori	r18, 0x08	; 8
    1796:	fc 01       	movw	r30, r24
    1798:	20 83       	st	Z, r18
    179a:	1b c0       	rjmp	.+54     	; 0x17d2 <TIMER_init+0x4ca>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    179c:	89 81       	ldd	r24, Y+1	; 0x01
    179e:	9a 81       	ldd	r25, Y+2	; 0x02
    17a0:	8b 96       	adiw	r24, 0x2b	; 43
    17a2:	6b ea       	ldi	r22, 0xAB	; 171
    17a4:	70 e0       	ldi	r23, 0x00	; 0
    17a6:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    17aa:	89 2b       	or	r24, r25
    17ac:	91 f4       	brne	.+36     	; 0x17d2 <TIMER_init+0x4ca>
				TCCR0 |= (1 << COM1A1);/* COM1A0=0 and COM1A1=1 */
    17ae:	83 e5       	ldi	r24, 0x53	; 83
    17b0:	90 e0       	ldi	r25, 0x00	; 0
    17b2:	23 e5       	ldi	r18, 0x53	; 83
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	f9 01       	movw	r30, r18
    17b8:	20 81       	ld	r18, Z
    17ba:	20 68       	ori	r18, 0x80	; 128
    17bc:	fc 01       	movw	r30, r24
    17be:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    17c0:	87 e3       	ldi	r24, 0x37	; 55
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	27 e3       	ldi	r18, 0x37	; 55
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	f9 01       	movw	r30, r18
    17ca:	20 81       	ld	r18, Z
    17cc:	28 60       	ori	r18, 0x08	; 8
    17ce:	fc 01       	movw	r30, r24
    17d0:	20 83       	st	Z, r18

		}
/***************************************************************
* 						2	TIMER2						*
 * *************************************************************/
		if (config->timerNumber == 2) {
    17d2:	89 81       	ldd	r24, Y+1	; 0x01
    17d4:	9a 81       	ldd	r25, Y+2	; 0x02
    17d6:	fc 01       	movw	r30, r24
    17d8:	80 81       	ld	r24, Z
    17da:	82 30       	cpi	r24, 0x02	; 2
    17dc:	09 f0       	breq	.+2      	; 0x17e0 <TIMER_init+0x4d8>
    17de:	3d c1       	rjmp	.+634    	; 0x1a5a <TIMER_init+0x752>
			TCCR2 = 0;/* put zeros into all bits in the register */
    17e0:	85 e4       	ldi	r24, 0x45	; 69
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	fc 01       	movw	r30, r24
    17e6:	10 82       	st	Z, r1
			switch (config->prescaler) {
    17e8:	89 81       	ldd	r24, Y+1	; 0x01
    17ea:	9a 81       	ldd	r25, Y+2	; 0x02
    17ec:	fc 01       	movw	r30, r24
    17ee:	85 89       	ldd	r24, Z+21	; 0x15
    17f0:	96 89       	ldd	r25, Z+22	; 0x16
    17f2:	80 34       	cpi	r24, 0x40	; 64
    17f4:	91 05       	cpc	r25, r1
    17f6:	49 f1       	breq	.+82     	; 0x184a <TIMER_init+0x542>
    17f8:	81 34       	cpi	r24, 0x41	; 65
    17fa:	91 05       	cpc	r25, r1
    17fc:	30 f4       	brcc	.+12     	; 0x180a <TIMER_init+0x502>
    17fe:	88 30       	cpi	r24, 0x08	; 8
    1800:	91 05       	cpc	r25, r1
    1802:	79 f0       	breq	.+30     	; 0x1822 <TIMER_init+0x51a>
    1804:	80 97       	sbiw	r24, 0x20	; 32
    1806:	b9 f0       	breq	.+46     	; 0x1836 <TIMER_init+0x52e>
    1808:	48 c0       	rjmp	.+144    	; 0x189a <TIMER_init+0x592>
    180a:	81 15       	cp	r24, r1
    180c:	f1 e0       	ldi	r31, 0x01	; 1
    180e:	9f 07       	cpc	r25, r31
    1810:	81 f1       	breq	.+96     	; 0x1872 <TIMER_init+0x56a>
    1812:	81 15       	cp	r24, r1
    1814:	24 e0       	ldi	r18, 0x04	; 4
    1816:	92 07       	cpc	r25, r18
    1818:	b1 f1       	breq	.+108    	; 0x1886 <TIMER_init+0x57e>
    181a:	80 38       	cpi	r24, 0x80	; 128
    181c:	91 05       	cpc	r25, r1
    181e:	f9 f0       	breq	.+62     	; 0x185e <TIMER_init+0x556>
    1820:	3c c0       	rjmp	.+120    	; 0x189a <TIMER_init+0x592>
			case 8:
				TCCR2 |= (1 << CS21);/*CS20=0  CS21=1 CS22=0  */
    1822:	85 e4       	ldi	r24, 0x45	; 69
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	25 e4       	ldi	r18, 0x45	; 69
    1828:	30 e0       	ldi	r19, 0x00	; 0
    182a:	f9 01       	movw	r30, r18
    182c:	20 81       	ld	r18, Z
    182e:	22 60       	ori	r18, 0x02	; 2
    1830:	fc 01       	movw	r30, r24
    1832:	20 83       	st	Z, r18
				break;
    1834:	3b c0       	rjmp	.+118    	; 0x18ac <TIMER_init+0x5a4>
			case 32:
				TCCR2 |= (1 << CS20) | (1 << CS21);/*CS20=1  CS21=0 CS22=0  */
    1836:	85 e4       	ldi	r24, 0x45	; 69
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	25 e4       	ldi	r18, 0x45	; 69
    183c:	30 e0       	ldi	r19, 0x00	; 0
    183e:	f9 01       	movw	r30, r18
    1840:	20 81       	ld	r18, Z
    1842:	23 60       	ori	r18, 0x03	; 3
    1844:	fc 01       	movw	r30, r24
    1846:	20 83       	st	Z, r18
				break;
    1848:	31 c0       	rjmp	.+98     	; 0x18ac <TIMER_init+0x5a4>
			case 64:
				TCCR2 |= (1 << CS22);/*CS20=0  CS21=0 CS22=1  */
    184a:	85 e4       	ldi	r24, 0x45	; 69
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	25 e4       	ldi	r18, 0x45	; 69
    1850:	30 e0       	ldi	r19, 0x00	; 0
    1852:	f9 01       	movw	r30, r18
    1854:	20 81       	ld	r18, Z
    1856:	24 60       	ori	r18, 0x04	; 4
    1858:	fc 01       	movw	r30, r24
    185a:	20 83       	st	Z, r18
				break;
    185c:	27 c0       	rjmp	.+78     	; 0x18ac <TIMER_init+0x5a4>
			case 128:
				TCCR2 |= (1 << CS20) | (1 << CS22);/*CS20=1  CS21=0 CS22=1  */
    185e:	85 e4       	ldi	r24, 0x45	; 69
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	25 e4       	ldi	r18, 0x45	; 69
    1864:	30 e0       	ldi	r19, 0x00	; 0
    1866:	f9 01       	movw	r30, r18
    1868:	20 81       	ld	r18, Z
    186a:	25 60       	ori	r18, 0x05	; 5
    186c:	fc 01       	movw	r30, r24
    186e:	20 83       	st	Z, r18
				break;
    1870:	1d c0       	rjmp	.+58     	; 0x18ac <TIMER_init+0x5a4>
			case 256:
				TCCR2 |= (1 << CS21) | (1 << CS22);/*CS20=0  CS21=1 CS22=1  */
    1872:	85 e4       	ldi	r24, 0x45	; 69
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	25 e4       	ldi	r18, 0x45	; 69
    1878:	30 e0       	ldi	r19, 0x00	; 0
    187a:	f9 01       	movw	r30, r18
    187c:	20 81       	ld	r18, Z
    187e:	26 60       	ori	r18, 0x06	; 6
    1880:	fc 01       	movw	r30, r24
    1882:	20 83       	st	Z, r18
				break;
    1884:	13 c0       	rjmp	.+38     	; 0x18ac <TIMER_init+0x5a4>
			case 1024:
				TCCR2 |= (1 << CS20) | (1 << CS21) | (1 << CS22);/*CS20=1  CS21=1 CS22=1  */
    1886:	85 e4       	ldi	r24, 0x45	; 69
    1888:	90 e0       	ldi	r25, 0x00	; 0
    188a:	25 e4       	ldi	r18, 0x45	; 69
    188c:	30 e0       	ldi	r19, 0x00	; 0
    188e:	f9 01       	movw	r30, r18
    1890:	20 81       	ld	r18, Z
    1892:	27 60       	ori	r18, 0x07	; 7
    1894:	fc 01       	movw	r30, r24
    1896:	20 83       	st	Z, r18
				break;
    1898:	09 c0       	rjmp	.+18     	; 0x18ac <TIMER_init+0x5a4>
			default:/* the default case work scale 1:1 even the prescaler member not determine */
				TCCR2 |= (1 << CS20);/*CS20=1  CS21=0 CS22=0  */
    189a:	85 e4       	ldi	r24, 0x45	; 69
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	25 e4       	ldi	r18, 0x45	; 69
    18a0:	30 e0       	ldi	r19, 0x00	; 0
    18a2:	f9 01       	movw	r30, r18
    18a4:	20 81       	ld	r18, Z
    18a6:	21 60       	ori	r18, 0x01	; 1
    18a8:	fc 01       	movw	r30, r24
    18aa:	20 83       	st	Z, r18

/****************************************************
* 		2-1 compare match output mode for TIMER2	*
 * ***************************************************
					 */
			if (!strcmp(config->mode, "compare")) {
    18ac:	89 81       	ldd	r24, Y+1	; 0x01
    18ae:	9a 81       	ldd	r25, Y+2	; 0x02
    18b0:	01 96       	adiw	r24, 0x01	; 1
    18b2:	6d e7       	ldi	r22, 0x7D	; 125
    18b4:	70 e0       	ldi	r23, 0x00	; 0
    18b6:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    18ba:	89 2b       	or	r24, r25
    18bc:	09 f0       	breq	.+2      	; 0x18c0 <TIMER_init+0x5b8>
    18be:	62 c0       	rjmp	.+196    	; 0x1984 <TIMER_init+0x67c>
				/*
				 * FOC2=1 for non PWM mode
				 * select compare mode --->> WGM21=1 and WGM20=0
				 */
				TCCR2 |= (1 << FOC2) | (1 << WGM21);
    18c0:	85 e4       	ldi	r24, 0x45	; 69
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	25 e4       	ldi	r18, 0x45	; 69
    18c6:	30 e0       	ldi	r19, 0x00	; 0
    18c8:	f9 01       	movw	r30, r18
    18ca:	20 81       	ld	r18, Z
    18cc:	28 68       	ori	r18, 0x88	; 136
    18ce:	fc 01       	movw	r30, r24
    18d0:	20 83       	st	Z, r18

				if (!strcmp(config->compareMatchMode, "toggle")) {
    18d2:	89 81       	ldd	r24, Y+1	; 0x01
    18d4:	9a 81       	ldd	r25, Y+2	; 0x02
    18d6:	47 96       	adiw	r24, 0x17	; 23
    18d8:	65 e8       	ldi	r22, 0x85	; 133
    18da:	70 e0       	ldi	r23, 0x00	; 0
    18dc:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    18e0:	89 2b       	or	r24, r25
    18e2:	99 f4       	brne	.+38     	; 0x190a <TIMER_init+0x602>
					TCCR2 |= (1 << COM20);/*COM20=1 AND COM21=0 */
    18e4:	85 e4       	ldi	r24, 0x45	; 69
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	25 e4       	ldi	r18, 0x45	; 69
    18ea:	30 e0       	ldi	r19, 0x00	; 0
    18ec:	f9 01       	movw	r30, r18
    18ee:	20 81       	ld	r18, Z
    18f0:	20 61       	ori	r18, 0x10	; 16
    18f2:	fc 01       	movw	r30, r24
    18f4:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    18f6:	81 e3       	ldi	r24, 0x31	; 49
    18f8:	90 e0       	ldi	r25, 0x00	; 0
    18fa:	21 e3       	ldi	r18, 0x31	; 49
    18fc:	30 e0       	ldi	r19, 0x00	; 0
    18fe:	f9 01       	movw	r30, r18
    1900:	20 81       	ld	r18, Z
    1902:	20 68       	ori	r18, 0x80	; 128
    1904:	fc 01       	movw	r30, r24
    1906:	20 83       	st	Z, r18
    1908:	37 c0       	rjmp	.+110    	; 0x1978 <TIMER_init+0x670>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	9a 81       	ldd	r25, Y+2	; 0x02
    190e:	47 96       	adiw	r24, 0x17	; 23
    1910:	6c e8       	ldi	r22, 0x8C	; 140
    1912:	70 e0       	ldi	r23, 0x00	; 0
    1914:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1918:	89 2b       	or	r24, r25
    191a:	99 f4       	brne	.+38     	; 0x1942 <TIMER_init+0x63a>
					TCCR2 |= (1 << COM21);/*COM20=0 AND COM21=1 */
    191c:	85 e4       	ldi	r24, 0x45	; 69
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	25 e4       	ldi	r18, 0x45	; 69
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	f9 01       	movw	r30, r18
    1926:	20 81       	ld	r18, Z
    1928:	20 62       	ori	r18, 0x20	; 32
    192a:	fc 01       	movw	r30, r24
    192c:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    192e:	81 e3       	ldi	r24, 0x31	; 49
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	21 e3       	ldi	r18, 0x31	; 49
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	f9 01       	movw	r30, r18
    1938:	20 81       	ld	r18, Z
    193a:	20 68       	ori	r18, 0x80	; 128
    193c:	fc 01       	movw	r30, r24
    193e:	20 83       	st	Z, r18
    1940:	1b c0       	rjmp	.+54     	; 0x1978 <TIMER_init+0x670>

				} else if (!strcmp(config->compareMatchMode, "set")) {
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	9a 81       	ldd	r25, Y+2	; 0x02
    1946:	47 96       	adiw	r24, 0x17	; 23
    1948:	62 e9       	ldi	r22, 0x92	; 146
    194a:	70 e0       	ldi	r23, 0x00	; 0
    194c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1950:	89 2b       	or	r24, r25
    1952:	91 f4       	brne	.+36     	; 0x1978 <TIMER_init+0x670>
					TCCR2 |= (1 << COM21) | (1 << COM20);/*COM20=1 AND COM21=1 */
    1954:	85 e4       	ldi	r24, 0x45	; 69
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	25 e4       	ldi	r18, 0x45	; 69
    195a:	30 e0       	ldi	r19, 0x00	; 0
    195c:	f9 01       	movw	r30, r18
    195e:	20 81       	ld	r18, Z
    1960:	20 63       	ori	r18, 0x30	; 48
    1962:	fc 01       	movw	r30, r24
    1964:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    1966:	81 e3       	ldi	r24, 0x31	; 49
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	21 e3       	ldi	r18, 0x31	; 49
    196c:	30 e0       	ldi	r19, 0x00	; 0
    196e:	f9 01       	movw	r30, r18
    1970:	20 81       	ld	r18, Z
    1972:	20 68       	ori	r18, 0x80	; 128
    1974:	fc 01       	movw	r30, r24
    1976:	20 83       	st	Z, r18

				}
				/* the default case will be normal port operation OCO disconnected
											enable interrupt for compare mode */
				TIMSK = (1 << OCIE2);
    1978:	89 e5       	ldi	r24, 0x59	; 89
    197a:	90 e0       	ldi	r25, 0x00	; 0
    197c:	20 e8       	ldi	r18, 0x80	; 128
    197e:	fc 01       	movw	r30, r24
    1980:	20 83       	st	Z, r18
    1982:	6b c0       	rjmp	.+214    	; 0x1a5a <TIMER_init+0x752>

/****************************************************
* 		2-2 normal  mode for TIMER2		     *
 * ***************************************************
					 */
			else if (!strcmp(config->mode, "normal")) {
    1984:	89 81       	ldd	r24, Y+1	; 0x01
    1986:	9a 81       	ldd	r25, Y+2	; 0x02
    1988:	01 96       	adiw	r24, 0x01	; 1
    198a:	66 e9       	ldi	r22, 0x96	; 150
    198c:	70 e0       	ldi	r23, 0x00	; 0
    198e:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1992:	89 2b       	or	r24, r25
    1994:	79 f4       	brne	.+30     	; 0x19b4 <TIMER_init+0x6ac>
				/*
				 * FOC2=1 for non PWM mode
				 * select normal mode --->> WGM21=0 and WGM20=0
				*/
				TCCR2 |= (1 << FOC2);
    1996:	85 e4       	ldi	r24, 0x45	; 69
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	25 e4       	ldi	r18, 0x45	; 69
    199c:	30 e0       	ldi	r19, 0x00	; 0
    199e:	f9 01       	movw	r30, r18
    19a0:	20 81       	ld	r18, Z
    19a2:	20 68       	ori	r18, 0x80	; 128
    19a4:	fc 01       	movw	r30, r24
    19a6:	20 83       	st	Z, r18
				TIMSK = (1 << TOIE2); /*enable interrupt for normal mode */
    19a8:	89 e5       	ldi	r24, 0x59	; 89
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	20 e4       	ldi	r18, 0x40	; 64
    19ae:	fc 01       	movw	r30, r24
    19b0:	20 83       	st	Z, r18
    19b2:	53 c0       	rjmp	.+166    	; 0x1a5a <TIMER_init+0x752>

/****************************************************
 * 			2-3 PWM  mode for TIMER2	     *
 * ***************************************************/

			} else if (!strcmp(config->mode, "pwm")) {
    19b4:	89 81       	ldd	r24, Y+1	; 0x01
    19b6:	9a 81       	ldd	r25, Y+2	; 0x02
    19b8:	01 96       	adiw	r24, 0x01	; 1
    19ba:	6d e9       	ldi	r22, 0x9D	; 157
    19bc:	70 e0       	ldi	r23, 0x00	; 0
    19be:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    19c2:	89 2b       	or	r24, r25
    19c4:	09 f0       	breq	.+2      	; 0x19c8 <TIMER_init+0x6c0>
    19c6:	49 c0       	rjmp	.+146    	; 0x1a5a <TIMER_init+0x752>
				/*
				 * FOC2=0 for  PWM mode
				 * select PWM mode --->> WGM21=1 and WGM20=1
				 */

				TCCR2 |= (1 << WGM20) | (1 << WGM21);
    19c8:	85 e4       	ldi	r24, 0x45	; 69
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	25 e4       	ldi	r18, 0x45	; 69
    19ce:	30 e0       	ldi	r19, 0x00	; 0
    19d0:	f9 01       	movw	r30, r18
    19d2:	20 81       	ld	r18, Z
    19d4:	28 64       	ori	r18, 0x48	; 72
    19d6:	fc 01       	movw	r30, r24
    19d8:	20 83       	st	Z, r18
				if (!strcmp(config->pwmMode, "inverting")) {
    19da:	89 81       	ldd	r24, Y+1	; 0x01
    19dc:	9a 81       	ldd	r25, Y+2	; 0x02
    19de:	8b 96       	adiw	r24, 0x2b	; 43
    19e0:	61 ea       	ldi	r22, 0xA1	; 161
    19e2:	70 e0       	ldi	r23, 0x00	; 0
    19e4:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    19e8:	89 2b       	or	r24, r25
    19ea:	e1 f4       	brne	.+56     	; 0x1a24 <TIMER_init+0x71c>
					/* COM20=1 and COM21=1 */
					TCCR2 |= (1 << COM20);
    19ec:	85 e4       	ldi	r24, 0x45	; 69
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	25 e4       	ldi	r18, 0x45	; 69
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	f9 01       	movw	r30, r18
    19f6:	20 81       	ld	r18, Z
    19f8:	20 61       	ori	r18, 0x10	; 16
    19fa:	fc 01       	movw	r30, r24
    19fc:	20 83       	st	Z, r18
					TCCR2 |= (1 << COM21);
    19fe:	85 e4       	ldi	r24, 0x45	; 69
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	25 e4       	ldi	r18, 0x45	; 69
    1a04:	30 e0       	ldi	r19, 0x00	; 0
    1a06:	f9 01       	movw	r30, r18
    1a08:	20 81       	ld	r18, Z
    1a0a:	20 62       	ori	r18, 0x20	; 32
    1a0c:	fc 01       	movw	r30, r24
    1a0e:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    1a10:	81 e3       	ldi	r24, 0x31	; 49
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	21 e3       	ldi	r18, 0x31	; 49
    1a16:	30 e0       	ldi	r19, 0x00	; 0
    1a18:	f9 01       	movw	r30, r18
    1a1a:	20 81       	ld	r18, Z
    1a1c:	20 68       	ori	r18, 0x80	; 128
    1a1e:	fc 01       	movw	r30, r24
    1a20:	20 83       	st	Z, r18
    1a22:	1b c0       	rjmp	.+54     	; 0x1a5a <TIMER_init+0x752>
				} else if (!strcmp(config->pwmMode, "non-inverting")) {
    1a24:	89 81       	ldd	r24, Y+1	; 0x01
    1a26:	9a 81       	ldd	r25, Y+2	; 0x02
    1a28:	8b 96       	adiw	r24, 0x2b	; 43
    1a2a:	6b ea       	ldi	r22, 0xAB	; 171
    1a2c:	70 e0       	ldi	r23, 0x00	; 0
    1a2e:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1a32:	89 2b       	or	r24, r25
    1a34:	91 f4       	brne	.+36     	; 0x1a5a <TIMER_init+0x752>
					/* COM20=0 and COM21=1 */
					TCCR2 |= (1 << COM21);
    1a36:	85 e4       	ldi	r24, 0x45	; 69
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	25 e4       	ldi	r18, 0x45	; 69
    1a3c:	30 e0       	ldi	r19, 0x00	; 0
    1a3e:	f9 01       	movw	r30, r18
    1a40:	20 81       	ld	r18, Z
    1a42:	20 62       	ori	r18, 0x20	; 32
    1a44:	fc 01       	movw	r30, r24
    1a46:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    1a48:	81 e3       	ldi	r24, 0x31	; 49
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	21 e3       	ldi	r18, 0x31	; 49
    1a4e:	30 e0       	ldi	r19, 0x00	; 0
    1a50:	f9 01       	movw	r30, r18
    1a52:	20 81       	ld	r18, Z
    1a54:	20 68       	ori	r18, 0x80	; 128
    1a56:	fc 01       	movw	r30, r24
    1a58:	20 83       	st	Z, r18

			}

		}
		/* global interrupt enable */
		sei();
    1a5a:	78 94       	sei
	}
    1a5c:	00 00       	nop
    1a5e:	0f 90       	pop	r0
    1a60:	0f 90       	pop	r0
    1a62:	df 91       	pop	r29
    1a64:	cf 91       	pop	r28
    1a66:	08 95       	ret

00001a68 <TIMER_setCompare>:
 * 			 setting functions definition 			*
 * *******************************************************
 */

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29
    1a6c:	00 d0       	rcall	.+0      	; 0x1a6e <TIMER_setCompare+0x6>
    1a6e:	cd b7       	in	r28, 0x3d	; 61
    1a70:	de b7       	in	r29, 0x3e	; 62
    1a72:	9a 83       	std	Y+2, r25	; 0x02
    1a74:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1a76:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <configPtr>
    1a7a:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <configPtr+0x1>
    1a7e:	fc 01       	movw	r30, r24
    1a80:	80 81       	ld	r24, Z
    1a82:	88 2f       	mov	r24, r24
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	81 30       	cpi	r24, 0x01	; 1
    1a88:	91 05       	cpc	r25, r1
    1a8a:	81 f0       	breq	.+32     	; 0x1aac <TIMER_setCompare+0x44>
    1a8c:	82 30       	cpi	r24, 0x02	; 2
    1a8e:	91 05       	cpc	r25, r1
    1a90:	d1 f0       	breq	.+52     	; 0x1ac6 <TIMER_setCompare+0x5e>
    1a92:	89 2b       	or	r24, r25
    1a94:	09 f0       	breq	.+2      	; 0x1a98 <TIMER_setCompare+0x30>
	case 2:
		TCNT2 = 0;
		OCR2 = compareValue;
		break;
	}
}
    1a96:	21 c0       	rjmp	.+66     	; 0x1ada <TIMER_setCompare+0x72>

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
	switch (configPtr->timerNumber) {
	case 0:/* timer number*/
		TCNT0 = 0;/* initial value */
    1a98:	82 e5       	ldi	r24, 0x52	; 82
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	fc 01       	movw	r30, r24
    1a9e:	10 82       	st	Z, r1
		OCR0 = compareValue; /*compare value */
    1aa0:	8c e5       	ldi	r24, 0x5C	; 92
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	29 81       	ldd	r18, Y+1	; 0x01
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	20 83       	st	Z, r18
		break;
    1aaa:	17 c0       	rjmp	.+46     	; 0x1ada <TIMER_setCompare+0x72>
	case 1:
		TCNT1 = 0;
    1aac:	8c e4       	ldi	r24, 0x4C	; 76
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	fc 01       	movw	r30, r24
    1ab2:	11 82       	std	Z+1, r1	; 0x01
    1ab4:	10 82       	st	Z, r1
		OCR1A = compareValue;
    1ab6:	8a e4       	ldi	r24, 0x4A	; 74
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	29 81       	ldd	r18, Y+1	; 0x01
    1abc:	3a 81       	ldd	r19, Y+2	; 0x02
    1abe:	fc 01       	movw	r30, r24
    1ac0:	31 83       	std	Z+1, r19	; 0x01
    1ac2:	20 83       	st	Z, r18
		break;
    1ac4:	0a c0       	rjmp	.+20     	; 0x1ada <TIMER_setCompare+0x72>
	case 2:
		TCNT2 = 0;
    1ac6:	84 e4       	ldi	r24, 0x44	; 68
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	fc 01       	movw	r30, r24
    1acc:	10 82       	st	Z, r1
		OCR2 = compareValue;
    1ace:	83 e4       	ldi	r24, 0x43	; 67
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	29 81       	ldd	r18, Y+1	; 0x01
    1ad4:	fc 01       	movw	r30, r24
    1ad6:	20 83       	st	Z, r18
		break;
    1ad8:	00 00       	nop
	}
}
    1ada:	00 00       	nop
    1adc:	0f 90       	pop	r0
    1ade:	0f 90       	pop	r0
    1ae0:	df 91       	pop	r29
    1ae2:	cf 91       	pop	r28
    1ae4:	08 95       	ret

00001ae6 <TIMER_setNormal>:
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
    1ae6:	cf 93       	push	r28
    1ae8:	df 93       	push	r29
    1aea:	1f 92       	push	r1
    1aec:	cd b7       	in	r28, 0x3d	; 61
    1aee:	de b7       	in	r29, 0x3e	; 62
    1af0:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1af2:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <configPtr>
    1af6:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <configPtr+0x1>
    1afa:	fc 01       	movw	r30, r24
    1afc:	80 81       	ld	r24, Z
    1afe:	88 2f       	mov	r24, r24
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	81 30       	cpi	r24, 0x01	; 1
    1b04:	91 05       	cpc	r25, r1
    1b06:	61 f0       	breq	.+24     	; 0x1b20 <TIMER_setNormal+0x3a>
    1b08:	82 30       	cpi	r24, 0x02	; 2
    1b0a:	91 05       	cpc	r25, r1
    1b0c:	91 f0       	breq	.+36     	; 0x1b32 <TIMER_setNormal+0x4c>
    1b0e:	89 2b       	or	r24, r25
    1b10:	09 f0       	breq	.+2      	; 0x1b14 <TIMER_setNormal+0x2e>
		TCNT2 = initValue;
		break;

	}
	/* function to set duty cycle value in PWM mode */
}
    1b12:	15 c0       	rjmp	.+42     	; 0x1b3e <TIMER_setNormal+0x58>
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
	switch (configPtr->timerNumber) {
	case 0:
		TCNT0 = initValue;
    1b14:	82 e5       	ldi	r24, 0x52	; 82
    1b16:	90 e0       	ldi	r25, 0x00	; 0
    1b18:	29 81       	ldd	r18, Y+1	; 0x01
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	20 83       	st	Z, r18
		break;
    1b1e:	0f c0       	rjmp	.+30     	; 0x1b3e <TIMER_setNormal+0x58>
	case 1:
		TCNT1 = initValue;
    1b20:	8c e4       	ldi	r24, 0x4C	; 76
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	29 81       	ldd	r18, Y+1	; 0x01
    1b26:	22 2f       	mov	r18, r18
    1b28:	30 e0       	ldi	r19, 0x00	; 0
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	31 83       	std	Z+1, r19	; 0x01
    1b2e:	20 83       	st	Z, r18
		break;
    1b30:	06 c0       	rjmp	.+12     	; 0x1b3e <TIMER_setNormal+0x58>
	case 2:
		TCNT2 = initValue;
    1b32:	84 e4       	ldi	r24, 0x44	; 68
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	29 81       	ldd	r18, Y+1	; 0x01
    1b38:	fc 01       	movw	r30, r24
    1b3a:	20 83       	st	Z, r18
		break;
    1b3c:	00 00       	nop

	}
	/* function to set duty cycle value in PWM mode */
}
    1b3e:	00 00       	nop
    1b40:	0f 90       	pop	r0
    1b42:	df 91       	pop	r29
    1b44:	cf 91       	pop	r28
    1b46:	08 95       	ret

00001b48 <TIMER_setpwm>:
void TIMER_setpwm(uint8 dutyCycle) {
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
    1b4c:	1f 92       	push	r1
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62
    1b52:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1b54:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <configPtr>
    1b58:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <configPtr+0x1>
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	80 81       	ld	r24, Z
    1b60:	88 2f       	mov	r24, r24
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	81 30       	cpi	r24, 0x01	; 1
    1b66:	91 05       	cpc	r25, r1
    1b68:	81 f0       	breq	.+32     	; 0x1b8a <TIMER_setpwm+0x42>
    1b6a:	82 30       	cpi	r24, 0x02	; 2
    1b6c:	91 05       	cpc	r25, r1
    1b6e:	d9 f0       	breq	.+54     	; 0x1ba6 <TIMER_setpwm+0x5e>
    1b70:	89 2b       	or	r24, r25
    1b72:	09 f0       	breq	.+2      	; 0x1b76 <TIMER_setpwm+0x2e>
	case 2:
		TCNT2 = 0;
		OCR2 = dutyCycle;
		break;
	}
}
    1b74:	22 c0       	rjmp	.+68     	; 0x1bba <TIMER_setpwm+0x72>
}
void TIMER_setpwm(uint8 dutyCycle) {
	switch (configPtr->timerNumber) {

	case 0:
		TCNT0 = 0;
    1b76:	82 e5       	ldi	r24, 0x52	; 82
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	10 82       	st	Z, r1
		OCR0 = dutyCycle;
    1b7e:	8c e5       	ldi	r24, 0x5C	; 92
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	29 81       	ldd	r18, Y+1	; 0x01
    1b84:	fc 01       	movw	r30, r24
    1b86:	20 83       	st	Z, r18
		break;
    1b88:	18 c0       	rjmp	.+48     	; 0x1bba <TIMER_setpwm+0x72>
	case 1:
		TCNT1 = 0;
    1b8a:	8c e4       	ldi	r24, 0x4C	; 76
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	fc 01       	movw	r30, r24
    1b90:	11 82       	std	Z+1, r1	; 0x01
    1b92:	10 82       	st	Z, r1
		OCR1A = dutyCycle;
    1b94:	8a e4       	ldi	r24, 0x4A	; 74
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	29 81       	ldd	r18, Y+1	; 0x01
    1b9a:	22 2f       	mov	r18, r18
    1b9c:	30 e0       	ldi	r19, 0x00	; 0
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	31 83       	std	Z+1, r19	; 0x01
    1ba2:	20 83       	st	Z, r18
		break;
    1ba4:	0a c0       	rjmp	.+20     	; 0x1bba <TIMER_setpwm+0x72>
	case 2:
		TCNT2 = 0;
    1ba6:	84 e4       	ldi	r24, 0x44	; 68
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	fc 01       	movw	r30, r24
    1bac:	10 82       	st	Z, r1
		OCR2 = dutyCycle;
    1bae:	83 e4       	ldi	r24, 0x43	; 67
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	29 81       	ldd	r18, Y+1	; 0x01
    1bb4:	fc 01       	movw	r30, r24
    1bb6:	20 83       	st	Z, r18
		break;
    1bb8:	00 00       	nop
	}
}
    1bba:	00 00       	nop
    1bbc:	0f 90       	pop	r0
    1bbe:	df 91       	pop	r29
    1bc0:	cf 91       	pop	r28
    1bc2:	08 95       	ret

00001bc4 <TIMER_setCallBackPtr>:
/* function to get adress of call back funtion to passing it for ISR */
void TIMER_setCallBackPtr(void (*a_ptr)(void)) {
    1bc4:	cf 93       	push	r28
    1bc6:	df 93       	push	r29
    1bc8:	00 d0       	rcall	.+0      	; 0x1bca <TIMER_setCallBackPtr+0x6>
    1bca:	cd b7       	in	r28, 0x3d	; 61
    1bcc:	de b7       	in	r29, 0x3e	; 62
    1bce:	9a 83       	std	Y+2, r25	; 0x02
    1bd0:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr; /*g_callBackPtr is shared global variable */
    1bd2:	89 81       	ldd	r24, Y+1	; 0x01
    1bd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bd6:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <g_callBackPtr+0x1>
    1bda:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <g_callBackPtr>
}
    1bde:	00 00       	nop
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	df 91       	pop	r29
    1be6:	cf 91       	pop	r28
    1be8:	08 95       	ret

00001bea <TIMER_stop>:
/* function to stop the running timer */
void TIMER_stop() {
    1bea:	cf 93       	push	r28
    1bec:	df 93       	push	r29
    1bee:	cd b7       	in	r28, 0x3d	; 61
    1bf0:	de b7       	in	r29, 0x3e	; 62
	switch (configPtr->timerNumber)
    1bf2:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <configPtr>
    1bf6:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <configPtr+0x1>
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	80 81       	ld	r24, Z
    1bfe:	88 2f       	mov	r24, r24
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	81 30       	cpi	r24, 0x01	; 1
    1c04:	91 05       	cpc	r25, r1
    1c06:	81 f0       	breq	.+32     	; 0x1c28 <TIMER_stop+0x3e>
    1c08:	82 30       	cpi	r24, 0x02	; 2
    1c0a:	91 05       	cpc	r25, r1
    1c0c:	b9 f0       	breq	.+46     	; 0x1c3c <TIMER_stop+0x52>
    1c0e:	89 2b       	or	r24, r25
    1c10:	09 f0       	breq	.+2      	; 0x1c14 <TIMER_stop+0x2a>
		break;
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
		break;
	}
}
    1c12:	1e c0       	rjmp	.+60     	; 0x1c50 <TIMER_stop+0x66>
void TIMER_stop() {
	switch (configPtr->timerNumber)

	{
	case 0:
		TCCR0 &= ~(1 << CS00) & ~(1 << CS01) & ~(1 << CS02);
    1c14:	83 e5       	ldi	r24, 0x53	; 83
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	23 e5       	ldi	r18, 0x53	; 83
    1c1a:	30 e0       	ldi	r19, 0x00	; 0
    1c1c:	f9 01       	movw	r30, r18
    1c1e:	20 81       	ld	r18, Z
    1c20:	28 7f       	andi	r18, 0xF8	; 248
    1c22:	fc 01       	movw	r30, r24
    1c24:	20 83       	st	Z, r18
		break;
    1c26:	14 c0       	rjmp	.+40     	; 0x1c50 <TIMER_stop+0x66>
	case 1:
		TCCR1B &= ~(1 << CS10) & ~(1 << CS11) & ~(1 << CS12);
    1c28:	8e e4       	ldi	r24, 0x4E	; 78
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	2e e4       	ldi	r18, 0x4E	; 78
    1c2e:	30 e0       	ldi	r19, 0x00	; 0
    1c30:	f9 01       	movw	r30, r18
    1c32:	20 81       	ld	r18, Z
    1c34:	28 7f       	andi	r18, 0xF8	; 248
    1c36:	fc 01       	movw	r30, r24
    1c38:	20 83       	st	Z, r18
		break;
    1c3a:	0a c0       	rjmp	.+20     	; 0x1c50 <TIMER_stop+0x66>
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
    1c3c:	85 e4       	ldi	r24, 0x45	; 69
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	25 e4       	ldi	r18, 0x45	; 69
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	f9 01       	movw	r30, r18
    1c46:	20 81       	ld	r18, Z
    1c48:	28 7f       	andi	r18, 0xF8	; 248
    1c4a:	fc 01       	movw	r30, r24
    1c4c:	20 83       	st	Z, r18
		break;
    1c4e:	00 00       	nop
	}
}
    1c50:	00 00       	nop
    1c52:	df 91       	pop	r29
    1c54:	cf 91       	pop	r28
    1c56:	08 95       	ret

00001c58 <UART_init>:
 */

/* configurate by passing UART  configuration structure */

void UART_init(UART_configurationType * config)
{/* put zeros into all bits in the registers */
    1c58:	0f 93       	push	r16
    1c5a:	1f 93       	push	r17
    1c5c:	cf 93       	push	r28
    1c5e:	df 93       	push	r29
    1c60:	00 d0       	rcall	.+0      	; 0x1c62 <UART_init+0xa>
    1c62:	cd b7       	in	r28, 0x3d	; 61
    1c64:	de b7       	in	r29, 0x3e	; 62
    1c66:	9a 83       	std	Y+2, r25	; 0x02
    1c68:	89 83       	std	Y+1, r24	; 0x01
UCSRA=0;
    1c6a:	8b e2       	ldi	r24, 0x2B	; 43
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	fc 01       	movw	r30, r24
    1c70:	10 82       	st	Z, r1
UCSRB=0;
    1c72:	8a e2       	ldi	r24, 0x2A	; 42
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	fc 01       	movw	r30, r24
    1c78:	10 82       	st	Z, r1
UCSRC=0;
    1c7a:	80 e4       	ldi	r24, 0x40	; 64
    1c7c:	90 e0       	ldi	r25, 0x00	; 0
    1c7e:	fc 01       	movw	r30, r24
    1c80:	10 82       	st	Z, r1
/* enables */
	if(!strcmp(config->mode,"normal"))
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	05 96       	adiw	r24, 0x05	; 5
    1c88:	69 eb       	ldi	r22, 0xB9	; 185
    1c8a:	70 e0       	ldi	r23, 0x00	; 0
    1c8c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1c90:	89 2b       	or	r24, r25
    1c92:	09 f0       	breq	.+2      	; 0x1c96 <UART_init+0x3e>
    1c94:	60 c0       	rjmp	.+192    	; 0x1d56 <UART_init+0xfe>
	{
CLEAR_BIT(UCSRA,U2X); /* disable double speed bit */
    1c96:	8b e2       	ldi	r24, 0x2B	; 43
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	2b e2       	ldi	r18, 0x2B	; 43
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	f9 01       	movw	r30, r18
    1ca0:	20 81       	ld	r18, Z
    1ca2:	2d 7f       	andi	r18, 0xFD	; 253
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	20 83       	st	Z, r18
/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
UBRRL=((F_CPU /(16*config->buadRate))-1);
    1ca8:	09 e2       	ldi	r16, 0x29	; 41
    1caa:	10 e0       	ldi	r17, 0x00	; 0
    1cac:	89 81       	ldd	r24, Y+1	; 0x01
    1cae:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb0:	fc 01       	movw	r30, r24
    1cb2:	81 81       	ldd	r24, Z+1	; 0x01
    1cb4:	92 81       	ldd	r25, Z+2	; 0x02
    1cb6:	a3 81       	ldd	r26, Z+3	; 0x03
    1cb8:	b4 81       	ldd	r27, Z+4	; 0x04
    1cba:	88 0f       	add	r24, r24
    1cbc:	99 1f       	adc	r25, r25
    1cbe:	aa 1f       	adc	r26, r26
    1cc0:	bb 1f       	adc	r27, r27
    1cc2:	88 0f       	add	r24, r24
    1cc4:	99 1f       	adc	r25, r25
    1cc6:	aa 1f       	adc	r26, r26
    1cc8:	bb 1f       	adc	r27, r27
    1cca:	88 0f       	add	r24, r24
    1ccc:	99 1f       	adc	r25, r25
    1cce:	aa 1f       	adc	r26, r26
    1cd0:	bb 1f       	adc	r27, r27
    1cd2:	88 0f       	add	r24, r24
    1cd4:	99 1f       	adc	r25, r25
    1cd6:	aa 1f       	adc	r26, r26
    1cd8:	bb 1f       	adc	r27, r27
    1cda:	9c 01       	movw	r18, r24
    1cdc:	ad 01       	movw	r20, r26
    1cde:	80 e0       	ldi	r24, 0x00	; 0
    1ce0:	92 e1       	ldi	r25, 0x12	; 18
    1ce2:	aa e7       	ldi	r26, 0x7A	; 122
    1ce4:	b0 e0       	ldi	r27, 0x00	; 0
    1ce6:	bc 01       	movw	r22, r24
    1ce8:	cd 01       	movw	r24, r26
    1cea:	0e 94 b8 10 	call	0x2170	; 0x2170 <__udivmodsi4>
    1cee:	da 01       	movw	r26, r20
    1cf0:	c9 01       	movw	r24, r18
    1cf2:	81 50       	subi	r24, 0x01	; 1
    1cf4:	f8 01       	movw	r30, r16
    1cf6:	80 83       	st	Z, r24
UBRRH=((F_CPU /(16*config->buadRate))-1)>>8;
    1cf8:	00 e4       	ldi	r16, 0x40	; 64
    1cfa:	10 e0       	ldi	r17, 0x00	; 0
    1cfc:	89 81       	ldd	r24, Y+1	; 0x01
    1cfe:	9a 81       	ldd	r25, Y+2	; 0x02
    1d00:	fc 01       	movw	r30, r24
    1d02:	81 81       	ldd	r24, Z+1	; 0x01
    1d04:	92 81       	ldd	r25, Z+2	; 0x02
    1d06:	a3 81       	ldd	r26, Z+3	; 0x03
    1d08:	b4 81       	ldd	r27, Z+4	; 0x04
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	aa 1f       	adc	r26, r26
    1d10:	bb 1f       	adc	r27, r27
    1d12:	88 0f       	add	r24, r24
    1d14:	99 1f       	adc	r25, r25
    1d16:	aa 1f       	adc	r26, r26
    1d18:	bb 1f       	adc	r27, r27
    1d1a:	88 0f       	add	r24, r24
    1d1c:	99 1f       	adc	r25, r25
    1d1e:	aa 1f       	adc	r26, r26
    1d20:	bb 1f       	adc	r27, r27
    1d22:	88 0f       	add	r24, r24
    1d24:	99 1f       	adc	r25, r25
    1d26:	aa 1f       	adc	r26, r26
    1d28:	bb 1f       	adc	r27, r27
    1d2a:	9c 01       	movw	r18, r24
    1d2c:	ad 01       	movw	r20, r26
    1d2e:	80 e0       	ldi	r24, 0x00	; 0
    1d30:	92 e1       	ldi	r25, 0x12	; 18
    1d32:	aa e7       	ldi	r26, 0x7A	; 122
    1d34:	b0 e0       	ldi	r27, 0x00	; 0
    1d36:	bc 01       	movw	r22, r24
    1d38:	cd 01       	movw	r24, r26
    1d3a:	0e 94 b8 10 	call	0x2170	; 0x2170 <__udivmodsi4>
    1d3e:	da 01       	movw	r26, r20
    1d40:	c9 01       	movw	r24, r18
    1d42:	01 97       	sbiw	r24, 0x01	; 1
    1d44:	a1 09       	sbc	r26, r1
    1d46:	b1 09       	sbc	r27, r1
    1d48:	89 2f       	mov	r24, r25
    1d4a:	9a 2f       	mov	r25, r26
    1d4c:	ab 2f       	mov	r26, r27
    1d4e:	bb 27       	eor	r27, r27
    1d50:	f8 01       	movw	r30, r16
    1d52:	80 83       	st	Z, r24
    1d54:	61 c0       	rjmp	.+194    	; 0x1e18 <UART_init+0x1c0>


	}
	else if(!strcmp(config->mode,"double speed"))
    1d56:	89 81       	ldd	r24, Y+1	; 0x01
    1d58:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5a:	05 96       	adiw	r24, 0x05	; 5
    1d5c:	60 ec       	ldi	r22, 0xC0	; 192
    1d5e:	70 e0       	ldi	r23, 0x00	; 0
    1d60:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1d64:	89 2b       	or	r24, r25
    1d66:	09 f0       	breq	.+2      	; 0x1d6a <UART_init+0x112>
    1d68:	57 c0       	rjmp	.+174    	; 0x1e18 <UART_init+0x1c0>
	{
		SET_BIT(UCSRA,U2X);/* enable double speed bit */
    1d6a:	8b e2       	ldi	r24, 0x2B	; 43
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	2b e2       	ldi	r18, 0x2B	; 43
    1d70:	30 e0       	ldi	r19, 0x00	; 0
    1d72:	f9 01       	movw	r30, r18
    1d74:	20 81       	ld	r18, Z
    1d76:	22 60       	ori	r18, 0x02	; 2
    1d78:	fc 01       	movw	r30, r24
    1d7a:	20 83       	st	Z, r18
		/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
		UBRRL=((F_CPU /(8*config->buadRate))-1);
    1d7c:	09 e2       	ldi	r16, 0x29	; 41
    1d7e:	10 e0       	ldi	r17, 0x00	; 0
    1d80:	89 81       	ldd	r24, Y+1	; 0x01
    1d82:	9a 81       	ldd	r25, Y+2	; 0x02
    1d84:	fc 01       	movw	r30, r24
    1d86:	81 81       	ldd	r24, Z+1	; 0x01
    1d88:	92 81       	ldd	r25, Z+2	; 0x02
    1d8a:	a3 81       	ldd	r26, Z+3	; 0x03
    1d8c:	b4 81       	ldd	r27, Z+4	; 0x04
    1d8e:	88 0f       	add	r24, r24
    1d90:	99 1f       	adc	r25, r25
    1d92:	aa 1f       	adc	r26, r26
    1d94:	bb 1f       	adc	r27, r27
    1d96:	88 0f       	add	r24, r24
    1d98:	99 1f       	adc	r25, r25
    1d9a:	aa 1f       	adc	r26, r26
    1d9c:	bb 1f       	adc	r27, r27
    1d9e:	88 0f       	add	r24, r24
    1da0:	99 1f       	adc	r25, r25
    1da2:	aa 1f       	adc	r26, r26
    1da4:	bb 1f       	adc	r27, r27
    1da6:	9c 01       	movw	r18, r24
    1da8:	ad 01       	movw	r20, r26
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	92 e1       	ldi	r25, 0x12	; 18
    1dae:	aa e7       	ldi	r26, 0x7A	; 122
    1db0:	b0 e0       	ldi	r27, 0x00	; 0
    1db2:	bc 01       	movw	r22, r24
    1db4:	cd 01       	movw	r24, r26
    1db6:	0e 94 b8 10 	call	0x2170	; 0x2170 <__udivmodsi4>
    1dba:	da 01       	movw	r26, r20
    1dbc:	c9 01       	movw	r24, r18
    1dbe:	81 50       	subi	r24, 0x01	; 1
    1dc0:	f8 01       	movw	r30, r16
    1dc2:	80 83       	st	Z, r24
		UBRRH=((F_CPU /(8*config->buadRate))-1)>>8;
    1dc4:	00 e4       	ldi	r16, 0x40	; 64
    1dc6:	10 e0       	ldi	r17, 0x00	; 0
    1dc8:	89 81       	ldd	r24, Y+1	; 0x01
    1dca:	9a 81       	ldd	r25, Y+2	; 0x02
    1dcc:	fc 01       	movw	r30, r24
    1dce:	81 81       	ldd	r24, Z+1	; 0x01
    1dd0:	92 81       	ldd	r25, Z+2	; 0x02
    1dd2:	a3 81       	ldd	r26, Z+3	; 0x03
    1dd4:	b4 81       	ldd	r27, Z+4	; 0x04
    1dd6:	88 0f       	add	r24, r24
    1dd8:	99 1f       	adc	r25, r25
    1dda:	aa 1f       	adc	r26, r26
    1ddc:	bb 1f       	adc	r27, r27
    1dde:	88 0f       	add	r24, r24
    1de0:	99 1f       	adc	r25, r25
    1de2:	aa 1f       	adc	r26, r26
    1de4:	bb 1f       	adc	r27, r27
    1de6:	88 0f       	add	r24, r24
    1de8:	99 1f       	adc	r25, r25
    1dea:	aa 1f       	adc	r26, r26
    1dec:	bb 1f       	adc	r27, r27
    1dee:	9c 01       	movw	r18, r24
    1df0:	ad 01       	movw	r20, r26
    1df2:	80 e0       	ldi	r24, 0x00	; 0
    1df4:	92 e1       	ldi	r25, 0x12	; 18
    1df6:	aa e7       	ldi	r26, 0x7A	; 122
    1df8:	b0 e0       	ldi	r27, 0x00	; 0
    1dfa:	bc 01       	movw	r22, r24
    1dfc:	cd 01       	movw	r24, r26
    1dfe:	0e 94 b8 10 	call	0x2170	; 0x2170 <__udivmodsi4>
    1e02:	da 01       	movw	r26, r20
    1e04:	c9 01       	movw	r24, r18
    1e06:	01 97       	sbiw	r24, 0x01	; 1
    1e08:	a1 09       	sbc	r26, r1
    1e0a:	b1 09       	sbc	r27, r1
    1e0c:	89 2f       	mov	r24, r25
    1e0e:	9a 2f       	mov	r25, r26
    1e10:	ab 2f       	mov	r26, r27
    1e12:	bb 27       	eor	r27, r27
    1e14:	f8 01       	movw	r30, r16
    1e16:	80 83       	st	Z, r24

	}


/* TO enable writing on Register UCSRC (used for define the frame )as it has the same address with UBRR register */
SET_BIT(UCSRC,URSEL);
    1e18:	80 e4       	ldi	r24, 0x40	; 64
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	20 e4       	ldi	r18, 0x40	; 64
    1e1e:	30 e0       	ldi	r19, 0x00	; 0
    1e20:	f9 01       	movw	r30, r18
    1e22:	20 81       	ld	r18, Z
    1e24:	20 68       	ori	r18, 0x80	; 128
    1e26:	fc 01       	movw	r30, r24
    1e28:	20 83       	st	Z, r18
/* the UART frame parameters*/
/* character size */

switch(config->character_size)
    1e2a:	89 81       	ldd	r24, Y+1	; 0x01
    1e2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e2e:	fc 01       	movw	r30, r24
    1e30:	80 81       	ld	r24, Z
    1e32:	88 2f       	mov	r24, r24
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	86 30       	cpi	r24, 0x06	; 6
    1e38:	91 05       	cpc	r25, r1
    1e3a:	f9 f0       	breq	.+62     	; 0x1e7a <UART_init+0x222>
    1e3c:	87 30       	cpi	r24, 0x07	; 7
    1e3e:	91 05       	cpc	r25, r1
    1e40:	1c f4       	brge	.+6      	; 0x1e48 <UART_init+0x1f0>
    1e42:	05 97       	sbiw	r24, 0x05	; 5
    1e44:	39 f0       	breq	.+14     	; 0x1e54 <UART_init+0x1fc>
    1e46:	5b c0       	rjmp	.+182    	; 0x1efe <UART_init+0x2a6>
    1e48:	87 30       	cpi	r24, 0x07	; 7
    1e4a:	91 05       	cpc	r25, r1
    1e4c:	49 f1       	breq	.+82     	; 0x1ea0 <UART_init+0x248>
    1e4e:	09 97       	sbiw	r24, 0x09	; 9
    1e50:	d1 f1       	breq	.+116    	; 0x1ec6 <UART_init+0x26e>
    1e52:	55 c0       	rjmp	.+170    	; 0x1efe <UART_init+0x2a6>
{
case 5:
	/* UCSZ0 =0, UCSZ1=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e54:	80 e4       	ldi	r24, 0x40	; 64
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	20 e4       	ldi	r18, 0x40	; 64
    1e5a:	30 e0       	ldi	r19, 0x00	; 0
    1e5c:	f9 01       	movw	r30, r18
    1e5e:	20 81       	ld	r18, Z
    1e60:	2d 7f       	andi	r18, 0xFD	; 253
    1e62:	fc 01       	movw	r30, r24
    1e64:	20 83       	st	Z, r18
	CLEAR_BIT(UCSRC,UCSZ1);
    1e66:	80 e4       	ldi	r24, 0x40	; 64
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	20 e4       	ldi	r18, 0x40	; 64
    1e6c:	30 e0       	ldi	r19, 0x00	; 0
    1e6e:	f9 01       	movw	r30, r18
    1e70:	20 81       	ld	r18, Z
    1e72:	2b 7f       	andi	r18, 0xFB	; 251
    1e74:	fc 01       	movw	r30, r24
    1e76:	20 83       	st	Z, r18
	break;
    1e78:	54 c0       	rjmp	.+168    	; 0x1f22 <UART_init+0x2ca>

case 6:
	/* UCSZ0 =0, UCSZ1=1,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e7a:	80 e4       	ldi	r24, 0x40	; 64
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	20 e4       	ldi	r18, 0x40	; 64
    1e80:	30 e0       	ldi	r19, 0x00	; 0
    1e82:	f9 01       	movw	r30, r18
    1e84:	20 81       	ld	r18, Z
    1e86:	2d 7f       	andi	r18, 0xFD	; 253
    1e88:	fc 01       	movw	r30, r24
    1e8a:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1e8c:	80 e4       	ldi	r24, 0x40	; 64
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	20 e4       	ldi	r18, 0x40	; 64
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	f9 01       	movw	r30, r18
    1e96:	20 81       	ld	r18, Z
    1e98:	24 60       	ori	r18, 0x04	; 4
    1e9a:	fc 01       	movw	r30, r24
    1e9c:	20 83       	st	Z, r18
	break;
    1e9e:	41 c0       	rjmp	.+130    	; 0x1f22 <UART_init+0x2ca>
case 7:
	/* UCSZ0 =1, UCSZ=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ1);
    1ea0:	80 e4       	ldi	r24, 0x40	; 64
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	20 e4       	ldi	r18, 0x40	; 64
    1ea6:	30 e0       	ldi	r19, 0x00	; 0
    1ea8:	f9 01       	movw	r30, r18
    1eaa:	20 81       	ld	r18, Z
    1eac:	2b 7f       	andi	r18, 0xFB	; 251
    1eae:	fc 01       	movw	r30, r24
    1eb0:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ0);
    1eb2:	80 e4       	ldi	r24, 0x40	; 64
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	20 e4       	ldi	r18, 0x40	; 64
    1eb8:	30 e0       	ldi	r19, 0x00	; 0
    1eba:	f9 01       	movw	r30, r18
    1ebc:	20 81       	ld	r18, Z
    1ebe:	22 60       	ori	r18, 0x02	; 2
    1ec0:	fc 01       	movw	r30, r24
    1ec2:	20 83       	st	Z, r18
		break;
    1ec4:	2e c0       	rjmp	.+92     	; 0x1f22 <UART_init+0x2ca>
case 9:
	/* UCSZ0 =1, UCSZ1=0,UCSZ2=1 */
	SET_BIT(UCSRC,UCSZ0);
    1ec6:	80 e4       	ldi	r24, 0x40	; 64
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	20 e4       	ldi	r18, 0x40	; 64
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	f9 01       	movw	r30, r18
    1ed0:	20 81       	ld	r18, Z
    1ed2:	22 60       	ori	r18, 0x02	; 2
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1ed8:	80 e4       	ldi	r24, 0x40	; 64
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	20 e4       	ldi	r18, 0x40	; 64
    1ede:	30 e0       	ldi	r19, 0x00	; 0
    1ee0:	f9 01       	movw	r30, r18
    1ee2:	20 81       	ld	r18, Z
    1ee4:	24 60       	ori	r18, 0x04	; 4
    1ee6:	fc 01       	movw	r30, r24
    1ee8:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ2);
    1eea:	80 e4       	ldi	r24, 0x40	; 64
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	20 e4       	ldi	r18, 0x40	; 64
    1ef0:	30 e0       	ldi	r19, 0x00	; 0
    1ef2:	f9 01       	movw	r30, r18
    1ef4:	20 81       	ld	r18, Z
    1ef6:	24 60       	ori	r18, 0x04	; 4
    1ef8:	fc 01       	movw	r30, r24
    1efa:	20 83       	st	Z, r18


	break;
    1efc:	12 c0       	rjmp	.+36     	; 0x1f22 <UART_init+0x2ca>

default :
	/* the default will be 8bits */
	/* UCSZ0 =1, UCSZ1=1,UCSZ2=0 */
	SET_BIT(UCSRC,UCSZ0);
    1efe:	80 e4       	ldi	r24, 0x40	; 64
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	20 e4       	ldi	r18, 0x40	; 64
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	f9 01       	movw	r30, r18
    1f08:	20 81       	ld	r18, Z
    1f0a:	22 60       	ori	r18, 0x02	; 2
    1f0c:	fc 01       	movw	r30, r24
    1f0e:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1f10:	80 e4       	ldi	r24, 0x40	; 64
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	20 e4       	ldi	r18, 0x40	; 64
    1f16:	30 e0       	ldi	r19, 0x00	; 0
    1f18:	f9 01       	movw	r30, r18
    1f1a:	20 81       	ld	r18, Z
    1f1c:	24 60       	ori	r18, 0x04	; 4
    1f1e:	fc 01       	movw	r30, r24
    1f20:	20 83       	st	Z, r18
}
switch(config->stop_bit_number)
    1f22:	89 81       	ldd	r24, Y+1	; 0x01
    1f24:	9a 81       	ldd	r25, Y+2	; 0x02
    1f26:	fc 01       	movw	r30, r24
    1f28:	85 a5       	ldd	r24, Z+45	; 0x2d
    1f2a:	88 2f       	mov	r24, r24
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	02 97       	sbiw	r24, 0x02	; 2
    1f30:	51 f0       	breq	.+20     	; 0x1f46 <UART_init+0x2ee>
{
default : /* STOP BIT =1 */
	SET_BIT(UCSRC,USBS);
    1f32:	80 e4       	ldi	r24, 0x40	; 64
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	20 e4       	ldi	r18, 0x40	; 64
    1f38:	30 e0       	ldi	r19, 0x00	; 0
    1f3a:	f9 01       	movw	r30, r18
    1f3c:	20 81       	ld	r18, Z
    1f3e:	28 60       	ori	r18, 0x08	; 8
    1f40:	fc 01       	movw	r30, r24
    1f42:	20 83       	st	Z, r18
	break;
    1f44:	0a c0       	rjmp	.+20     	; 0x1f5a <UART_init+0x302>
case 2 : /* STOP BIT =2 */
	CLEAR_BIT(UCSRC,USBS);
    1f46:	80 e4       	ldi	r24, 0x40	; 64
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	20 e4       	ldi	r18, 0x40	; 64
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	f9 01       	movw	r30, r18
    1f50:	20 81       	ld	r18, Z
    1f52:	27 7f       	andi	r18, 0xF7	; 247
    1f54:	fc 01       	movw	r30, r24
    1f56:	20 83       	st	Z, r18
	break;
    1f58:	00 00       	nop

}
if(!strcmp(config->parity,"odd"))
    1f5a:	89 81       	ldd	r24, Y+1	; 0x01
    1f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f5e:	49 96       	adiw	r24, 0x19	; 25
    1f60:	6d ec       	ldi	r22, 0xCD	; 205
    1f62:	70 e0       	ldi	r23, 0x00	; 0
    1f64:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1f68:	89 2b       	or	r24, r25
    1f6a:	99 f4       	brne	.+38     	; 0x1f92 <UART_init+0x33a>
		{
		SET_BIT(UCSRC,UPM0);
    1f6c:	80 e4       	ldi	r24, 0x40	; 64
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	20 e4       	ldi	r18, 0x40	; 64
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	f9 01       	movw	r30, r18
    1f76:	20 81       	ld	r18, Z
    1f78:	20 61       	ori	r18, 0x10	; 16
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	20 83       	st	Z, r18
		SET_BIT(UCSRC,UPM1);
    1f7e:	80 e4       	ldi	r24, 0x40	; 64
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	20 e4       	ldi	r18, 0x40	; 64
    1f84:	30 e0       	ldi	r19, 0x00	; 0
    1f86:	f9 01       	movw	r30, r18
    1f88:	20 81       	ld	r18, Z
    1f8a:	20 62       	ori	r18, 0x20	; 32
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	20 83       	st	Z, r18
    1f90:	2e c0       	rjmp	.+92     	; 0x1fee <UART_init+0x396>
		}
else if(!strcmp(config->parity,"even"))
    1f92:	89 81       	ldd	r24, Y+1	; 0x01
    1f94:	9a 81       	ldd	r25, Y+2	; 0x02
    1f96:	49 96       	adiw	r24, 0x19	; 25
    1f98:	61 ed       	ldi	r22, 0xD1	; 209
    1f9a:	70 e0       	ldi	r23, 0x00	; 0
    1f9c:	0e 94 96 14 	call	0x292c	; 0x292c <strcmp>
    1fa0:	89 2b       	or	r24, r25
    1fa2:	99 f4       	brne	.+38     	; 0x1fca <UART_init+0x372>
		{
		SET_BIT(UCSRC,UPM0);
    1fa4:	80 e4       	ldi	r24, 0x40	; 64
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	20 e4       	ldi	r18, 0x40	; 64
    1faa:	30 e0       	ldi	r19, 0x00	; 0
    1fac:	f9 01       	movw	r30, r18
    1fae:	20 81       	ld	r18, Z
    1fb0:	20 61       	ori	r18, 0x10	; 16
    1fb2:	fc 01       	movw	r30, r24
    1fb4:	20 83       	st	Z, r18
		CLEAR_BIT(UCSRC,UPM1);
    1fb6:	80 e4       	ldi	r24, 0x40	; 64
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	20 e4       	ldi	r18, 0x40	; 64
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	f9 01       	movw	r30, r18
    1fc0:	20 81       	ld	r18, Z
    1fc2:	2f 7d       	andi	r18, 0xDF	; 223
    1fc4:	fc 01       	movw	r30, r24
    1fc6:	20 83       	st	Z, r18
    1fc8:	12 c0       	rjmp	.+36     	; 0x1fee <UART_init+0x396>
		}
else
{
	CLEAR_BIT(UCSRC,UPM0);
    1fca:	80 e4       	ldi	r24, 0x40	; 64
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	20 e4       	ldi	r18, 0x40	; 64
    1fd0:	30 e0       	ldi	r19, 0x00	; 0
    1fd2:	f9 01       	movw	r30, r18
    1fd4:	20 81       	ld	r18, Z
    1fd6:	2f 7e       	andi	r18, 0xEF	; 239
    1fd8:	fc 01       	movw	r30, r24
    1fda:	20 83       	st	Z, r18
	CLEAR_BIT(UCSRC,UPM1);
    1fdc:	80 e4       	ldi	r24, 0x40	; 64
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	20 e4       	ldi	r18, 0x40	; 64
    1fe2:	30 e0       	ldi	r19, 0x00	; 0
    1fe4:	f9 01       	movw	r30, r18
    1fe6:	20 81       	ld	r18, Z
    1fe8:	2f 7d       	andi	r18, 0xDF	; 223
    1fea:	fc 01       	movw	r30, r24
    1fec:	20 83       	st	Z, r18
}
/* enable uart receive and transmit */
SET_BIT(UCSRB,RXEN);
    1fee:	8a e2       	ldi	r24, 0x2A	; 42
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	2a e2       	ldi	r18, 0x2A	; 42
    1ff4:	30 e0       	ldi	r19, 0x00	; 0
    1ff6:	f9 01       	movw	r30, r18
    1ff8:	20 81       	ld	r18, Z
    1ffa:	20 61       	ori	r18, 0x10	; 16
    1ffc:	fc 01       	movw	r30, r24
    1ffe:	20 83       	st	Z, r18
SET_BIT(UCSRB,TXEN);
    2000:	8a e2       	ldi	r24, 0x2A	; 42
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	2a e2       	ldi	r18, 0x2A	; 42
    2006:	30 e0       	ldi	r19, 0x00	; 0
    2008:	f9 01       	movw	r30, r18
    200a:	20 81       	ld	r18, Z
    200c:	28 60       	ori	r18, 0x08	; 8
    200e:	fc 01       	movw	r30, r24
    2010:	20 83       	st	Z, r18
}
    2012:	00 00       	nop
    2014:	0f 90       	pop	r0
    2016:	0f 90       	pop	r0
    2018:	df 91       	pop	r29
    201a:	cf 91       	pop	r28
    201c:	1f 91       	pop	r17
    201e:	0f 91       	pop	r16
    2020:	08 95       	ret

00002022 <UART_receiveByte>:

uint8 UART_receiveByte(void)
{
    2022:	cf 93       	push	r28
    2024:	df 93       	push	r29
    2026:	cd b7       	in	r28, 0x3d	; 61
    2028:	de b7       	in	r29, 0x3e	; 62
	while(BIT_IS_CLEAR(UCSRA,RXC)); /* wait until RXC  flag be 1 it means that there is data not read */
    202a:	00 00       	nop
    202c:	8b e2       	ldi	r24, 0x2B	; 43
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	fc 01       	movw	r30, r24
    2032:	80 81       	ld	r24, Z
    2034:	88 23       	and	r24, r24
    2036:	d4 f7       	brge	.-12     	; 0x202c <UART_receiveByte+0xa>

	return UDR;/* read and return RXC flag to zero */
    2038:	8c e2       	ldi	r24, 0x2C	; 44
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	fc 01       	movw	r30, r24
    203e:	80 81       	ld	r24, Z
}
    2040:	df 91       	pop	r29
    2042:	cf 91       	pop	r28
    2044:	08 95       	ret

00002046 <UART_sendByte>:
void UART_sendByte(const uint8 data)
{
    2046:	cf 93       	push	r28
    2048:	df 93       	push	r29
    204a:	1f 92       	push	r1
    204c:	cd b7       	in	r28, 0x3d	; 61
    204e:	de b7       	in	r29, 0x3e	; 62
    2050:	89 83       	std	Y+1, r24	; 0x01
	UDR=data; /*store data in shift register UDR from less significant bit */
    2052:	8c e2       	ldi	r24, 0x2C	; 44
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	29 81       	ldd	r18, Y+1	; 0x01
    2058:	fc 01       	movw	r30, r24
    205a:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(UCSRA,TXC));/*wait until send data txc =1*/
    205c:	00 00       	nop
    205e:	8b e2       	ldi	r24, 0x2B	; 43
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	fc 01       	movw	r30, r24
    2064:	80 81       	ld	r24, Z
    2066:	88 2f       	mov	r24, r24
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	80 74       	andi	r24, 0x40	; 64
    206c:	99 27       	eor	r25, r25
    206e:	89 2b       	or	r24, r25
    2070:	b1 f3       	breq	.-20     	; 0x205e <UART_sendByte+0x18>
	SET_BIT(UCSRA,TXC); /*clear the flag as it doesnt clear automatically as no interrupt or ISR*/
    2072:	8b e2       	ldi	r24, 0x2B	; 43
    2074:	90 e0       	ldi	r25, 0x00	; 0
    2076:	2b e2       	ldi	r18, 0x2B	; 43
    2078:	30 e0       	ldi	r19, 0x00	; 0
    207a:	f9 01       	movw	r30, r18
    207c:	20 81       	ld	r18, Z
    207e:	20 64       	ori	r18, 0x40	; 64
    2080:	fc 01       	movw	r30, r24
    2082:	20 83       	st	Z, r18

}
    2084:	00 00       	nop
    2086:	0f 90       	pop	r0
    2088:	df 91       	pop	r29
    208a:	cf 91       	pop	r28
    208c:	08 95       	ret

0000208e <UART_sendString>:
void UART_sendString(uint8 *str)
{
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
    2092:	00 d0       	rcall	.+0      	; 0x2094 <UART_sendString+0x6>
    2094:	1f 92       	push	r1
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
    209a:	9b 83       	std	Y+3, r25	; 0x03
    209c:	8a 83       	std	Y+2, r24	; 0x02
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
    209e:	19 82       	std	Y+1, r1	; 0x01
		while(str[i] != '\0')
    20a0:	0e c0       	rjmp	.+28     	; 0x20be <UART_sendString+0x30>
		{
			UART_sendByte(str[i]);
    20a2:	89 81       	ldd	r24, Y+1	; 0x01
    20a4:	88 2f       	mov	r24, r24
    20a6:	90 e0       	ldi	r25, 0x00	; 0
    20a8:	2a 81       	ldd	r18, Y+2	; 0x02
    20aa:	3b 81       	ldd	r19, Y+3	; 0x03
    20ac:	82 0f       	add	r24, r18
    20ae:	93 1f       	adc	r25, r19
    20b0:	fc 01       	movw	r30, r24
    20b2:	80 81       	ld	r24, Z
    20b4:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>
			i++;
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	8f 5f       	subi	r24, 0xFF	; 255
    20bc:	89 83       	std	Y+1, r24	; 0x01
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
		while(str[i] != '\0')
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	88 2f       	mov	r24, r24
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	2a 81       	ldd	r18, Y+2	; 0x02
    20c6:	3b 81       	ldd	r19, Y+3	; 0x03
    20c8:	82 0f       	add	r24, r18
    20ca:	93 1f       	adc	r25, r19
    20cc:	fc 01       	movw	r30, r24
    20ce:	80 81       	ld	r24, Z
    20d0:	88 23       	and	r24, r24
    20d2:	39 f7       	brne	.-50     	; 0x20a2 <UART_sendString+0x14>
		{
			UART_sendByte(str[i]);
			i++;
		}
	UART_sendByte('#');
    20d4:	83 e2       	ldi	r24, 0x23	; 35
    20d6:	0e 94 23 10 	call	0x2046	; 0x2046 <UART_sendByte>

}
    20da:	00 00       	nop
    20dc:	0f 90       	pop	r0
    20de:	0f 90       	pop	r0
    20e0:	0f 90       	pop	r0
    20e2:	df 91       	pop	r29
    20e4:	cf 91       	pop	r28
    20e6:	08 95       	ret

000020e8 <UART_receiveString>:
void UART_receiveString(uint8 *str)
{ /*
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	00 d0       	rcall	.+0      	; 0x20f2 <UART_receiveString+0xa>
    20f2:	1f 92       	push	r1
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
    20f8:	9b 83       	std	Y+3, r25	; 0x03
    20fa:	8a 83       	std	Y+2, r24	; 0x02
at first receive first byte then check the  pre define pattern # may be empty string ""
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
    20fc:	19 82       	std	Y+1, r1	; 0x01
		str[i] = UART_receiveByte();
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	88 2f       	mov	r24, r24
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	2a 81       	ldd	r18, Y+2	; 0x02
    2106:	3b 81       	ldd	r19, Y+3	; 0x03
    2108:	89 01       	movw	r16, r18
    210a:	08 0f       	add	r16, r24
    210c:	19 1f       	adc	r17, r25
    210e:	0e 94 11 10 	call	0x2022	; 0x2022 <UART_receiveByte>
    2112:	f8 01       	movw	r30, r16
    2114:	80 83       	st	Z, r24
		while(str[i] != '#')
    2116:	0f c0       	rjmp	.+30     	; 0x2136 <UART_receiveString+0x4e>
		{
			i++;
    2118:	89 81       	ldd	r24, Y+1	; 0x01
    211a:	8f 5f       	subi	r24, 0xFF	; 255
    211c:	89 83       	std	Y+1, r24	; 0x01
			str[i] = UART_receiveByte();
    211e:	89 81       	ldd	r24, Y+1	; 0x01
    2120:	88 2f       	mov	r24, r24
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	2a 81       	ldd	r18, Y+2	; 0x02
    2126:	3b 81       	ldd	r19, Y+3	; 0x03
    2128:	89 01       	movw	r16, r18
    212a:	08 0f       	add	r16, r24
    212c:	19 1f       	adc	r17, r25
    212e:	0e 94 11 10 	call	0x2022	; 0x2022 <UART_receiveByte>
    2132:	f8 01       	movw	r30, r16
    2134:	80 83       	st	Z, r24
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
		str[i] = UART_receiveByte();
		while(str[i] != '#')
    2136:	89 81       	ldd	r24, Y+1	; 0x01
    2138:	88 2f       	mov	r24, r24
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	2a 81       	ldd	r18, Y+2	; 0x02
    213e:	3b 81       	ldd	r19, Y+3	; 0x03
    2140:	82 0f       	add	r24, r18
    2142:	93 1f       	adc	r25, r19
    2144:	fc 01       	movw	r30, r24
    2146:	80 81       	ld	r24, Z
    2148:	83 32       	cpi	r24, 0x23	; 35
    214a:	31 f7       	brne	.-52     	; 0x2118 <UART_receiveString+0x30>
		{
			i++;
			str[i] = UART_receiveByte();
		}
		str[i] = '\0';
    214c:	89 81       	ldd	r24, Y+1	; 0x01
    214e:	88 2f       	mov	r24, r24
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	2a 81       	ldd	r18, Y+2	; 0x02
    2154:	3b 81       	ldd	r19, Y+3	; 0x03
    2156:	82 0f       	add	r24, r18
    2158:	93 1f       	adc	r25, r19
    215a:	fc 01       	movw	r30, r24
    215c:	10 82       	st	Z, r1
}
    215e:	00 00       	nop
    2160:	0f 90       	pop	r0
    2162:	0f 90       	pop	r0
    2164:	0f 90       	pop	r0
    2166:	df 91       	pop	r29
    2168:	cf 91       	pop	r28
    216a:	1f 91       	pop	r17
    216c:	0f 91       	pop	r16
    216e:	08 95       	ret

00002170 <__udivmodsi4>:
    2170:	a1 e2       	ldi	r26, 0x21	; 33
    2172:	1a 2e       	mov	r1, r26
    2174:	aa 1b       	sub	r26, r26
    2176:	bb 1b       	sub	r27, r27
    2178:	fd 01       	movw	r30, r26
    217a:	0d c0       	rjmp	.+26     	; 0x2196 <__udivmodsi4_ep>

0000217c <__udivmodsi4_loop>:
    217c:	aa 1f       	adc	r26, r26
    217e:	bb 1f       	adc	r27, r27
    2180:	ee 1f       	adc	r30, r30
    2182:	ff 1f       	adc	r31, r31
    2184:	a2 17       	cp	r26, r18
    2186:	b3 07       	cpc	r27, r19
    2188:	e4 07       	cpc	r30, r20
    218a:	f5 07       	cpc	r31, r21
    218c:	20 f0       	brcs	.+8      	; 0x2196 <__udivmodsi4_ep>
    218e:	a2 1b       	sub	r26, r18
    2190:	b3 0b       	sbc	r27, r19
    2192:	e4 0b       	sbc	r30, r20
    2194:	f5 0b       	sbc	r31, r21

00002196 <__udivmodsi4_ep>:
    2196:	66 1f       	adc	r22, r22
    2198:	77 1f       	adc	r23, r23
    219a:	88 1f       	adc	r24, r24
    219c:	99 1f       	adc	r25, r25
    219e:	1a 94       	dec	r1
    21a0:	69 f7       	brne	.-38     	; 0x217c <__udivmodsi4_loop>
    21a2:	60 95       	com	r22
    21a4:	70 95       	com	r23
    21a6:	80 95       	com	r24
    21a8:	90 95       	com	r25
    21aa:	9b 01       	movw	r18, r22
    21ac:	ac 01       	movw	r20, r24
    21ae:	bd 01       	movw	r22, r26
    21b0:	cf 01       	movw	r24, r30
    21b2:	08 95       	ret

000021b4 <__subsf3>:
    21b4:	50 58       	subi	r21, 0x80	; 128

000021b6 <__addsf3>:
    21b6:	bb 27       	eor	r27, r27
    21b8:	aa 27       	eor	r26, r26
    21ba:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <__addsf3x>
    21be:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__fp_round>
    21c2:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fp_pscA>
    21c6:	38 f0       	brcs	.+14     	; 0x21d6 <__addsf3+0x20>
    21c8:	0e 94 5e 12 	call	0x24bc	; 0x24bc <__fp_pscB>
    21cc:	20 f0       	brcs	.+8      	; 0x21d6 <__addsf3+0x20>
    21ce:	39 f4       	brne	.+14     	; 0x21de <__addsf3+0x28>
    21d0:	9f 3f       	cpi	r25, 0xFF	; 255
    21d2:	19 f4       	brne	.+6      	; 0x21da <__addsf3+0x24>
    21d4:	26 f4       	brtc	.+8      	; 0x21de <__addsf3+0x28>
    21d6:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>
    21da:	0e f4       	brtc	.+2      	; 0x21de <__addsf3+0x28>
    21dc:	e0 95       	com	r30
    21de:	e7 fb       	bst	r30, 7
    21e0:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>

000021e4 <__addsf3x>:
    21e4:	e9 2f       	mov	r30, r25
    21e6:	0e 94 76 12 	call	0x24ec	; 0x24ec <__fp_split3>
    21ea:	58 f3       	brcs	.-42     	; 0x21c2 <__addsf3+0xc>
    21ec:	ba 17       	cp	r27, r26
    21ee:	62 07       	cpc	r22, r18
    21f0:	73 07       	cpc	r23, r19
    21f2:	84 07       	cpc	r24, r20
    21f4:	95 07       	cpc	r25, r21
    21f6:	20 f0       	brcs	.+8      	; 0x2200 <__addsf3x+0x1c>
    21f8:	79 f4       	brne	.+30     	; 0x2218 <__addsf3x+0x34>
    21fa:	a6 f5       	brtc	.+104    	; 0x2264 <__addsf3x+0x80>
    21fc:	0c 94 98 12 	jmp	0x2530	; 0x2530 <__fp_zero>
    2200:	0e f4       	brtc	.+2      	; 0x2204 <__addsf3x+0x20>
    2202:	e0 95       	com	r30
    2204:	0b 2e       	mov	r0, r27
    2206:	ba 2f       	mov	r27, r26
    2208:	a0 2d       	mov	r26, r0
    220a:	0b 01       	movw	r0, r22
    220c:	b9 01       	movw	r22, r18
    220e:	90 01       	movw	r18, r0
    2210:	0c 01       	movw	r0, r24
    2212:	ca 01       	movw	r24, r20
    2214:	a0 01       	movw	r20, r0
    2216:	11 24       	eor	r1, r1
    2218:	ff 27       	eor	r31, r31
    221a:	59 1b       	sub	r21, r25
    221c:	99 f0       	breq	.+38     	; 0x2244 <__addsf3x+0x60>
    221e:	59 3f       	cpi	r21, 0xF9	; 249
    2220:	50 f4       	brcc	.+20     	; 0x2236 <__addsf3x+0x52>
    2222:	50 3e       	cpi	r21, 0xE0	; 224
    2224:	68 f1       	brcs	.+90     	; 0x2280 <__addsf3x+0x9c>
    2226:	1a 16       	cp	r1, r26
    2228:	f0 40       	sbci	r31, 0x00	; 0
    222a:	a2 2f       	mov	r26, r18
    222c:	23 2f       	mov	r18, r19
    222e:	34 2f       	mov	r19, r20
    2230:	44 27       	eor	r20, r20
    2232:	58 5f       	subi	r21, 0xF8	; 248
    2234:	f3 cf       	rjmp	.-26     	; 0x221c <__addsf3x+0x38>
    2236:	46 95       	lsr	r20
    2238:	37 95       	ror	r19
    223a:	27 95       	ror	r18
    223c:	a7 95       	ror	r26
    223e:	f0 40       	sbci	r31, 0x00	; 0
    2240:	53 95       	inc	r21
    2242:	c9 f7       	brne	.-14     	; 0x2236 <__addsf3x+0x52>
    2244:	7e f4       	brtc	.+30     	; 0x2264 <__addsf3x+0x80>
    2246:	1f 16       	cp	r1, r31
    2248:	ba 0b       	sbc	r27, r26
    224a:	62 0b       	sbc	r22, r18
    224c:	73 0b       	sbc	r23, r19
    224e:	84 0b       	sbc	r24, r20
    2250:	ba f0       	brmi	.+46     	; 0x2280 <__addsf3x+0x9c>
    2252:	91 50       	subi	r25, 0x01	; 1
    2254:	a1 f0       	breq	.+40     	; 0x227e <__addsf3x+0x9a>
    2256:	ff 0f       	add	r31, r31
    2258:	bb 1f       	adc	r27, r27
    225a:	66 1f       	adc	r22, r22
    225c:	77 1f       	adc	r23, r23
    225e:	88 1f       	adc	r24, r24
    2260:	c2 f7       	brpl	.-16     	; 0x2252 <__addsf3x+0x6e>
    2262:	0e c0       	rjmp	.+28     	; 0x2280 <__addsf3x+0x9c>
    2264:	ba 0f       	add	r27, r26
    2266:	62 1f       	adc	r22, r18
    2268:	73 1f       	adc	r23, r19
    226a:	84 1f       	adc	r24, r20
    226c:	48 f4       	brcc	.+18     	; 0x2280 <__addsf3x+0x9c>
    226e:	87 95       	ror	r24
    2270:	77 95       	ror	r23
    2272:	67 95       	ror	r22
    2274:	b7 95       	ror	r27
    2276:	f7 95       	ror	r31
    2278:	9e 3f       	cpi	r25, 0xFE	; 254
    227a:	08 f0       	brcs	.+2      	; 0x227e <__addsf3x+0x9a>
    227c:	b0 cf       	rjmp	.-160    	; 0x21de <__addsf3+0x28>
    227e:	93 95       	inc	r25
    2280:	88 0f       	add	r24, r24
    2282:	08 f0       	brcs	.+2      	; 0x2286 <__addsf3x+0xa2>
    2284:	99 27       	eor	r25, r25
    2286:	ee 0f       	add	r30, r30
    2288:	97 95       	ror	r25
    228a:	87 95       	ror	r24
    228c:	08 95       	ret

0000228e <__cmpsf2>:
    228e:	0e 94 2a 12 	call	0x2454	; 0x2454 <__fp_cmp>
    2292:	08 f4       	brcc	.+2      	; 0x2296 <__cmpsf2+0x8>
    2294:	81 e0       	ldi	r24, 0x01	; 1
    2296:	08 95       	ret

00002298 <__divsf3>:
    2298:	0e 94 60 11 	call	0x22c0	; 0x22c0 <__divsf3x>
    229c:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__fp_round>
    22a0:	0e 94 5e 12 	call	0x24bc	; 0x24bc <__fp_pscB>
    22a4:	58 f0       	brcs	.+22     	; 0x22bc <__divsf3+0x24>
    22a6:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fp_pscA>
    22aa:	40 f0       	brcs	.+16     	; 0x22bc <__divsf3+0x24>
    22ac:	29 f4       	brne	.+10     	; 0x22b8 <__divsf3+0x20>
    22ae:	5f 3f       	cpi	r21, 0xFF	; 255
    22b0:	29 f0       	breq	.+10     	; 0x22bc <__divsf3+0x24>
    22b2:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    22b6:	51 11       	cpse	r21, r1
    22b8:	0c 94 99 12 	jmp	0x2532	; 0x2532 <__fp_szero>
    22bc:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>

000022c0 <__divsf3x>:
    22c0:	0e 94 76 12 	call	0x24ec	; 0x24ec <__fp_split3>
    22c4:	68 f3       	brcs	.-38     	; 0x22a0 <__divsf3+0x8>

000022c6 <__divsf3_pse>:
    22c6:	99 23       	and	r25, r25
    22c8:	b1 f3       	breq	.-20     	; 0x22b6 <__divsf3+0x1e>
    22ca:	55 23       	and	r21, r21
    22cc:	91 f3       	breq	.-28     	; 0x22b2 <__divsf3+0x1a>
    22ce:	95 1b       	sub	r25, r21
    22d0:	55 0b       	sbc	r21, r21
    22d2:	bb 27       	eor	r27, r27
    22d4:	aa 27       	eor	r26, r26
    22d6:	62 17       	cp	r22, r18
    22d8:	73 07       	cpc	r23, r19
    22da:	84 07       	cpc	r24, r20
    22dc:	38 f0       	brcs	.+14     	; 0x22ec <__divsf3_pse+0x26>
    22de:	9f 5f       	subi	r25, 0xFF	; 255
    22e0:	5f 4f       	sbci	r21, 0xFF	; 255
    22e2:	22 0f       	add	r18, r18
    22e4:	33 1f       	adc	r19, r19
    22e6:	44 1f       	adc	r20, r20
    22e8:	aa 1f       	adc	r26, r26
    22ea:	a9 f3       	breq	.-22     	; 0x22d6 <__divsf3_pse+0x10>
    22ec:	35 d0       	rcall	.+106    	; 0x2358 <__divsf3_pse+0x92>
    22ee:	0e 2e       	mov	r0, r30
    22f0:	3a f0       	brmi	.+14     	; 0x2300 <__divsf3_pse+0x3a>
    22f2:	e0 e8       	ldi	r30, 0x80	; 128
    22f4:	32 d0       	rcall	.+100    	; 0x235a <__divsf3_pse+0x94>
    22f6:	91 50       	subi	r25, 0x01	; 1
    22f8:	50 40       	sbci	r21, 0x00	; 0
    22fa:	e6 95       	lsr	r30
    22fc:	00 1c       	adc	r0, r0
    22fe:	ca f7       	brpl	.-14     	; 0x22f2 <__divsf3_pse+0x2c>
    2300:	2b d0       	rcall	.+86     	; 0x2358 <__divsf3_pse+0x92>
    2302:	fe 2f       	mov	r31, r30
    2304:	29 d0       	rcall	.+82     	; 0x2358 <__divsf3_pse+0x92>
    2306:	66 0f       	add	r22, r22
    2308:	77 1f       	adc	r23, r23
    230a:	88 1f       	adc	r24, r24
    230c:	bb 1f       	adc	r27, r27
    230e:	26 17       	cp	r18, r22
    2310:	37 07       	cpc	r19, r23
    2312:	48 07       	cpc	r20, r24
    2314:	ab 07       	cpc	r26, r27
    2316:	b0 e8       	ldi	r27, 0x80	; 128
    2318:	09 f0       	breq	.+2      	; 0x231c <__divsf3_pse+0x56>
    231a:	bb 0b       	sbc	r27, r27
    231c:	80 2d       	mov	r24, r0
    231e:	bf 01       	movw	r22, r30
    2320:	ff 27       	eor	r31, r31
    2322:	93 58       	subi	r25, 0x83	; 131
    2324:	5f 4f       	sbci	r21, 0xFF	; 255
    2326:	3a f0       	brmi	.+14     	; 0x2336 <__divsf3_pse+0x70>
    2328:	9e 3f       	cpi	r25, 0xFE	; 254
    232a:	51 05       	cpc	r21, r1
    232c:	78 f0       	brcs	.+30     	; 0x234c <__divsf3_pse+0x86>
    232e:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    2332:	0c 94 99 12 	jmp	0x2532	; 0x2532 <__fp_szero>
    2336:	5f 3f       	cpi	r21, 0xFF	; 255
    2338:	e4 f3       	brlt	.-8      	; 0x2332 <__divsf3_pse+0x6c>
    233a:	98 3e       	cpi	r25, 0xE8	; 232
    233c:	d4 f3       	brlt	.-12     	; 0x2332 <__divsf3_pse+0x6c>
    233e:	86 95       	lsr	r24
    2340:	77 95       	ror	r23
    2342:	67 95       	ror	r22
    2344:	b7 95       	ror	r27
    2346:	f7 95       	ror	r31
    2348:	9f 5f       	subi	r25, 0xFF	; 255
    234a:	c9 f7       	brne	.-14     	; 0x233e <__divsf3_pse+0x78>
    234c:	88 0f       	add	r24, r24
    234e:	91 1d       	adc	r25, r1
    2350:	96 95       	lsr	r25
    2352:	87 95       	ror	r24
    2354:	97 f9       	bld	r25, 7
    2356:	08 95       	ret
    2358:	e1 e0       	ldi	r30, 0x01	; 1
    235a:	66 0f       	add	r22, r22
    235c:	77 1f       	adc	r23, r23
    235e:	88 1f       	adc	r24, r24
    2360:	bb 1f       	adc	r27, r27
    2362:	62 17       	cp	r22, r18
    2364:	73 07       	cpc	r23, r19
    2366:	84 07       	cpc	r24, r20
    2368:	ba 07       	cpc	r27, r26
    236a:	20 f0       	brcs	.+8      	; 0x2374 <__divsf3_pse+0xae>
    236c:	62 1b       	sub	r22, r18
    236e:	73 0b       	sbc	r23, r19
    2370:	84 0b       	sbc	r24, r20
    2372:	ba 0b       	sbc	r27, r26
    2374:	ee 1f       	adc	r30, r30
    2376:	88 f7       	brcc	.-30     	; 0x235a <__divsf3_pse+0x94>
    2378:	e0 95       	com	r30
    237a:	08 95       	ret

0000237c <__fixunssfsi>:
    237c:	0e 94 7e 12 	call	0x24fc	; 0x24fc <__fp_splitA>
    2380:	88 f0       	brcs	.+34     	; 0x23a4 <__fixunssfsi+0x28>
    2382:	9f 57       	subi	r25, 0x7F	; 127
    2384:	98 f0       	brcs	.+38     	; 0x23ac <__fixunssfsi+0x30>
    2386:	b9 2f       	mov	r27, r25
    2388:	99 27       	eor	r25, r25
    238a:	b7 51       	subi	r27, 0x17	; 23
    238c:	b0 f0       	brcs	.+44     	; 0x23ba <__fixunssfsi+0x3e>
    238e:	e1 f0       	breq	.+56     	; 0x23c8 <__fixunssfsi+0x4c>
    2390:	66 0f       	add	r22, r22
    2392:	77 1f       	adc	r23, r23
    2394:	88 1f       	adc	r24, r24
    2396:	99 1f       	adc	r25, r25
    2398:	1a f0       	brmi	.+6      	; 0x23a0 <__fixunssfsi+0x24>
    239a:	ba 95       	dec	r27
    239c:	c9 f7       	brne	.-14     	; 0x2390 <__fixunssfsi+0x14>
    239e:	14 c0       	rjmp	.+40     	; 0x23c8 <__fixunssfsi+0x4c>
    23a0:	b1 30       	cpi	r27, 0x01	; 1
    23a2:	91 f0       	breq	.+36     	; 0x23c8 <__fixunssfsi+0x4c>
    23a4:	0e 94 98 12 	call	0x2530	; 0x2530 <__fp_zero>
    23a8:	b1 e0       	ldi	r27, 0x01	; 1
    23aa:	08 95       	ret
    23ac:	0c 94 98 12 	jmp	0x2530	; 0x2530 <__fp_zero>
    23b0:	67 2f       	mov	r22, r23
    23b2:	78 2f       	mov	r23, r24
    23b4:	88 27       	eor	r24, r24
    23b6:	b8 5f       	subi	r27, 0xF8	; 248
    23b8:	39 f0       	breq	.+14     	; 0x23c8 <__fixunssfsi+0x4c>
    23ba:	b9 3f       	cpi	r27, 0xF9	; 249
    23bc:	cc f3       	brlt	.-14     	; 0x23b0 <__fixunssfsi+0x34>
    23be:	86 95       	lsr	r24
    23c0:	77 95       	ror	r23
    23c2:	67 95       	ror	r22
    23c4:	b3 95       	inc	r27
    23c6:	d9 f7       	brne	.-10     	; 0x23be <__fixunssfsi+0x42>
    23c8:	3e f4       	brtc	.+14     	; 0x23d8 <__fixunssfsi+0x5c>
    23ca:	90 95       	com	r25
    23cc:	80 95       	com	r24
    23ce:	70 95       	com	r23
    23d0:	61 95       	neg	r22
    23d2:	7f 4f       	sbci	r23, 0xFF	; 255
    23d4:	8f 4f       	sbci	r24, 0xFF	; 255
    23d6:	9f 4f       	sbci	r25, 0xFF	; 255
    23d8:	08 95       	ret

000023da <__floatunsisf>:
    23da:	e8 94       	clt
    23dc:	09 c0       	rjmp	.+18     	; 0x23f0 <__floatsisf+0x12>

000023de <__floatsisf>:
    23de:	97 fb       	bst	r25, 7
    23e0:	3e f4       	brtc	.+14     	; 0x23f0 <__floatsisf+0x12>
    23e2:	90 95       	com	r25
    23e4:	80 95       	com	r24
    23e6:	70 95       	com	r23
    23e8:	61 95       	neg	r22
    23ea:	7f 4f       	sbci	r23, 0xFF	; 255
    23ec:	8f 4f       	sbci	r24, 0xFF	; 255
    23ee:	9f 4f       	sbci	r25, 0xFF	; 255
    23f0:	99 23       	and	r25, r25
    23f2:	a9 f0       	breq	.+42     	; 0x241e <__floatsisf+0x40>
    23f4:	f9 2f       	mov	r31, r25
    23f6:	96 e9       	ldi	r25, 0x96	; 150
    23f8:	bb 27       	eor	r27, r27
    23fa:	93 95       	inc	r25
    23fc:	f6 95       	lsr	r31
    23fe:	87 95       	ror	r24
    2400:	77 95       	ror	r23
    2402:	67 95       	ror	r22
    2404:	b7 95       	ror	r27
    2406:	f1 11       	cpse	r31, r1
    2408:	f8 cf       	rjmp	.-16     	; 0x23fa <__floatsisf+0x1c>
    240a:	fa f4       	brpl	.+62     	; 0x244a <__floatsisf+0x6c>
    240c:	bb 0f       	add	r27, r27
    240e:	11 f4       	brne	.+4      	; 0x2414 <__floatsisf+0x36>
    2410:	60 ff       	sbrs	r22, 0
    2412:	1b c0       	rjmp	.+54     	; 0x244a <__floatsisf+0x6c>
    2414:	6f 5f       	subi	r22, 0xFF	; 255
    2416:	7f 4f       	sbci	r23, 0xFF	; 255
    2418:	8f 4f       	sbci	r24, 0xFF	; 255
    241a:	9f 4f       	sbci	r25, 0xFF	; 255
    241c:	16 c0       	rjmp	.+44     	; 0x244a <__floatsisf+0x6c>
    241e:	88 23       	and	r24, r24
    2420:	11 f0       	breq	.+4      	; 0x2426 <__floatsisf+0x48>
    2422:	96 e9       	ldi	r25, 0x96	; 150
    2424:	11 c0       	rjmp	.+34     	; 0x2448 <__floatsisf+0x6a>
    2426:	77 23       	and	r23, r23
    2428:	21 f0       	breq	.+8      	; 0x2432 <__floatsisf+0x54>
    242a:	9e e8       	ldi	r25, 0x8E	; 142
    242c:	87 2f       	mov	r24, r23
    242e:	76 2f       	mov	r23, r22
    2430:	05 c0       	rjmp	.+10     	; 0x243c <__floatsisf+0x5e>
    2432:	66 23       	and	r22, r22
    2434:	71 f0       	breq	.+28     	; 0x2452 <__floatsisf+0x74>
    2436:	96 e8       	ldi	r25, 0x86	; 134
    2438:	86 2f       	mov	r24, r22
    243a:	70 e0       	ldi	r23, 0x00	; 0
    243c:	60 e0       	ldi	r22, 0x00	; 0
    243e:	2a f0       	brmi	.+10     	; 0x244a <__floatsisf+0x6c>
    2440:	9a 95       	dec	r25
    2442:	66 0f       	add	r22, r22
    2444:	77 1f       	adc	r23, r23
    2446:	88 1f       	adc	r24, r24
    2448:	da f7       	brpl	.-10     	; 0x2440 <__floatsisf+0x62>
    244a:	88 0f       	add	r24, r24
    244c:	96 95       	lsr	r25
    244e:	87 95       	ror	r24
    2450:	97 f9       	bld	r25, 7
    2452:	08 95       	ret

00002454 <__fp_cmp>:
    2454:	99 0f       	add	r25, r25
    2456:	00 08       	sbc	r0, r0
    2458:	55 0f       	add	r21, r21
    245a:	aa 0b       	sbc	r26, r26
    245c:	e0 e8       	ldi	r30, 0x80	; 128
    245e:	fe ef       	ldi	r31, 0xFE	; 254
    2460:	16 16       	cp	r1, r22
    2462:	17 06       	cpc	r1, r23
    2464:	e8 07       	cpc	r30, r24
    2466:	f9 07       	cpc	r31, r25
    2468:	c0 f0       	brcs	.+48     	; 0x249a <__fp_cmp+0x46>
    246a:	12 16       	cp	r1, r18
    246c:	13 06       	cpc	r1, r19
    246e:	e4 07       	cpc	r30, r20
    2470:	f5 07       	cpc	r31, r21
    2472:	98 f0       	brcs	.+38     	; 0x249a <__fp_cmp+0x46>
    2474:	62 1b       	sub	r22, r18
    2476:	73 0b       	sbc	r23, r19
    2478:	84 0b       	sbc	r24, r20
    247a:	95 0b       	sbc	r25, r21
    247c:	39 f4       	brne	.+14     	; 0x248c <__fp_cmp+0x38>
    247e:	0a 26       	eor	r0, r26
    2480:	61 f0       	breq	.+24     	; 0x249a <__fp_cmp+0x46>
    2482:	23 2b       	or	r18, r19
    2484:	24 2b       	or	r18, r20
    2486:	25 2b       	or	r18, r21
    2488:	21 f4       	brne	.+8      	; 0x2492 <__fp_cmp+0x3e>
    248a:	08 95       	ret
    248c:	0a 26       	eor	r0, r26
    248e:	09 f4       	brne	.+2      	; 0x2492 <__fp_cmp+0x3e>
    2490:	a1 40       	sbci	r26, 0x01	; 1
    2492:	a6 95       	lsr	r26
    2494:	8f ef       	ldi	r24, 0xFF	; 255
    2496:	81 1d       	adc	r24, r1
    2498:	81 1d       	adc	r24, r1
    249a:	08 95       	ret

0000249c <__fp_inf>:
    249c:	97 f9       	bld	r25, 7
    249e:	9f 67       	ori	r25, 0x7F	; 127
    24a0:	80 e8       	ldi	r24, 0x80	; 128
    24a2:	70 e0       	ldi	r23, 0x00	; 0
    24a4:	60 e0       	ldi	r22, 0x00	; 0
    24a6:	08 95       	ret

000024a8 <__fp_nan>:
    24a8:	9f ef       	ldi	r25, 0xFF	; 255
    24aa:	80 ec       	ldi	r24, 0xC0	; 192
    24ac:	08 95       	ret

000024ae <__fp_pscA>:
    24ae:	00 24       	eor	r0, r0
    24b0:	0a 94       	dec	r0
    24b2:	16 16       	cp	r1, r22
    24b4:	17 06       	cpc	r1, r23
    24b6:	18 06       	cpc	r1, r24
    24b8:	09 06       	cpc	r0, r25
    24ba:	08 95       	ret

000024bc <__fp_pscB>:
    24bc:	00 24       	eor	r0, r0
    24be:	0a 94       	dec	r0
    24c0:	12 16       	cp	r1, r18
    24c2:	13 06       	cpc	r1, r19
    24c4:	14 06       	cpc	r1, r20
    24c6:	05 06       	cpc	r0, r21
    24c8:	08 95       	ret

000024ca <__fp_round>:
    24ca:	09 2e       	mov	r0, r25
    24cc:	03 94       	inc	r0
    24ce:	00 0c       	add	r0, r0
    24d0:	11 f4       	brne	.+4      	; 0x24d6 <__fp_round+0xc>
    24d2:	88 23       	and	r24, r24
    24d4:	52 f0       	brmi	.+20     	; 0x24ea <__fp_round+0x20>
    24d6:	bb 0f       	add	r27, r27
    24d8:	40 f4       	brcc	.+16     	; 0x24ea <__fp_round+0x20>
    24da:	bf 2b       	or	r27, r31
    24dc:	11 f4       	brne	.+4      	; 0x24e2 <__fp_round+0x18>
    24de:	60 ff       	sbrs	r22, 0
    24e0:	04 c0       	rjmp	.+8      	; 0x24ea <__fp_round+0x20>
    24e2:	6f 5f       	subi	r22, 0xFF	; 255
    24e4:	7f 4f       	sbci	r23, 0xFF	; 255
    24e6:	8f 4f       	sbci	r24, 0xFF	; 255
    24e8:	9f 4f       	sbci	r25, 0xFF	; 255
    24ea:	08 95       	ret

000024ec <__fp_split3>:
    24ec:	57 fd       	sbrc	r21, 7
    24ee:	90 58       	subi	r25, 0x80	; 128
    24f0:	44 0f       	add	r20, r20
    24f2:	55 1f       	adc	r21, r21
    24f4:	59 f0       	breq	.+22     	; 0x250c <__fp_splitA+0x10>
    24f6:	5f 3f       	cpi	r21, 0xFF	; 255
    24f8:	71 f0       	breq	.+28     	; 0x2516 <__fp_splitA+0x1a>
    24fa:	47 95       	ror	r20

000024fc <__fp_splitA>:
    24fc:	88 0f       	add	r24, r24
    24fe:	97 fb       	bst	r25, 7
    2500:	99 1f       	adc	r25, r25
    2502:	61 f0       	breq	.+24     	; 0x251c <__fp_splitA+0x20>
    2504:	9f 3f       	cpi	r25, 0xFF	; 255
    2506:	79 f0       	breq	.+30     	; 0x2526 <__fp_splitA+0x2a>
    2508:	87 95       	ror	r24
    250a:	08 95       	ret
    250c:	12 16       	cp	r1, r18
    250e:	13 06       	cpc	r1, r19
    2510:	14 06       	cpc	r1, r20
    2512:	55 1f       	adc	r21, r21
    2514:	f2 cf       	rjmp	.-28     	; 0x24fa <__fp_split3+0xe>
    2516:	46 95       	lsr	r20
    2518:	f1 df       	rcall	.-30     	; 0x24fc <__fp_splitA>
    251a:	08 c0       	rjmp	.+16     	; 0x252c <__fp_splitA+0x30>
    251c:	16 16       	cp	r1, r22
    251e:	17 06       	cpc	r1, r23
    2520:	18 06       	cpc	r1, r24
    2522:	99 1f       	adc	r25, r25
    2524:	f1 cf       	rjmp	.-30     	; 0x2508 <__fp_splitA+0xc>
    2526:	86 95       	lsr	r24
    2528:	71 05       	cpc	r23, r1
    252a:	61 05       	cpc	r22, r1
    252c:	08 94       	sec
    252e:	08 95       	ret

00002530 <__fp_zero>:
    2530:	e8 94       	clt

00002532 <__fp_szero>:
    2532:	bb 27       	eor	r27, r27
    2534:	66 27       	eor	r22, r22
    2536:	77 27       	eor	r23, r23
    2538:	cb 01       	movw	r24, r22
    253a:	97 f9       	bld	r25, 7
    253c:	08 95       	ret

0000253e <__gesf2>:
    253e:	0e 94 2a 12 	call	0x2454	; 0x2454 <__fp_cmp>
    2542:	08 f4       	brcc	.+2      	; 0x2546 <__gesf2+0x8>
    2544:	8f ef       	ldi	r24, 0xFF	; 255
    2546:	08 95       	ret

00002548 <__mulsf3>:
    2548:	0e 94 b7 12 	call	0x256e	; 0x256e <__mulsf3x>
    254c:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__fp_round>
    2550:	0e 94 57 12 	call	0x24ae	; 0x24ae <__fp_pscA>
    2554:	38 f0       	brcs	.+14     	; 0x2564 <__mulsf3+0x1c>
    2556:	0e 94 5e 12 	call	0x24bc	; 0x24bc <__fp_pscB>
    255a:	20 f0       	brcs	.+8      	; 0x2564 <__mulsf3+0x1c>
    255c:	95 23       	and	r25, r21
    255e:	11 f0       	breq	.+4      	; 0x2564 <__mulsf3+0x1c>
    2560:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    2564:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>
    2568:	11 24       	eor	r1, r1
    256a:	0c 94 99 12 	jmp	0x2532	; 0x2532 <__fp_szero>

0000256e <__mulsf3x>:
    256e:	0e 94 76 12 	call	0x24ec	; 0x24ec <__fp_split3>
    2572:	70 f3       	brcs	.-36     	; 0x2550 <__mulsf3+0x8>

00002574 <__mulsf3_pse>:
    2574:	95 9f       	mul	r25, r21
    2576:	c1 f3       	breq	.-16     	; 0x2568 <__mulsf3+0x20>
    2578:	95 0f       	add	r25, r21
    257a:	50 e0       	ldi	r21, 0x00	; 0
    257c:	55 1f       	adc	r21, r21
    257e:	62 9f       	mul	r22, r18
    2580:	f0 01       	movw	r30, r0
    2582:	72 9f       	mul	r23, r18
    2584:	bb 27       	eor	r27, r27
    2586:	f0 0d       	add	r31, r0
    2588:	b1 1d       	adc	r27, r1
    258a:	63 9f       	mul	r22, r19
    258c:	aa 27       	eor	r26, r26
    258e:	f0 0d       	add	r31, r0
    2590:	b1 1d       	adc	r27, r1
    2592:	aa 1f       	adc	r26, r26
    2594:	64 9f       	mul	r22, r20
    2596:	66 27       	eor	r22, r22
    2598:	b0 0d       	add	r27, r0
    259a:	a1 1d       	adc	r26, r1
    259c:	66 1f       	adc	r22, r22
    259e:	82 9f       	mul	r24, r18
    25a0:	22 27       	eor	r18, r18
    25a2:	b0 0d       	add	r27, r0
    25a4:	a1 1d       	adc	r26, r1
    25a6:	62 1f       	adc	r22, r18
    25a8:	73 9f       	mul	r23, r19
    25aa:	b0 0d       	add	r27, r0
    25ac:	a1 1d       	adc	r26, r1
    25ae:	62 1f       	adc	r22, r18
    25b0:	83 9f       	mul	r24, r19
    25b2:	a0 0d       	add	r26, r0
    25b4:	61 1d       	adc	r22, r1
    25b6:	22 1f       	adc	r18, r18
    25b8:	74 9f       	mul	r23, r20
    25ba:	33 27       	eor	r19, r19
    25bc:	a0 0d       	add	r26, r0
    25be:	61 1d       	adc	r22, r1
    25c0:	23 1f       	adc	r18, r19
    25c2:	84 9f       	mul	r24, r20
    25c4:	60 0d       	add	r22, r0
    25c6:	21 1d       	adc	r18, r1
    25c8:	82 2f       	mov	r24, r18
    25ca:	76 2f       	mov	r23, r22
    25cc:	6a 2f       	mov	r22, r26
    25ce:	11 24       	eor	r1, r1
    25d0:	9f 57       	subi	r25, 0x7F	; 127
    25d2:	50 40       	sbci	r21, 0x00	; 0
    25d4:	9a f0       	brmi	.+38     	; 0x25fc <__mulsf3_pse+0x88>
    25d6:	f1 f0       	breq	.+60     	; 0x2614 <__mulsf3_pse+0xa0>
    25d8:	88 23       	and	r24, r24
    25da:	4a f0       	brmi	.+18     	; 0x25ee <__mulsf3_pse+0x7a>
    25dc:	ee 0f       	add	r30, r30
    25de:	ff 1f       	adc	r31, r31
    25e0:	bb 1f       	adc	r27, r27
    25e2:	66 1f       	adc	r22, r22
    25e4:	77 1f       	adc	r23, r23
    25e6:	88 1f       	adc	r24, r24
    25e8:	91 50       	subi	r25, 0x01	; 1
    25ea:	50 40       	sbci	r21, 0x00	; 0
    25ec:	a9 f7       	brne	.-22     	; 0x25d8 <__mulsf3_pse+0x64>
    25ee:	9e 3f       	cpi	r25, 0xFE	; 254
    25f0:	51 05       	cpc	r21, r1
    25f2:	80 f0       	brcs	.+32     	; 0x2614 <__mulsf3_pse+0xa0>
    25f4:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    25f8:	0c 94 99 12 	jmp	0x2532	; 0x2532 <__fp_szero>
    25fc:	5f 3f       	cpi	r21, 0xFF	; 255
    25fe:	e4 f3       	brlt	.-8      	; 0x25f8 <__mulsf3_pse+0x84>
    2600:	98 3e       	cpi	r25, 0xE8	; 232
    2602:	d4 f3       	brlt	.-12     	; 0x25f8 <__mulsf3_pse+0x84>
    2604:	86 95       	lsr	r24
    2606:	77 95       	ror	r23
    2608:	67 95       	ror	r22
    260a:	b7 95       	ror	r27
    260c:	f7 95       	ror	r31
    260e:	e7 95       	ror	r30
    2610:	9f 5f       	subi	r25, 0xFF	; 255
    2612:	c1 f7       	brne	.-16     	; 0x2604 <__mulsf3_pse+0x90>
    2614:	fe 2b       	or	r31, r30
    2616:	88 0f       	add	r24, r24
    2618:	91 1d       	adc	r25, r1
    261a:	96 95       	lsr	r25
    261c:	87 95       	ror	r24
    261e:	97 f9       	bld	r25, 7
    2620:	08 95       	ret

00002622 <pow>:
    2622:	fa 01       	movw	r30, r20
    2624:	ee 0f       	add	r30, r30
    2626:	ff 1f       	adc	r31, r31
    2628:	30 96       	adiw	r30, 0x00	; 0
    262a:	21 05       	cpc	r18, r1
    262c:	31 05       	cpc	r19, r1
    262e:	a1 f1       	breq	.+104    	; 0x2698 <pow+0x76>
    2630:	61 15       	cp	r22, r1
    2632:	71 05       	cpc	r23, r1
    2634:	61 f4       	brne	.+24     	; 0x264e <pow+0x2c>
    2636:	80 38       	cpi	r24, 0x80	; 128
    2638:	bf e3       	ldi	r27, 0x3F	; 63
    263a:	9b 07       	cpc	r25, r27
    263c:	49 f1       	breq	.+82     	; 0x2690 <pow+0x6e>
    263e:	68 94       	set
    2640:	90 38       	cpi	r25, 0x80	; 128
    2642:	81 05       	cpc	r24, r1
    2644:	61 f0       	breq	.+24     	; 0x265e <pow+0x3c>
    2646:	80 38       	cpi	r24, 0x80	; 128
    2648:	bf ef       	ldi	r27, 0xFF	; 255
    264a:	9b 07       	cpc	r25, r27
    264c:	41 f0       	breq	.+16     	; 0x265e <pow+0x3c>
    264e:	99 23       	and	r25, r25
    2650:	4a f5       	brpl	.+82     	; 0x26a4 <pow+0x82>
    2652:	ff 3f       	cpi	r31, 0xFF	; 255
    2654:	e1 05       	cpc	r30, r1
    2656:	31 05       	cpc	r19, r1
    2658:	21 05       	cpc	r18, r1
    265a:	19 f1       	breq	.+70     	; 0x26a2 <pow+0x80>
    265c:	e8 94       	clt
    265e:	08 94       	sec
    2660:	e7 95       	ror	r30
    2662:	d9 01       	movw	r26, r18
    2664:	aa 23       	and	r26, r26
    2666:	29 f4       	brne	.+10     	; 0x2672 <pow+0x50>
    2668:	ab 2f       	mov	r26, r27
    266a:	be 2f       	mov	r27, r30
    266c:	f8 5f       	subi	r31, 0xF8	; 248
    266e:	d0 f3       	brcs	.-12     	; 0x2664 <pow+0x42>
    2670:	10 c0       	rjmp	.+32     	; 0x2692 <pow+0x70>
    2672:	ff 5f       	subi	r31, 0xFF	; 255
    2674:	70 f4       	brcc	.+28     	; 0x2692 <pow+0x70>
    2676:	a6 95       	lsr	r26
    2678:	e0 f7       	brcc	.-8      	; 0x2672 <pow+0x50>
    267a:	f7 39       	cpi	r31, 0x97	; 151
    267c:	50 f0       	brcs	.+20     	; 0x2692 <pow+0x70>
    267e:	19 f0       	breq	.+6      	; 0x2686 <pow+0x64>
    2680:	ff 3a       	cpi	r31, 0xAF	; 175
    2682:	38 f4       	brcc	.+14     	; 0x2692 <pow+0x70>
    2684:	9f 77       	andi	r25, 0x7F	; 127
    2686:	9f 93       	push	r25
    2688:	0d d0       	rcall	.+26     	; 0x26a4 <pow+0x82>
    268a:	0f 90       	pop	r0
    268c:	07 fc       	sbrc	r0, 7
    268e:	90 58       	subi	r25, 0x80	; 128
    2690:	08 95       	ret
    2692:	46 f0       	brts	.+16     	; 0x26a4 <pow+0x82>
    2694:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>
    2698:	60 e0       	ldi	r22, 0x00	; 0
    269a:	70 e0       	ldi	r23, 0x00	; 0
    269c:	80 e8       	ldi	r24, 0x80	; 128
    269e:	9f e3       	ldi	r25, 0x3F	; 63
    26a0:	08 95       	ret
    26a2:	4f e7       	ldi	r20, 0x7F	; 127
    26a4:	9f 77       	andi	r25, 0x7F	; 127
    26a6:	5f 93       	push	r21
    26a8:	4f 93       	push	r20
    26aa:	3f 93       	push	r19
    26ac:	2f 93       	push	r18
    26ae:	0e 94 0c 14 	call	0x2818	; 0x2818 <log>
    26b2:	2f 91       	pop	r18
    26b4:	3f 91       	pop	r19
    26b6:	4f 91       	pop	r20
    26b8:	5f 91       	pop	r21
    26ba:	0e 94 a4 12 	call	0x2548	; 0x2548 <__mulsf3>
    26be:	0c 94 69 13 	jmp	0x26d2	; 0x26d2 <exp>
    26c2:	29 f4       	brne	.+10     	; 0x26ce <pow+0xac>
    26c4:	16 f0       	brts	.+4      	; 0x26ca <pow+0xa8>
    26c6:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    26ca:	0c 94 98 12 	jmp	0x2530	; 0x2530 <__fp_zero>
    26ce:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>

000026d2 <exp>:
    26d2:	0e 94 7e 12 	call	0x24fc	; 0x24fc <__fp_splitA>
    26d6:	a8 f3       	brcs	.-22     	; 0x26c2 <pow+0xa0>
    26d8:	96 38       	cpi	r25, 0x86	; 134
    26da:	a0 f7       	brcc	.-24     	; 0x26c4 <pow+0xa2>
    26dc:	07 f8       	bld	r0, 7
    26de:	0f 92       	push	r0
    26e0:	e8 94       	clt
    26e2:	2b e3       	ldi	r18, 0x3B	; 59
    26e4:	3a ea       	ldi	r19, 0xAA	; 170
    26e6:	48 eb       	ldi	r20, 0xB8	; 184
    26e8:	5f e7       	ldi	r21, 0x7F	; 127
    26ea:	0e 94 ba 12 	call	0x2574	; 0x2574 <__mulsf3_pse>
    26ee:	0f 92       	push	r0
    26f0:	0f 92       	push	r0
    26f2:	0f 92       	push	r0
    26f4:	4d b7       	in	r20, 0x3d	; 61
    26f6:	5e b7       	in	r21, 0x3e	; 62
    26f8:	0f 92       	push	r0
    26fa:	0e 94 54 14 	call	0x28a8	; 0x28a8 <modf>
    26fe:	e4 e5       	ldi	r30, 0x54	; 84
    2700:	f0 e0       	ldi	r31, 0x00	; 0
    2702:	0e 94 9b 13 	call	0x2736	; 0x2736 <__fp_powser>
    2706:	4f 91       	pop	r20
    2708:	5f 91       	pop	r21
    270a:	ef 91       	pop	r30
    270c:	ff 91       	pop	r31
    270e:	e5 95       	asr	r30
    2710:	ee 1f       	adc	r30, r30
    2712:	ff 1f       	adc	r31, r31
    2714:	49 f0       	breq	.+18     	; 0x2728 <exp+0x56>
    2716:	fe 57       	subi	r31, 0x7E	; 126
    2718:	e0 68       	ori	r30, 0x80	; 128
    271a:	44 27       	eor	r20, r20
    271c:	ee 0f       	add	r30, r30
    271e:	44 1f       	adc	r20, r20
    2720:	fa 95       	dec	r31
    2722:	e1 f7       	brne	.-8      	; 0x271c <exp+0x4a>
    2724:	41 95       	neg	r20
    2726:	55 0b       	sbc	r21, r21
    2728:	0e 94 ce 13 	call	0x279c	; 0x279c <ldexp>
    272c:	0f 90       	pop	r0
    272e:	07 fe       	sbrs	r0, 7
    2730:	0c 94 c2 13 	jmp	0x2784	; 0x2784 <inverse>
    2734:	08 95       	ret

00002736 <__fp_powser>:
    2736:	df 93       	push	r29
    2738:	cf 93       	push	r28
    273a:	1f 93       	push	r17
    273c:	0f 93       	push	r16
    273e:	ff 92       	push	r15
    2740:	ef 92       	push	r14
    2742:	df 92       	push	r13
    2744:	7b 01       	movw	r14, r22
    2746:	8c 01       	movw	r16, r24
    2748:	68 94       	set
    274a:	06 c0       	rjmp	.+12     	; 0x2758 <__fp_powser+0x22>
    274c:	da 2e       	mov	r13, r26
    274e:	ef 01       	movw	r28, r30
    2750:	0e 94 b7 12 	call	0x256e	; 0x256e <__mulsf3x>
    2754:	fe 01       	movw	r30, r28
    2756:	e8 94       	clt
    2758:	a5 91       	lpm	r26, Z+
    275a:	25 91       	lpm	r18, Z+
    275c:	35 91       	lpm	r19, Z+
    275e:	45 91       	lpm	r20, Z+
    2760:	55 91       	lpm	r21, Z+
    2762:	a6 f3       	brts	.-24     	; 0x274c <__fp_powser+0x16>
    2764:	ef 01       	movw	r28, r30
    2766:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <__addsf3x>
    276a:	fe 01       	movw	r30, r28
    276c:	97 01       	movw	r18, r14
    276e:	a8 01       	movw	r20, r16
    2770:	da 94       	dec	r13
    2772:	69 f7       	brne	.-38     	; 0x274e <__fp_powser+0x18>
    2774:	df 90       	pop	r13
    2776:	ef 90       	pop	r14
    2778:	ff 90       	pop	r15
    277a:	0f 91       	pop	r16
    277c:	1f 91       	pop	r17
    277e:	cf 91       	pop	r28
    2780:	df 91       	pop	r29
    2782:	08 95       	ret

00002784 <inverse>:
    2784:	9b 01       	movw	r18, r22
    2786:	ac 01       	movw	r20, r24
    2788:	60 e0       	ldi	r22, 0x00	; 0
    278a:	70 e0       	ldi	r23, 0x00	; 0
    278c:	80 e8       	ldi	r24, 0x80	; 128
    278e:	9f e3       	ldi	r25, 0x3F	; 63
    2790:	0c 94 4c 11 	jmp	0x2298	; 0x2298 <__divsf3>
    2794:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>
    2798:	0c 94 88 14 	jmp	0x2910	; 0x2910 <__fp_mpack>

0000279c <ldexp>:
    279c:	0e 94 7e 12 	call	0x24fc	; 0x24fc <__fp_splitA>
    27a0:	d8 f3       	brcs	.-10     	; 0x2798 <inverse+0x14>
    27a2:	99 23       	and	r25, r25
    27a4:	c9 f3       	breq	.-14     	; 0x2798 <inverse+0x14>
    27a6:	94 0f       	add	r25, r20
    27a8:	51 1d       	adc	r21, r1
    27aa:	a3 f3       	brvs	.-24     	; 0x2794 <inverse+0x10>
    27ac:	91 50       	subi	r25, 0x01	; 1
    27ae:	50 40       	sbci	r21, 0x00	; 0
    27b0:	94 f0       	brlt	.+36     	; 0x27d6 <ldexp+0x3a>
    27b2:	59 f0       	breq	.+22     	; 0x27ca <ldexp+0x2e>
    27b4:	88 23       	and	r24, r24
    27b6:	32 f0       	brmi	.+12     	; 0x27c4 <ldexp+0x28>
    27b8:	66 0f       	add	r22, r22
    27ba:	77 1f       	adc	r23, r23
    27bc:	88 1f       	adc	r24, r24
    27be:	91 50       	subi	r25, 0x01	; 1
    27c0:	50 40       	sbci	r21, 0x00	; 0
    27c2:	c1 f7       	brne	.-16     	; 0x27b4 <ldexp+0x18>
    27c4:	9e 3f       	cpi	r25, 0xFE	; 254
    27c6:	51 05       	cpc	r21, r1
    27c8:	2c f7       	brge	.-54     	; 0x2794 <inverse+0x10>
    27ca:	88 0f       	add	r24, r24
    27cc:	91 1d       	adc	r25, r1
    27ce:	96 95       	lsr	r25
    27d0:	87 95       	ror	r24
    27d2:	97 f9       	bld	r25, 7
    27d4:	08 95       	ret
    27d6:	5f 3f       	cpi	r21, 0xFF	; 255
    27d8:	ac f0       	brlt	.+42     	; 0x2804 <ldexp+0x68>
    27da:	98 3e       	cpi	r25, 0xE8	; 232
    27dc:	9c f0       	brlt	.+38     	; 0x2804 <ldexp+0x68>
    27de:	bb 27       	eor	r27, r27
    27e0:	86 95       	lsr	r24
    27e2:	77 95       	ror	r23
    27e4:	67 95       	ror	r22
    27e6:	b7 95       	ror	r27
    27e8:	08 f4       	brcc	.+2      	; 0x27ec <ldexp+0x50>
    27ea:	b1 60       	ori	r27, 0x01	; 1
    27ec:	93 95       	inc	r25
    27ee:	c1 f7       	brne	.-16     	; 0x27e0 <ldexp+0x44>
    27f0:	bb 0f       	add	r27, r27
    27f2:	58 f7       	brcc	.-42     	; 0x27ca <ldexp+0x2e>
    27f4:	11 f4       	brne	.+4      	; 0x27fa <ldexp+0x5e>
    27f6:	60 ff       	sbrs	r22, 0
    27f8:	e8 cf       	rjmp	.-48     	; 0x27ca <ldexp+0x2e>
    27fa:	6f 5f       	subi	r22, 0xFF	; 255
    27fc:	7f 4f       	sbci	r23, 0xFF	; 255
    27fe:	8f 4f       	sbci	r24, 0xFF	; 255
    2800:	9f 4f       	sbci	r25, 0xFF	; 255
    2802:	e3 cf       	rjmp	.-58     	; 0x27ca <ldexp+0x2e>
    2804:	0c 94 99 12 	jmp	0x2532	; 0x2532 <__fp_szero>
    2808:	16 f0       	brts	.+4      	; 0x280e <ldexp+0x72>
    280a:	0c 94 88 14 	jmp	0x2910	; 0x2910 <__fp_mpack>
    280e:	0c 94 54 12 	jmp	0x24a8	; 0x24a8 <__fp_nan>
    2812:	68 94       	set
    2814:	0c 94 4e 12 	jmp	0x249c	; 0x249c <__fp_inf>

00002818 <log>:
    2818:	0e 94 7e 12 	call	0x24fc	; 0x24fc <__fp_splitA>
    281c:	a8 f3       	brcs	.-22     	; 0x2808 <ldexp+0x6c>
    281e:	99 23       	and	r25, r25
    2820:	c1 f3       	breq	.-16     	; 0x2812 <ldexp+0x76>
    2822:	ae f3       	brts	.-22     	; 0x280e <ldexp+0x72>
    2824:	df 93       	push	r29
    2826:	cf 93       	push	r28
    2828:	1f 93       	push	r17
    282a:	0f 93       	push	r16
    282c:	ff 92       	push	r15
    282e:	c9 2f       	mov	r28, r25
    2830:	dd 27       	eor	r29, r29
    2832:	88 23       	and	r24, r24
    2834:	2a f0       	brmi	.+10     	; 0x2840 <log+0x28>
    2836:	21 97       	sbiw	r28, 0x01	; 1
    2838:	66 0f       	add	r22, r22
    283a:	77 1f       	adc	r23, r23
    283c:	88 1f       	adc	r24, r24
    283e:	da f7       	brpl	.-10     	; 0x2836 <log+0x1e>
    2840:	20 e0       	ldi	r18, 0x00	; 0
    2842:	30 e0       	ldi	r19, 0x00	; 0
    2844:	40 e8       	ldi	r20, 0x80	; 128
    2846:	5f eb       	ldi	r21, 0xBF	; 191
    2848:	9f e3       	ldi	r25, 0x3F	; 63
    284a:	88 39       	cpi	r24, 0x98	; 152
    284c:	20 f0       	brcs	.+8      	; 0x2856 <log+0x3e>
    284e:	80 3e       	cpi	r24, 0xE0	; 224
    2850:	38 f0       	brcs	.+14     	; 0x2860 <log+0x48>
    2852:	21 96       	adiw	r28, 0x01	; 1
    2854:	8f 77       	andi	r24, 0x7F	; 127
    2856:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__addsf3>
    285a:	ec e7       	ldi	r30, 0x7C	; 124
    285c:	f0 e0       	ldi	r31, 0x00	; 0
    285e:	04 c0       	rjmp	.+8      	; 0x2868 <log+0x50>
    2860:	0e 94 db 10 	call	0x21b6	; 0x21b6 <__addsf3>
    2864:	e9 ea       	ldi	r30, 0xA9	; 169
    2866:	f0 e0       	ldi	r31, 0x00	; 0
    2868:	0e 94 9b 13 	call	0x2736	; 0x2736 <__fp_powser>
    286c:	8b 01       	movw	r16, r22
    286e:	be 01       	movw	r22, r28
    2870:	ec 01       	movw	r28, r24
    2872:	fb 2e       	mov	r15, r27
    2874:	6f 57       	subi	r22, 0x7F	; 127
    2876:	71 09       	sbc	r23, r1
    2878:	75 95       	asr	r23
    287a:	77 1f       	adc	r23, r23
    287c:	88 0b       	sbc	r24, r24
    287e:	99 0b       	sbc	r25, r25
    2880:	0e 94 ef 11 	call	0x23de	; 0x23de <__floatsisf>
    2884:	28 e1       	ldi	r18, 0x18	; 24
    2886:	32 e7       	ldi	r19, 0x72	; 114
    2888:	41 e3       	ldi	r20, 0x31	; 49
    288a:	5f e3       	ldi	r21, 0x3F	; 63
    288c:	0e 94 b7 12 	call	0x256e	; 0x256e <__mulsf3x>
    2890:	af 2d       	mov	r26, r15
    2892:	98 01       	movw	r18, r16
    2894:	ae 01       	movw	r20, r28
    2896:	ff 90       	pop	r15
    2898:	0f 91       	pop	r16
    289a:	1f 91       	pop	r17
    289c:	cf 91       	pop	r28
    289e:	df 91       	pop	r29
    28a0:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <__addsf3x>
    28a4:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <__fp_round>

000028a8 <modf>:
    28a8:	fa 01       	movw	r30, r20
    28aa:	dc 01       	movw	r26, r24
    28ac:	aa 0f       	add	r26, r26
    28ae:	bb 1f       	adc	r27, r27
    28b0:	9b 01       	movw	r18, r22
    28b2:	ac 01       	movw	r20, r24
    28b4:	bf 57       	subi	r27, 0x7F	; 127
    28b6:	28 f4       	brcc	.+10     	; 0x28c2 <modf+0x1a>
    28b8:	22 27       	eor	r18, r18
    28ba:	33 27       	eor	r19, r19
    28bc:	44 27       	eor	r20, r20
    28be:	50 78       	andi	r21, 0x80	; 128
    28c0:	20 c0       	rjmp	.+64     	; 0x2902 <modf+0x5a>
    28c2:	b7 51       	subi	r27, 0x17	; 23
    28c4:	90 f4       	brcc	.+36     	; 0x28ea <modf+0x42>
    28c6:	ab 2f       	mov	r26, r27
    28c8:	00 24       	eor	r0, r0
    28ca:	46 95       	lsr	r20
    28cc:	37 95       	ror	r19
    28ce:	27 95       	ror	r18
    28d0:	01 1c       	adc	r0, r1
    28d2:	a3 95       	inc	r26
    28d4:	d2 f3       	brmi	.-12     	; 0x28ca <modf+0x22>
    28d6:	00 20       	and	r0, r0
    28d8:	71 f0       	breq	.+28     	; 0x28f6 <modf+0x4e>
    28da:	22 0f       	add	r18, r18
    28dc:	33 1f       	adc	r19, r19
    28de:	44 1f       	adc	r20, r20
    28e0:	b3 95       	inc	r27
    28e2:	da f3       	brmi	.-10     	; 0x28da <modf+0x32>
    28e4:	0e d0       	rcall	.+28     	; 0x2902 <modf+0x5a>
    28e6:	0c 94 da 10 	jmp	0x21b4	; 0x21b4 <__subsf3>
    28ea:	61 30       	cpi	r22, 0x01	; 1
    28ec:	71 05       	cpc	r23, r1
    28ee:	a0 e8       	ldi	r26, 0x80	; 128
    28f0:	8a 07       	cpc	r24, r26
    28f2:	b9 46       	sbci	r27, 0x69	; 105
    28f4:	30 f4       	brcc	.+12     	; 0x2902 <modf+0x5a>
    28f6:	9b 01       	movw	r18, r22
    28f8:	ac 01       	movw	r20, r24
    28fa:	66 27       	eor	r22, r22
    28fc:	77 27       	eor	r23, r23
    28fe:	88 27       	eor	r24, r24
    2900:	90 78       	andi	r25, 0x80	; 128
    2902:	30 96       	adiw	r30, 0x00	; 0
    2904:	21 f0       	breq	.+8      	; 0x290e <modf+0x66>
    2906:	20 83       	st	Z, r18
    2908:	31 83       	std	Z+1, r19	; 0x01
    290a:	42 83       	std	Z+2, r20	; 0x02
    290c:	53 83       	std	Z+3, r21	; 0x03
    290e:	08 95       	ret

00002910 <__fp_mpack>:
    2910:	9f 3f       	cpi	r25, 0xFF	; 255
    2912:	31 f0       	breq	.+12     	; 0x2920 <__fp_mpack_finite+0xc>

00002914 <__fp_mpack_finite>:
    2914:	91 50       	subi	r25, 0x01	; 1
    2916:	20 f4       	brcc	.+8      	; 0x2920 <__fp_mpack_finite+0xc>
    2918:	87 95       	ror	r24
    291a:	77 95       	ror	r23
    291c:	67 95       	ror	r22
    291e:	b7 95       	ror	r27
    2920:	88 0f       	add	r24, r24
    2922:	91 1d       	adc	r25, r1
    2924:	96 95       	lsr	r25
    2926:	87 95       	ror	r24
    2928:	97 f9       	bld	r25, 7
    292a:	08 95       	ret

0000292c <strcmp>:
    292c:	fb 01       	movw	r30, r22
    292e:	dc 01       	movw	r26, r24
    2930:	8d 91       	ld	r24, X+
    2932:	01 90       	ld	r0, Z+
    2934:	80 19       	sub	r24, r0
    2936:	01 10       	cpse	r0, r1
    2938:	d9 f3       	breq	.-10     	; 0x2930 <strcmp+0x4>
    293a:	99 0b       	sbc	r25, r25
    293c:	08 95       	ret

0000293e <_exit>:
    293e:	f8 94       	cli

00002940 <__stop_program>:
    2940:	ff cf       	rjmp	.-2      	; 0x2940 <__stop_program>
