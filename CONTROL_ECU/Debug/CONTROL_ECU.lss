
CONTROL_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002852  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000066  00800060  00002852  000028e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008e  008000c6  008000c6  0000294c  2**0
                  ALLOC
  3 .stab         0000321c  00000000  00000000  0000294c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001567  00000000  00000000  00005b68  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000070cf  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000070e0  2**2
                  CONTENTS, READONLY
  7 .debug_info   0000052e  00000000  00000000  0000711c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004e7  00000000  00000000  0000764a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00007b31  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001af  00000000  00000000  00007b4b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 04 09 	jmp	0x1208	; 0x1208 <__vector_3>
      10:	0c 94 3b 09 	jmp	0x1276	; 0x1276 <__vector_4>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 cd 08 	jmp	0x119a	; 0x119a <__vector_6>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 96 08 	jmp	0x112c	; 0x112c <__vector_8>
      24:	0c 94 5f 08 	jmp	0x10be	; 0x10be <__vector_9>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 28 08 	jmp	0x1050	; 0x1050 <__vector_19>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	std	Y+40, r29	; 0x28
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	std	Y+56, r1	; 0x38
      62:	ba ab       	std	Y+50, r27	; 0x32
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	std	Y+54, r27	; 0x36
      96:	aa aa       	std	Y+50, r10	; 0x32
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	ldd	r30, Z+49	; 0x31
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__stack+0x471>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d4 e0       	ldi	r29, 0x04	; 4
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	e2 e5       	ldi	r30, 0x52	; 82
      ea:	f8 e2       	ldi	r31, 0x28	; 40
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	a6 3c       	cpi	r26, 0xC6	; 198
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	21 e0       	ldi	r18, 0x01	; 1
      fa:	a6 ec       	ldi	r26, 0xC6	; 198
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	a4 35       	cpi	r26, 0x54	; 84
     104:	b2 07       	cpc	r27, r18
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 8a 00 	call	0x114	; 0x114 <main>
     10c:	0c 94 27 14 	jmp	0x284e	; 0x284e <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <main>:
uint8 count_password_tring=0;
uint8 data_temp;


int main(void)
{
     114:	0f 93       	push	r16
     116:	1f 93       	push	r17
     118:	cf 93       	push	r28
     11a:	df 93       	push	r29
     11c:	cd b7       	in	r28, 0x3d	; 61
     11e:	de b7       	in	r29, 0x3e	; 62
     120:	cd 56       	subi	r28, 0x6D	; 109
     122:	d1 09       	sbc	r29, r1
     124:	0f b6       	in	r0, 0x3f	; 63
     126:	f8 94       	cli
     128:	de bf       	out	0x3e, r29	; 62
     12a:	0f be       	out	0x3f, r0	; 63
     12c:	cd bf       	out	0x3d, r28	; 61
	SREG|=(1<<7); /*Global interrupt enable */
     12e:	8f e5       	ldi	r24, 0x5F	; 95
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	2f e5       	ldi	r18, 0x5F	; 95
     134:	30 e0       	ldi	r19, 0x00	; 0
     136:	f9 01       	movw	r30, r18
     138:	20 81       	ld	r18, Z
     13a:	20 68       	ori	r18, 0x80	; 128
     13c:	fc 01       	movw	r30, r24
     13e:	20 83       	st	Z, r18
/*	initialize peripheral  */

	/* UART initialization */
		UART_configurationType UART_config ;
		UART_config.buadRate=9600;
     140:	9e 01       	movw	r18, r28
     142:	2b 5a       	subi	r18, 0xAB	; 171
     144:	3f 4f       	sbci	r19, 0xFF	; 255
     146:	80 e8       	ldi	r24, 0x80	; 128
     148:	95 e2       	ldi	r25, 0x25	; 37
     14a:	a0 e0       	ldi	r26, 0x00	; 0
     14c:	b0 e0       	ldi	r27, 0x00	; 0
     14e:	f9 01       	movw	r30, r18
     150:	81 83       	std	Z+1, r24	; 0x01
     152:	92 83       	std	Z+2, r25	; 0x02
     154:	a3 83       	std	Z+3, r26	; 0x03
     156:	b4 83       	std	Z+4, r27	; 0x04
		UART_config.character_size=8;
     158:	ce 01       	movw	r24, r28
     15a:	8b 5a       	subi	r24, 0xAB	; 171
     15c:	9f 4f       	sbci	r25, 0xFF	; 255
     15e:	28 e0       	ldi	r18, 0x08	; 8
     160:	fc 01       	movw	r30, r24
     162:	20 83       	st	Z, r18
		strcpy(UART_config.mode,"double speed");
     164:	ce 01       	movw	r24, r28
     166:	8b 5a       	subi	r24, 0xAB	; 171
     168:	9f 4f       	sbci	r25, 0xFF	; 255
     16a:	05 96       	adiw	r24, 0x05	; 5
     16c:	2d e0       	ldi	r18, 0x0D	; 13
     16e:	e0 e6       	ldi	r30, 0x60	; 96
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	dc 01       	movw	r26, r24
     174:	01 90       	ld	r0, Z+
     176:	0d 92       	st	X+, r0
     178:	2a 95       	dec	r18
     17a:	e1 f7       	brne	.-8      	; 0x174 <main+0x60>
		UART_init(&UART_config);
     17c:	ce 01       	movw	r24, r28
     17e:	8b 5a       	subi	r24, 0xAB	; 171
     180:	9f 4f       	sbci	r25, 0xFF	; 255
     182:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <UART_init>

	/*EEPROM initialization */
		EEPROM_init();
     186:	0e 94 6d 05 	call	0xada	; 0xada <EEPROM_init>

	/* TIMER configuration which set in actuators module */
		timer_set();
     18a:	0e 94 9d 04 	call	0x93a	; 0x93a <timer_set>
     18e:	80 e0       	ldi	r24, 0x00	; 0
     190:	90 e0       	ldi	r25, 0x00	; 0
     192:	a8 ec       	ldi	r26, 0xC8	; 200
     194:	b2 e4       	ldi	r27, 0x42	; 66
     196:	8d 8b       	std	Y+21, r24	; 0x15
     198:	9e 8b       	std	Y+22, r25	; 0x16
     19a:	af 8b       	std	Y+23, r26	; 0x17
     19c:	b8 8f       	std	Y+24, r27	; 0x18

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	4a ef       	ldi	r20, 0xFA	; 250
     1a4:	54 e4       	ldi	r21, 0x44	; 68
     1a6:	6d 89       	ldd	r22, Y+21	; 0x15
     1a8:	7e 89       	ldd	r23, Y+22	; 0x16
     1aa:	8f 89       	ldd	r24, Y+23	; 0x17
     1ac:	98 8d       	ldd	r25, Y+24	; 0x18
     1ae:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     1b2:	dc 01       	movw	r26, r24
     1b4:	cb 01       	movw	r24, r22
     1b6:	89 8f       	std	Y+25, r24	; 0x19
     1b8:	9a 8f       	std	Y+26, r25	; 0x1a
     1ba:	ab 8f       	std	Y+27, r26	; 0x1b
     1bc:	bc 8f       	std	Y+28, r27	; 0x1c
	if (__tmp < 1.0)
     1be:	20 e0       	ldi	r18, 0x00	; 0
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e8       	ldi	r20, 0x80	; 128
     1c4:	5f e3       	ldi	r21, 0x3F	; 63
     1c6:	69 8d       	ldd	r22, Y+25	; 0x19
     1c8:	7a 8d       	ldd	r23, Y+26	; 0x1a
     1ca:	8b 8d       	ldd	r24, Y+27	; 0x1b
     1cc:	9c 8d       	ldd	r25, Y+28	; 0x1c
     1ce:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     1d2:	88 23       	and	r24, r24
     1d4:	2c f4       	brge	.+10     	; 0x1e0 <main+0xcc>
		__ticks = 1;
     1d6:	81 e0       	ldi	r24, 0x01	; 1
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	9e 8f       	std	Y+30, r25	; 0x1e
     1dc:	8d 8f       	std	Y+29, r24	; 0x1d
     1de:	3f c0       	rjmp	.+126    	; 0x25e <main+0x14a>
	else if (__tmp > 65535)
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	3f ef       	ldi	r19, 0xFF	; 255
     1e4:	4f e7       	ldi	r20, 0x7F	; 127
     1e6:	57 e4       	ldi	r21, 0x47	; 71
     1e8:	69 8d       	ldd	r22, Y+25	; 0x19
     1ea:	7a 8d       	ldd	r23, Y+26	; 0x1a
     1ec:	8b 8d       	ldd	r24, Y+27	; 0x1b
     1ee:	9c 8d       	ldd	r25, Y+28	; 0x1c
     1f0:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     1f4:	18 16       	cp	r1, r24
     1f6:	4c f5       	brge	.+82     	; 0x24a <main+0x136>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     1f8:	20 e0       	ldi	r18, 0x00	; 0
     1fa:	30 e0       	ldi	r19, 0x00	; 0
     1fc:	40 e2       	ldi	r20, 0x20	; 32
     1fe:	51 e4       	ldi	r21, 0x41	; 65
     200:	6d 89       	ldd	r22, Y+21	; 0x15
     202:	7e 89       	ldd	r23, Y+22	; 0x16
     204:	8f 89       	ldd	r24, Y+23	; 0x17
     206:	98 8d       	ldd	r25, Y+24	; 0x18
     208:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     20c:	dc 01       	movw	r26, r24
     20e:	cb 01       	movw	r24, r22
     210:	bc 01       	movw	r22, r24
     212:	cd 01       	movw	r24, r26
     214:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     218:	dc 01       	movw	r26, r24
     21a:	cb 01       	movw	r24, r22
     21c:	9e 8f       	std	Y+30, r25	; 0x1e
     21e:	8d 8f       	std	Y+29, r24	; 0x1d
     220:	0f c0       	rjmp	.+30     	; 0x240 <main+0x12c>
     222:	88 ec       	ldi	r24, 0xC8	; 200
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	98 a3       	std	Y+32, r25	; 0x20
     228:	8f 8f       	std	Y+31, r24	; 0x1f
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     22a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     22c:	98 a1       	ldd	r25, Y+32	; 0x20
     22e:	01 97       	sbiw	r24, 0x01	; 1
     230:	f1 f7       	brne	.-4      	; 0x22e <main+0x11a>
     232:	98 a3       	std	Y+32, r25	; 0x20
     234:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     236:	8d 8d       	ldd	r24, Y+29	; 0x1d
     238:	9e 8d       	ldd	r25, Y+30	; 0x1e
     23a:	01 97       	sbiw	r24, 0x01	; 1
     23c:	9e 8f       	std	Y+30, r25	; 0x1e
     23e:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     240:	8d 8d       	ldd	r24, Y+29	; 0x1d
     242:	9e 8d       	ldd	r25, Y+30	; 0x1e
     244:	89 2b       	or	r24, r25
     246:	69 f7       	brne	.-38     	; 0x222 <main+0x10e>
     248:	14 c0       	rjmp	.+40     	; 0x272 <main+0x15e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     24a:	69 8d       	ldd	r22, Y+25	; 0x19
     24c:	7a 8d       	ldd	r23, Y+26	; 0x1a
     24e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     250:	9c 8d       	ldd	r25, Y+28	; 0x1c
     252:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     256:	dc 01       	movw	r26, r24
     258:	cb 01       	movw	r24, r22
     25a:	9e 8f       	std	Y+30, r25	; 0x1e
     25c:	8d 8f       	std	Y+29, r24	; 0x1d
     25e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     260:	9e 8d       	ldd	r25, Y+30	; 0x1e
     262:	9a a3       	std	Y+34, r25	; 0x22
     264:	89 a3       	std	Y+33, r24	; 0x21
     266:	89 a1       	ldd	r24, Y+33	; 0x21
     268:	9a a1       	ldd	r25, Y+34	; 0x22
     26a:	01 97       	sbiw	r24, 0x01	; 1
     26c:	f1 f7       	brne	.-4      	; 0x26a <main+0x156>
     26e:	9a a3       	std	Y+34, r25	; 0x22
     270:	89 a3       	std	Y+33, r24	; 0x21
 	   	_delay_ms(100); /* delay to force UART in control_ECU synchronize with HMI_ECU */


 	   	/*check on a password stored flag if it equal predefine pattern=0xAA in specified address 0x0011
 	  */
    	EEPROM_readByte(0x0011,&password_stored_flag);
     272:	6e ee       	ldi	r22, 0xEE	; 238
     274:	70 e0       	ldi	r23, 0x00	; 0
     276:	81 e1       	ldi	r24, 0x11	; 17
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	0e 94 c8 05 	call	0xb90	; 0xb90 <EEPROM_readByte>

/***************************************************************
* 		CASE 0 : password already set	*
* *************************************************************
*/
    	if(((password_stored_flag ==0xAA)&&(count_password_tring<3)&&(set_password_now_flag==0)&&(!block_buzzer_scope)))
     27e:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     282:	8a 3a       	cpi	r24, 0xAA	; 170
     284:	09 f0       	breq	.+2      	; 0x288 <main+0x174>
     286:	a0 c1       	rjmp	.+832    	; 0x5c8 <__stack+0x169>
     288:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <count_password_tring>
     28c:	83 30       	cpi	r24, 0x03	; 3
     28e:	08 f0       	brcs	.+2      	; 0x292 <main+0x17e>
     290:	9b c1       	rjmp	.+822    	; 0x5c8 <__stack+0x169>
     292:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     296:	88 23       	and	r24, r24
     298:	09 f0       	breq	.+2      	; 0x29c <main+0x188>
     29a:	96 c1       	rjmp	.+812    	; 0x5c8 <__stack+0x169>
     29c:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <block_buzzer_scope>
     2a0:	88 23       	and	r24, r24
     2a2:	09 f0       	breq	.+2      	; 0x2a6 <main+0x192>
     2a4:	91 c1       	rjmp	.+802    	; 0x5c8 <__stack+0x169>
 * is stored in EEPROM and
 *  not exceeded 3 times trying to enter password
 * user dosent set the password now as no need to check password
 * waiting 1 minutes until finishing waring
 */
    		UART_sendByte('e'); /* send 'e' point to enter password */
     2a6:	85 e6       	ldi	r24, 0x65	; 101
     2a8:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>
     2ac:	80 e0       	ldi	r24, 0x00	; 0
     2ae:	90 e0       	ldi	r25, 0x00	; 0
     2b0:	a0 e2       	ldi	r26, 0x20	; 32
     2b2:	b1 e4       	ldi	r27, 0x41	; 65
     2b4:	89 87       	std	Y+9, r24	; 0x09
     2b6:	9a 87       	std	Y+10, r25	; 0x0a
     2b8:	ab 87       	std	Y+11, r26	; 0x0b
     2ba:	bc 87       	std	Y+12, r27	; 0x0c

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     2bc:	20 e0       	ldi	r18, 0x00	; 0
     2be:	30 e0       	ldi	r19, 0x00	; 0
     2c0:	4a ef       	ldi	r20, 0xFA	; 250
     2c2:	54 e4       	ldi	r21, 0x44	; 68
     2c4:	69 85       	ldd	r22, Y+9	; 0x09
     2c6:	7a 85       	ldd	r23, Y+10	; 0x0a
     2c8:	8b 85       	ldd	r24, Y+11	; 0x0b
     2ca:	9c 85       	ldd	r25, Y+12	; 0x0c
     2cc:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     2d0:	dc 01       	movw	r26, r24
     2d2:	cb 01       	movw	r24, r22
     2d4:	8f ab       	std	Y+55, r24	; 0x37
     2d6:	98 af       	std	Y+56, r25	; 0x38
     2d8:	a9 af       	std	Y+57, r26	; 0x39
     2da:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
     2dc:	20 e0       	ldi	r18, 0x00	; 0
     2de:	30 e0       	ldi	r19, 0x00	; 0
     2e0:	40 e8       	ldi	r20, 0x80	; 128
     2e2:	5f e3       	ldi	r21, 0x3F	; 63
     2e4:	6f a9       	ldd	r22, Y+55	; 0x37
     2e6:	78 ad       	ldd	r23, Y+56	; 0x38
     2e8:	89 ad       	ldd	r24, Y+57	; 0x39
     2ea:	9a ad       	ldd	r25, Y+58	; 0x3a
     2ec:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     2f0:	88 23       	and	r24, r24
     2f2:	2c f4       	brge	.+10     	; 0x2fe <main+0x1ea>
		__ticks = 1;
     2f4:	81 e0       	ldi	r24, 0x01	; 1
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	9c af       	std	Y+60, r25	; 0x3c
     2fa:	8b af       	std	Y+59, r24	; 0x3b
     2fc:	3f c0       	rjmp	.+126    	; 0x37c <main+0x268>
	else if (__tmp > 65535)
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	3f ef       	ldi	r19, 0xFF	; 255
     302:	4f e7       	ldi	r20, 0x7F	; 127
     304:	57 e4       	ldi	r21, 0x47	; 71
     306:	6f a9       	ldd	r22, Y+55	; 0x37
     308:	78 ad       	ldd	r23, Y+56	; 0x38
     30a:	89 ad       	ldd	r24, Y+57	; 0x39
     30c:	9a ad       	ldd	r25, Y+58	; 0x3a
     30e:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     312:	18 16       	cp	r1, r24
     314:	4c f5       	brge	.+82     	; 0x368 <main+0x254>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     316:	20 e0       	ldi	r18, 0x00	; 0
     318:	30 e0       	ldi	r19, 0x00	; 0
     31a:	40 e2       	ldi	r20, 0x20	; 32
     31c:	51 e4       	ldi	r21, 0x41	; 65
     31e:	69 85       	ldd	r22, Y+9	; 0x09
     320:	7a 85       	ldd	r23, Y+10	; 0x0a
     322:	8b 85       	ldd	r24, Y+11	; 0x0b
     324:	9c 85       	ldd	r25, Y+12	; 0x0c
     326:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     32a:	dc 01       	movw	r26, r24
     32c:	cb 01       	movw	r24, r22
     32e:	bc 01       	movw	r22, r24
     330:	cd 01       	movw	r24, r26
     332:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     336:	dc 01       	movw	r26, r24
     338:	cb 01       	movw	r24, r22
     33a:	9c af       	std	Y+60, r25	; 0x3c
     33c:	8b af       	std	Y+59, r24	; 0x3b
     33e:	0f c0       	rjmp	.+30     	; 0x35e <main+0x24a>
     340:	88 ec       	ldi	r24, 0xC8	; 200
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	9e af       	std	Y+62, r25	; 0x3e
     346:	8d af       	std	Y+61, r24	; 0x3d
     348:	8d ad       	ldd	r24, Y+61	; 0x3d
     34a:	9e ad       	ldd	r25, Y+62	; 0x3e
     34c:	01 97       	sbiw	r24, 0x01	; 1
     34e:	f1 f7       	brne	.-4      	; 0x34c <main+0x238>
     350:	9e af       	std	Y+62, r25	; 0x3e
     352:	8d af       	std	Y+61, r24	; 0x3d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     354:	8b ad       	ldd	r24, Y+59	; 0x3b
     356:	9c ad       	ldd	r25, Y+60	; 0x3c
     358:	01 97       	sbiw	r24, 0x01	; 1
     35a:	9c af       	std	Y+60, r25	; 0x3c
     35c:	8b af       	std	Y+59, r24	; 0x3b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     35e:	8b ad       	ldd	r24, Y+59	; 0x3b
     360:	9c ad       	ldd	r25, Y+60	; 0x3c
     362:	89 2b       	or	r24, r25
     364:	69 f7       	brne	.-38     	; 0x340 <main+0x22c>
     366:	1e c0       	rjmp	.+60     	; 0x3a4 <main+0x290>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     368:	6f a9       	ldd	r22, Y+55	; 0x37
     36a:	78 ad       	ldd	r23, Y+56	; 0x38
     36c:	89 ad       	ldd	r24, Y+57	; 0x39
     36e:	9a ad       	ldd	r25, Y+58	; 0x3a
     370:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     374:	dc 01       	movw	r26, r24
     376:	cb 01       	movw	r24, r22
     378:	9c af       	std	Y+60, r25	; 0x3c
     37a:	8b af       	std	Y+59, r24	; 0x3b
     37c:	2b ad       	ldd	r18, Y+59	; 0x3b
     37e:	3c ad       	ldd	r19, Y+60	; 0x3c
     380:	ce 01       	movw	r24, r28
     382:	cf 96       	adiw	r24, 0x3f	; 63
     384:	fc 01       	movw	r30, r24
     386:	31 83       	std	Z+1, r19	; 0x01
     388:	20 83       	st	Z, r18
     38a:	ce 01       	movw	r24, r28
     38c:	cf 96       	adiw	r24, 0x3f	; 63
     38e:	fc 01       	movw	r30, r24
     390:	80 81       	ld	r24, Z
     392:	91 81       	ldd	r25, Z+1	; 0x01
     394:	01 97       	sbiw	r24, 0x01	; 1
     396:	f1 f7       	brne	.-4      	; 0x394 <main+0x280>
     398:	9e 01       	movw	r18, r28
     39a:	21 5c       	subi	r18, 0xC1	; 193
     39c:	3f 4f       	sbci	r19, 0xFF	; 255
     39e:	f9 01       	movw	r30, r18
     3a0:	91 83       	std	Z+1, r25	; 0x01
     3a2:	80 83       	st	Z, r24
     	   	_delay_ms(10);
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
     3a4:	8a ed       	ldi	r24, 0xDA	; 218
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <UART_receiveString>
     3ac:	80 e0       	ldi	r24, 0x00	; 0
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	a0 e2       	ldi	r26, 0x20	; 32
     3b2:	b1 e4       	ldi	r27, 0x41	; 65
     3b4:	8d 87       	std	Y+13, r24	; 0x0d
     3b6:	9e 87       	std	Y+14, r25	; 0x0e
     3b8:	af 87       	std	Y+15, r26	; 0x0f
     3ba:	b8 8b       	std	Y+16, r27	; 0x10

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     3bc:	20 e0       	ldi	r18, 0x00	; 0
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	4a ef       	ldi	r20, 0xFA	; 250
     3c2:	54 e4       	ldi	r21, 0x44	; 68
     3c4:	6d 85       	ldd	r22, Y+13	; 0x0d
     3c6:	7e 85       	ldd	r23, Y+14	; 0x0e
     3c8:	8f 85       	ldd	r24, Y+15	; 0x0f
     3ca:	98 89       	ldd	r25, Y+16	; 0x10
     3cc:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     3d0:	dc 01       	movw	r26, r24
     3d2:	cb 01       	movw	r24, r22
     3d4:	8d a7       	std	Y+45, r24	; 0x2d
     3d6:	9e a7       	std	Y+46, r25	; 0x2e
     3d8:	af a7       	std	Y+47, r26	; 0x2f
     3da:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
     3dc:	20 e0       	ldi	r18, 0x00	; 0
     3de:	30 e0       	ldi	r19, 0x00	; 0
     3e0:	40 e8       	ldi	r20, 0x80	; 128
     3e2:	5f e3       	ldi	r21, 0x3F	; 63
     3e4:	6d a5       	ldd	r22, Y+45	; 0x2d
     3e6:	7e a5       	ldd	r23, Y+46	; 0x2e
     3e8:	8f a5       	ldd	r24, Y+47	; 0x2f
     3ea:	98 a9       	ldd	r25, Y+48	; 0x30
     3ec:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     3f0:	88 23       	and	r24, r24
     3f2:	2c f4       	brge	.+10     	; 0x3fe <main+0x2ea>
		__ticks = 1;
     3f4:	81 e0       	ldi	r24, 0x01	; 1
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	9a ab       	std	Y+50, r25	; 0x32
     3fa:	89 ab       	std	Y+49, r24	; 0x31
     3fc:	3f c0       	rjmp	.+126    	; 0x47c <__stack+0x1d>
	else if (__tmp > 65535)
     3fe:	20 e0       	ldi	r18, 0x00	; 0
     400:	3f ef       	ldi	r19, 0xFF	; 255
     402:	4f e7       	ldi	r20, 0x7F	; 127
     404:	57 e4       	ldi	r21, 0x47	; 71
     406:	6d a5       	ldd	r22, Y+45	; 0x2d
     408:	7e a5       	ldd	r23, Y+46	; 0x2e
     40a:	8f a5       	ldd	r24, Y+47	; 0x2f
     40c:	98 a9       	ldd	r25, Y+48	; 0x30
     40e:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     412:	18 16       	cp	r1, r24
     414:	4c f5       	brge	.+82     	; 0x468 <__stack+0x9>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     416:	20 e0       	ldi	r18, 0x00	; 0
     418:	30 e0       	ldi	r19, 0x00	; 0
     41a:	40 e2       	ldi	r20, 0x20	; 32
     41c:	51 e4       	ldi	r21, 0x41	; 65
     41e:	6d 85       	ldd	r22, Y+13	; 0x0d
     420:	7e 85       	ldd	r23, Y+14	; 0x0e
     422:	8f 85       	ldd	r24, Y+15	; 0x0f
     424:	98 89       	ldd	r25, Y+16	; 0x10
     426:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     42a:	dc 01       	movw	r26, r24
     42c:	cb 01       	movw	r24, r22
     42e:	bc 01       	movw	r22, r24
     430:	cd 01       	movw	r24, r26
     432:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     436:	dc 01       	movw	r26, r24
     438:	cb 01       	movw	r24, r22
     43a:	9a ab       	std	Y+50, r25	; 0x32
     43c:	89 ab       	std	Y+49, r24	; 0x31
     43e:	0f c0       	rjmp	.+30     	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     440:	88 ec       	ldi	r24, 0xC8	; 200
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	9c ab       	std	Y+52, r25	; 0x34
     446:	8b ab       	std	Y+51, r24	; 0x33
     448:	8b a9       	ldd	r24, Y+51	; 0x33
     44a:	9c a9       	ldd	r25, Y+52	; 0x34
     44c:	01 97       	sbiw	r24, 0x01	; 1
     44e:	f1 f7       	brne	.-4      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
     450:	9c ab       	std	Y+52, r25	; 0x34
     452:	8b ab       	std	Y+51, r24	; 0x33
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     454:	89 a9       	ldd	r24, Y+49	; 0x31
     456:	9a a9       	ldd	r25, Y+50	; 0x32
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9a ab       	std	Y+50, r25	; 0x32
     45c:	89 ab       	std	Y+49, r24	; 0x31
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     45e:	89 a9       	ldd	r24, Y+49	; 0x31
     460:	9a a9       	ldd	r25, Y+50	; 0x32
     462:	89 2b       	or	r24, r25
     464:	69 f7       	brne	.-38     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     466:	14 c0       	rjmp	.+40     	; 0x490 <__stack+0x31>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     468:	6d a5       	ldd	r22, Y+45	; 0x2d
     46a:	7e a5       	ldd	r23, Y+46	; 0x2e
     46c:	8f a5       	ldd	r24, Y+47	; 0x2f
     46e:	98 a9       	ldd	r25, Y+48	; 0x30
     470:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     474:	dc 01       	movw	r26, r24
     476:	cb 01       	movw	r24, r22
     478:	9a ab       	std	Y+50, r25	; 0x32
     47a:	89 ab       	std	Y+49, r24	; 0x31
     47c:	89 a9       	ldd	r24, Y+49	; 0x31
     47e:	9a a9       	ldd	r25, Y+50	; 0x32
     480:	9e ab       	std	Y+54, r25	; 0x36
     482:	8d ab       	std	Y+53, r24	; 0x35
     484:	8d a9       	ldd	r24, Y+53	; 0x35
     486:	9e a9       	ldd	r25, Y+54	; 0x36
     488:	01 97       	sbiw	r24, 0x01	; 1
     48a:	f1 f7       	brne	.-4      	; 0x488 <__stack+0x29>
     48c:	9e ab       	std	Y+54, r25	; 0x36
     48e:	8d ab       	std	Y+53, r24	; 0x35
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
     490:	66 ec       	ldi	r22, 0xC6	; 198
     492:	70 e0       	ldi	r23, 0x00	; 0
     494:	82 e1       	ldi	r24, 0x12	; 18
     496:	95 e0       	ldi	r25, 0x05	; 5
     498:	0e 94 df 06 	call	0xdbe	; 0xdbe <EEPROM_readString>
     49c:	80 e0       	ldi	r24, 0x00	; 0
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	a0 e2       	ldi	r26, 0x20	; 32
     4a2:	b1 e4       	ldi	r27, 0x41	; 65
     4a4:	89 83       	std	Y+1, r24	; 0x01
     4a6:	9a 83       	std	Y+2, r25	; 0x02
     4a8:	ab 83       	std	Y+3, r26	; 0x03
     4aa:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     4ac:	20 e0       	ldi	r18, 0x00	; 0
     4ae:	30 e0       	ldi	r19, 0x00	; 0
     4b0:	4a ef       	ldi	r20, 0xFA	; 250
     4b2:	54 e4       	ldi	r21, 0x44	; 68
     4b4:	69 81       	ldd	r22, Y+1	; 0x01
     4b6:	7a 81       	ldd	r23, Y+2	; 0x02
     4b8:	8b 81       	ldd	r24, Y+3	; 0x03
     4ba:	9c 81       	ldd	r25, Y+4	; 0x04
     4bc:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     4c0:	dc 01       	movw	r26, r24
     4c2:	cb 01       	movw	r24, r22
     4c4:	8b a3       	std	Y+35, r24	; 0x23
     4c6:	9c a3       	std	Y+36, r25	; 0x24
     4c8:	ad a3       	std	Y+37, r26	; 0x25
     4ca:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     4cc:	20 e0       	ldi	r18, 0x00	; 0
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	40 e8       	ldi	r20, 0x80	; 128
     4d2:	5f e3       	ldi	r21, 0x3F	; 63
     4d4:	6b a1       	ldd	r22, Y+35	; 0x23
     4d6:	7c a1       	ldd	r23, Y+36	; 0x24
     4d8:	8d a1       	ldd	r24, Y+37	; 0x25
     4da:	9e a1       	ldd	r25, Y+38	; 0x26
     4dc:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     4e0:	88 23       	and	r24, r24
     4e2:	2c f4       	brge	.+10     	; 0x4ee <__stack+0x8f>
		__ticks = 1;
     4e4:	81 e0       	ldi	r24, 0x01	; 1
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	98 a7       	std	Y+40, r25	; 0x28
     4ea:	8f a3       	std	Y+39, r24	; 0x27
     4ec:	3f c0       	rjmp	.+126    	; 0x56c <__stack+0x10d>
	else if (__tmp > 65535)
     4ee:	20 e0       	ldi	r18, 0x00	; 0
     4f0:	3f ef       	ldi	r19, 0xFF	; 255
     4f2:	4f e7       	ldi	r20, 0x7F	; 127
     4f4:	57 e4       	ldi	r21, 0x47	; 71
     4f6:	6b a1       	ldd	r22, Y+35	; 0x23
     4f8:	7c a1       	ldd	r23, Y+36	; 0x24
     4fa:	8d a1       	ldd	r24, Y+37	; 0x25
     4fc:	9e a1       	ldd	r25, Y+38	; 0x26
     4fe:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     502:	18 16       	cp	r1, r24
     504:	4c f5       	brge	.+82     	; 0x558 <__stack+0xf9>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     506:	20 e0       	ldi	r18, 0x00	; 0
     508:	30 e0       	ldi	r19, 0x00	; 0
     50a:	40 e2       	ldi	r20, 0x20	; 32
     50c:	51 e4       	ldi	r21, 0x41	; 65
     50e:	69 81       	ldd	r22, Y+1	; 0x01
     510:	7a 81       	ldd	r23, Y+2	; 0x02
     512:	8b 81       	ldd	r24, Y+3	; 0x03
     514:	9c 81       	ldd	r25, Y+4	; 0x04
     516:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     51a:	dc 01       	movw	r26, r24
     51c:	cb 01       	movw	r24, r22
     51e:	bc 01       	movw	r22, r24
     520:	cd 01       	movw	r24, r26
     522:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     526:	dc 01       	movw	r26, r24
     528:	cb 01       	movw	r24, r22
     52a:	98 a7       	std	Y+40, r25	; 0x28
     52c:	8f a3       	std	Y+39, r24	; 0x27
     52e:	0f c0       	rjmp	.+30     	; 0x54e <__stack+0xef>
     530:	88 ec       	ldi	r24, 0xC8	; 200
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	9a a7       	std	Y+42, r25	; 0x2a
     536:	89 a7       	std	Y+41, r24	; 0x29
     538:	89 a5       	ldd	r24, Y+41	; 0x29
     53a:	9a a5       	ldd	r25, Y+42	; 0x2a
     53c:	01 97       	sbiw	r24, 0x01	; 1
     53e:	f1 f7       	brne	.-4      	; 0x53c <__stack+0xdd>
     540:	9a a7       	std	Y+42, r25	; 0x2a
     542:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     544:	8f a1       	ldd	r24, Y+39	; 0x27
     546:	98 a5       	ldd	r25, Y+40	; 0x28
     548:	01 97       	sbiw	r24, 0x01	; 1
     54a:	98 a7       	std	Y+40, r25	; 0x28
     54c:	8f a3       	std	Y+39, r24	; 0x27
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     54e:	8f a1       	ldd	r24, Y+39	; 0x27
     550:	98 a5       	ldd	r25, Y+40	; 0x28
     552:	89 2b       	or	r24, r25
     554:	69 f7       	brne	.-38     	; 0x530 <__stack+0xd1>
     556:	14 c0       	rjmp	.+40     	; 0x580 <__stack+0x121>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     558:	6b a1       	ldd	r22, Y+35	; 0x23
     55a:	7c a1       	ldd	r23, Y+36	; 0x24
     55c:	8d a1       	ldd	r24, Y+37	; 0x25
     55e:	9e a1       	ldd	r25, Y+38	; 0x26
     560:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     564:	dc 01       	movw	r26, r24
     566:	cb 01       	movw	r24, r22
     568:	98 a7       	std	Y+40, r25	; 0x28
     56a:	8f a3       	std	Y+39, r24	; 0x27
     56c:	8f a1       	ldd	r24, Y+39	; 0x27
     56e:	98 a5       	ldd	r25, Y+40	; 0x28
     570:	9c a7       	std	Y+44, r25	; 0x2c
     572:	8b a7       	std	Y+43, r24	; 0x2b
     574:	8b a5       	ldd	r24, Y+43	; 0x2b
     576:	9c a5       	ldd	r25, Y+44	; 0x2c
     578:	01 97       	sbiw	r24, 0x01	; 1
     57a:	f1 f7       	brne	.-4      	; 0x578 <__stack+0x119>
     57c:	9c a7       	std	Y+44, r25	; 0x2c
     57e:	8b a7       	std	Y+43, r24	; 0x2b
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     580:	66 ec       	ldi	r22, 0xC6	; 198
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	8a ed       	ldi	r24, 0xDA	; 218
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
     58c:	89 2b       	or	r24, r25
     58e:	b1 f4       	brne	.+44     	; 0x5bc <__stack+0x15d>
    		{ /* if entered and stored password are typical
    		 	give user 2 option by sending 'w':
    		 	open door (o)
    		 	reset the password (reset the password (s)
    		 	*/
        		UART_sendByte('w');
     590:	87 e7       	ldi	r24, 0x77	; 119
     592:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>
        		data_temp=UART_receiveByte();
     596:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <UART_receiveByte>
     59a:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <data_temp>
        		if(data_temp=='s')
     59e:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_temp>
     5a2:	83 37       	cpi	r24, 0x73	; 115
     5a4:	21 f4       	brne	.+8      	; 0x5ae <__stack+0x14f>
        			force_set=1;
     5a6:	81 e0       	ldi	r24, 0x01	; 1
     5a8:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <force_set>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5ac:	28 c0       	rjmp	.+80     	; 0x5fe <__stack+0x19f>
    		 	*/
        		UART_sendByte('w');
        		data_temp=UART_receiveByte();
        		if(data_temp=='s')
        			force_set=1;
        		else if(data_temp=='o')
     5ae:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <data_temp>
     5b2:	8f 36       	cpi	r24, 0x6F	; 111
     5b4:	21 f5       	brne	.+72     	; 0x5fe <__stack+0x19f>
        		{
        			 motor_run();
     5b6:	0e 94 bb 04 	call	0x976	; 0x976 <motor_run>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5ba:	21 c0       	rjmp	.+66     	; 0x5fe <__stack+0x19f>
        		}
    		 }
    		else
    		{
    			/* count how many user try enter the password */
    			count_password_tring++;
     5bc:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <count_password_tring>
     5c0:	8f 5f       	subi	r24, 0xFF	; 255
     5c2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <count_password_tring>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5c6:	1b c0       	rjmp	.+54     	; 0x5fe <__stack+0x19f>
/*******************************************************************************
* 		CASE 1 : password already set and user try enter password than 3 times	*
* ******************************************************************************
*/

    	else if((password_stored_flag ==0xAA)&&(count_password_tring>=3)&&(set_password_now_flag==0)&&(!block_buzzer_scope))
     5c8:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     5cc:	8a 3a       	cpi	r24, 0xAA	; 170
     5ce:	c1 f4       	brne	.+48     	; 0x600 <__stack+0x1a1>
     5d0:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <count_password_tring>
     5d4:	83 30       	cpi	r24, 0x03	; 3
     5d6:	a0 f0       	brcs	.+40     	; 0x600 <__stack+0x1a1>
     5d8:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     5dc:	88 23       	and	r24, r24
     5de:	81 f4       	brne	.+32     	; 0x600 <__stack+0x1a1>
     5e0:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <block_buzzer_scope>
     5e4:	88 23       	and	r24, r24
     5e6:	61 f4       	brne	.+24     	; 0x600 <__stack+0x1a1>
    		 * user dosent set the password now as no need to check password
    		 * waiting 1 minutes until finishing waring
    		 */


    		UART_sendByte('B'); /* send 'B' to HMI ECU TO Clear the screan */
     5e8:	82 e4       	ldi	r24, 0x42	; 66
     5ea:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>
    		buzzer(); /* run buzzer warning */
     5ee:	0e 94 25 05 	call	0xa4a	; 0xa4a <buzzer>
    		block_buzzer_scope=1; /* block this scope until timer spend 1 minute and the timer ISR will return it to zero*/
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <block_buzzer_scope>
    		count_password_tring=0; /*restart the operation */
     5f8:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <count_password_tring>
     5fc:	01 c0       	rjmp	.+2      	; 0x600 <__stack+0x1a1>
     	   	/* receive entered password and compare with that was stored in EEPROM */
    	    	UART_receiveString(enter_password_stored);
    	   	_delay_ms(10);
    		EEPROM_readString(0x0512, check_password_stored);
    	    		_delay_ms(10);
    		if(!strcmp(enter_password_stored,check_password_stored))
     5fe:	00 00       	nop
    	/***************************************************************
    	* 		CASE 2 : first time and user should set password	*
    	* *************************************************************
    	*/

    	if(((password_stored_flag !=0xAA)&&(set_password_now_flag==0))||force_set)
     600:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <password_stored_flag>
     604:	8a 3a       	cpi	r24, 0xAA	; 170
     606:	21 f0       	breq	.+8      	; 0x610 <__stack+0x1b1>
     608:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <set_password_now_flag>
     60c:	88 23       	and	r24, r24
     60e:	29 f0       	breq	.+10     	; 0x61a <__stack+0x1bb>
     610:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <force_set>
     614:	88 23       	and	r24, r24
     616:	09 f4       	brne	.+2      	; 0x61a <__stack+0x1bb>
     618:	ba cd       	rjmp	.-1164   	; 0x18e <main+0x7a>
    		/* condition to enter this case
    		 *  password is not stored in EEPROM
    		 * user dosent set the password now as no need to reset the password
    		 */

        	UART_sendByte('s'); /*send 's' to tell HMI ECU that CONTROL ECU  ready to store the new password */
     61a:	83 e7       	ldi	r24, 0x73	; 115
     61c:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>
    	UART_receiveString(password_stored);
     620:	88 ef       	ldi	r24, 0xF8	; 248
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <UART_receiveString>
     628:	80 e0       	ldi	r24, 0x00	; 0
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	a8 ec       	ldi	r26, 0xC8	; 200
     62e:	b2 e4       	ldi	r27, 0x42	; 66
     630:	89 8b       	std	Y+17, r24	; 0x11
     632:	9a 8b       	std	Y+18, r25	; 0x12
     634:	ab 8b       	std	Y+19, r26	; 0x13
     636:	bc 8b       	std	Y+20, r27	; 0x14

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     638:	8e 01       	movw	r16, r28
     63a:	05 5b       	subi	r16, 0xB5	; 181
     63c:	1f 4f       	sbci	r17, 0xFF	; 255
     63e:	20 e0       	ldi	r18, 0x00	; 0
     640:	30 e0       	ldi	r19, 0x00	; 0
     642:	4a ef       	ldi	r20, 0xFA	; 250
     644:	54 e4       	ldi	r21, 0x44	; 68
     646:	69 89       	ldd	r22, Y+17	; 0x11
     648:	7a 89       	ldd	r23, Y+18	; 0x12
     64a:	8b 89       	ldd	r24, Y+19	; 0x13
     64c:	9c 89       	ldd	r25, Y+20	; 0x14
     64e:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     652:	dc 01       	movw	r26, r24
     654:	cb 01       	movw	r24, r22
     656:	f8 01       	movw	r30, r16
     658:	80 83       	st	Z, r24
     65a:	91 83       	std	Z+1, r25	; 0x01
     65c:	a2 83       	std	Z+2, r26	; 0x02
     65e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     660:	ce 01       	movw	r24, r28
     662:	85 5b       	subi	r24, 0xB5	; 181
     664:	9f 4f       	sbci	r25, 0xFF	; 255
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	40 e8       	ldi	r20, 0x80	; 128
     66c:	5f e3       	ldi	r21, 0x3F	; 63
     66e:	fc 01       	movw	r30, r24
     670:	60 81       	ld	r22, Z
     672:	71 81       	ldd	r23, Z+1	; 0x01
     674:	82 81       	ldd	r24, Z+2	; 0x02
     676:	93 81       	ldd	r25, Z+3	; 0x03
     678:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     67c:	88 23       	and	r24, r24
     67e:	4c f4       	brge	.+18     	; 0x692 <__stack+0x233>
		__ticks = 1;
     680:	ce 01       	movw	r24, r28
     682:	81 5b       	subi	r24, 0xB1	; 177
     684:	9f 4f       	sbci	r25, 0xFF	; 255
     686:	21 e0       	ldi	r18, 0x01	; 1
     688:	30 e0       	ldi	r19, 0x00	; 0
     68a:	fc 01       	movw	r30, r24
     68c:	31 83       	std	Z+1, r19	; 0x01
     68e:	20 83       	st	Z, r18
     690:	69 c0       	rjmp	.+210    	; 0x764 <__stack+0x305>
	else if (__tmp > 65535)
     692:	ce 01       	movw	r24, r28
     694:	85 5b       	subi	r24, 0xB5	; 181
     696:	9f 4f       	sbci	r25, 0xFF	; 255
     698:	20 e0       	ldi	r18, 0x00	; 0
     69a:	3f ef       	ldi	r19, 0xFF	; 255
     69c:	4f e7       	ldi	r20, 0x7F	; 127
     69e:	57 e4       	ldi	r21, 0x47	; 71
     6a0:	fc 01       	movw	r30, r24
     6a2:	60 81       	ld	r22, Z
     6a4:	71 81       	ldd	r23, Z+1	; 0x01
     6a6:	82 81       	ldd	r24, Z+2	; 0x02
     6a8:	93 81       	ldd	r25, Z+3	; 0x03
     6aa:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     6ae:	18 16       	cp	r1, r24
     6b0:	0c f0       	brlt	.+2      	; 0x6b4 <__stack+0x255>
     6b2:	46 c0       	rjmp	.+140    	; 0x740 <__stack+0x2e1>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     6b4:	20 e0       	ldi	r18, 0x00	; 0
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	40 e2       	ldi	r20, 0x20	; 32
     6ba:	51 e4       	ldi	r21, 0x41	; 65
     6bc:	69 89       	ldd	r22, Y+17	; 0x11
     6be:	7a 89       	ldd	r23, Y+18	; 0x12
     6c0:	8b 89       	ldd	r24, Y+19	; 0x13
     6c2:	9c 89       	ldd	r25, Y+20	; 0x14
     6c4:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     6c8:	dc 01       	movw	r26, r24
     6ca:	cb 01       	movw	r24, r22
     6cc:	8e 01       	movw	r16, r28
     6ce:	01 5b       	subi	r16, 0xB1	; 177
     6d0:	1f 4f       	sbci	r17, 0xFF	; 255
     6d2:	bc 01       	movw	r22, r24
     6d4:	cd 01       	movw	r24, r26
     6d6:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     6da:	dc 01       	movw	r26, r24
     6dc:	cb 01       	movw	r24, r22
     6de:	f8 01       	movw	r30, r16
     6e0:	91 83       	std	Z+1, r25	; 0x01
     6e2:	80 83       	st	Z, r24
     6e4:	24 c0       	rjmp	.+72     	; 0x72e <__stack+0x2cf>
     6e6:	ce 01       	movw	r24, r28
     6e8:	8f 5a       	subi	r24, 0xAF	; 175
     6ea:	9f 4f       	sbci	r25, 0xFF	; 255
     6ec:	28 ec       	ldi	r18, 0xC8	; 200
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	fc 01       	movw	r30, r24
     6f2:	31 83       	std	Z+1, r19	; 0x01
     6f4:	20 83       	st	Z, r18
     6f6:	ce 01       	movw	r24, r28
     6f8:	8f 5a       	subi	r24, 0xAF	; 175
     6fa:	9f 4f       	sbci	r25, 0xFF	; 255
     6fc:	fc 01       	movw	r30, r24
     6fe:	80 81       	ld	r24, Z
     700:	91 81       	ldd	r25, Z+1	; 0x01
     702:	01 97       	sbiw	r24, 0x01	; 1
     704:	f1 f7       	brne	.-4      	; 0x702 <__stack+0x2a3>
     706:	9e 01       	movw	r18, r28
     708:	2f 5a       	subi	r18, 0xAF	; 175
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	f9 01       	movw	r30, r18
     70e:	91 83       	std	Z+1, r25	; 0x01
     710:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     712:	ce 01       	movw	r24, r28
     714:	81 5b       	subi	r24, 0xB1	; 177
     716:	9f 4f       	sbci	r25, 0xFF	; 255
     718:	9e 01       	movw	r18, r28
     71a:	21 5b       	subi	r18, 0xB1	; 177
     71c:	3f 4f       	sbci	r19, 0xFF	; 255
     71e:	f9 01       	movw	r30, r18
     720:	20 81       	ld	r18, Z
     722:	31 81       	ldd	r19, Z+1	; 0x01
     724:	21 50       	subi	r18, 0x01	; 1
     726:	31 09       	sbc	r19, r1
     728:	fc 01       	movw	r30, r24
     72a:	31 83       	std	Z+1, r19	; 0x01
     72c:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     72e:	ce 01       	movw	r24, r28
     730:	81 5b       	subi	r24, 0xB1	; 177
     732:	9f 4f       	sbci	r25, 0xFF	; 255
     734:	fc 01       	movw	r30, r24
     736:	80 81       	ld	r24, Z
     738:	91 81       	ldd	r25, Z+1	; 0x01
     73a:	89 2b       	or	r24, r25
     73c:	a1 f6       	brne	.-88     	; 0x6e6 <__stack+0x287>
     73e:	2c c0       	rjmp	.+88     	; 0x798 <__stack+0x339>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     740:	8e 01       	movw	r16, r28
     742:	01 5b       	subi	r16, 0xB1	; 177
     744:	1f 4f       	sbci	r17, 0xFF	; 255
     746:	ce 01       	movw	r24, r28
     748:	85 5b       	subi	r24, 0xB5	; 181
     74a:	9f 4f       	sbci	r25, 0xFF	; 255
     74c:	fc 01       	movw	r30, r24
     74e:	60 81       	ld	r22, Z
     750:	71 81       	ldd	r23, Z+1	; 0x01
     752:	82 81       	ldd	r24, Z+2	; 0x02
     754:	93 81       	ldd	r25, Z+3	; 0x03
     756:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     75a:	dc 01       	movw	r26, r24
     75c:	cb 01       	movw	r24, r22
     75e:	f8 01       	movw	r30, r16
     760:	91 83       	std	Z+1, r25	; 0x01
     762:	80 83       	st	Z, r24
     764:	ce 01       	movw	r24, r28
     766:	8d 5a       	subi	r24, 0xAD	; 173
     768:	9f 4f       	sbci	r25, 0xFF	; 255
     76a:	9e 01       	movw	r18, r28
     76c:	21 5b       	subi	r18, 0xB1	; 177
     76e:	3f 4f       	sbci	r19, 0xFF	; 255
     770:	f9 01       	movw	r30, r18
     772:	20 81       	ld	r18, Z
     774:	31 81       	ldd	r19, Z+1	; 0x01
     776:	fc 01       	movw	r30, r24
     778:	31 83       	std	Z+1, r19	; 0x01
     77a:	20 83       	st	Z, r18
     77c:	ce 01       	movw	r24, r28
     77e:	8d 5a       	subi	r24, 0xAD	; 173
     780:	9f 4f       	sbci	r25, 0xFF	; 255
     782:	fc 01       	movw	r30, r24
     784:	80 81       	ld	r24, Z
     786:	91 81       	ldd	r25, Z+1	; 0x01
     788:	01 97       	sbiw	r24, 0x01	; 1
     78a:	f1 f7       	brne	.-4      	; 0x788 <__stack+0x329>
     78c:	9e 01       	movw	r18, r28
     78e:	2d 5a       	subi	r18, 0xAD	; 173
     790:	3f 4f       	sbci	r19, 0xFF	; 255
     792:	f9 01       	movw	r30, r18
     794:	91 83       	std	Z+1, r25	; 0x01
     796:	80 83       	st	Z, r24
        	_delay_ms(100);
    	EEPROM_writeString(0x0512,password_stored); /* overwrite on old password  in EEPROM*/
     798:	68 ef       	ldi	r22, 0xF8	; 248
     79a:	70 e0       	ldi	r23, 0x00	; 0
     79c:	82 e1       	ldi	r24, 0x12	; 18
     79e:	95 e0       	ldi	r25, 0x05	; 5
     7a0:	0e 94 26 06 	call	0xc4c	; 0xc4c <EEPROM_writeString>
     7a4:	80 e0       	ldi	r24, 0x00	; 0
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	a0 e2       	ldi	r26, 0x20	; 32
     7aa:	b1 e4       	ldi	r27, 0x41	; 65
     7ac:	8d 83       	std	Y+5, r24	; 0x05
     7ae:	9e 83       	std	Y+6, r25	; 0x06
     7b0:	af 83       	std	Y+7, r26	; 0x07
     7b2:	b8 87       	std	Y+8, r27	; 0x08

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     7b4:	8e 01       	movw	r16, r28
     7b6:	0f 5b       	subi	r16, 0xBF	; 191
     7b8:	1f 4f       	sbci	r17, 0xFF	; 255
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	30 e0       	ldi	r19, 0x00	; 0
     7be:	4a ef       	ldi	r20, 0xFA	; 250
     7c0:	54 e4       	ldi	r21, 0x44	; 68
     7c2:	6d 81       	ldd	r22, Y+5	; 0x05
     7c4:	7e 81       	ldd	r23, Y+6	; 0x06
     7c6:	8f 81       	ldd	r24, Y+7	; 0x07
     7c8:	98 85       	ldd	r25, Y+8	; 0x08
     7ca:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     7ce:	dc 01       	movw	r26, r24
     7d0:	cb 01       	movw	r24, r22
     7d2:	f8 01       	movw	r30, r16
     7d4:	80 83       	st	Z, r24
     7d6:	91 83       	std	Z+1, r25	; 0x01
     7d8:	a2 83       	std	Z+2, r26	; 0x02
     7da:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     7dc:	ce 01       	movw	r24, r28
     7de:	8f 5b       	subi	r24, 0xBF	; 191
     7e0:	9f 4f       	sbci	r25, 0xFF	; 255
     7e2:	20 e0       	ldi	r18, 0x00	; 0
     7e4:	30 e0       	ldi	r19, 0x00	; 0
     7e6:	40 e8       	ldi	r20, 0x80	; 128
     7e8:	5f e3       	ldi	r21, 0x3F	; 63
     7ea:	fc 01       	movw	r30, r24
     7ec:	60 81       	ld	r22, Z
     7ee:	71 81       	ldd	r23, Z+1	; 0x01
     7f0:	82 81       	ldd	r24, Z+2	; 0x02
     7f2:	93 81       	ldd	r25, Z+3	; 0x03
     7f4:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     7f8:	88 23       	and	r24, r24
     7fa:	4c f4       	brge	.+18     	; 0x80e <__stack+0x3af>
		__ticks = 1;
     7fc:	ce 01       	movw	r24, r28
     7fe:	8b 5b       	subi	r24, 0xBB	; 187
     800:	9f 4f       	sbci	r25, 0xFF	; 255
     802:	21 e0       	ldi	r18, 0x01	; 1
     804:	30 e0       	ldi	r19, 0x00	; 0
     806:	fc 01       	movw	r30, r24
     808:	31 83       	std	Z+1, r19	; 0x01
     80a:	20 83       	st	Z, r18
     80c:	69 c0       	rjmp	.+210    	; 0x8e0 <__stack+0x481>
	else if (__tmp > 65535)
     80e:	ce 01       	movw	r24, r28
     810:	8f 5b       	subi	r24, 0xBF	; 191
     812:	9f 4f       	sbci	r25, 0xFF	; 255
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	3f ef       	ldi	r19, 0xFF	; 255
     818:	4f e7       	ldi	r20, 0x7F	; 127
     81a:	57 e4       	ldi	r21, 0x47	; 71
     81c:	fc 01       	movw	r30, r24
     81e:	60 81       	ld	r22, Z
     820:	71 81       	ldd	r23, Z+1	; 0x01
     822:	82 81       	ldd	r24, Z+2	; 0x02
     824:	93 81       	ldd	r25, Z+3	; 0x03
     826:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     82a:	18 16       	cp	r1, r24
     82c:	0c f0       	brlt	.+2      	; 0x830 <__stack+0x3d1>
     82e:	46 c0       	rjmp	.+140    	; 0x8bc <__stack+0x45d>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     830:	20 e0       	ldi	r18, 0x00	; 0
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	40 e2       	ldi	r20, 0x20	; 32
     836:	51 e4       	ldi	r21, 0x41	; 65
     838:	6d 81       	ldd	r22, Y+5	; 0x05
     83a:	7e 81       	ldd	r23, Y+6	; 0x06
     83c:	8f 81       	ldd	r24, Y+7	; 0x07
     83e:	98 85       	ldd	r25, Y+8	; 0x08
     840:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     844:	dc 01       	movw	r26, r24
     846:	cb 01       	movw	r24, r22
     848:	8e 01       	movw	r16, r28
     84a:	0b 5b       	subi	r16, 0xBB	; 187
     84c:	1f 4f       	sbci	r17, 0xFF	; 255
     84e:	bc 01       	movw	r22, r24
     850:	cd 01       	movw	r24, r26
     852:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     856:	dc 01       	movw	r26, r24
     858:	cb 01       	movw	r24, r22
     85a:	f8 01       	movw	r30, r16
     85c:	91 83       	std	Z+1, r25	; 0x01
     85e:	80 83       	st	Z, r24
     860:	24 c0       	rjmp	.+72     	; 0x8aa <__stack+0x44b>
     862:	ce 01       	movw	r24, r28
     864:	89 5b       	subi	r24, 0xB9	; 185
     866:	9f 4f       	sbci	r25, 0xFF	; 255
     868:	28 ec       	ldi	r18, 0xC8	; 200
     86a:	30 e0       	ldi	r19, 0x00	; 0
     86c:	fc 01       	movw	r30, r24
     86e:	31 83       	std	Z+1, r19	; 0x01
     870:	20 83       	st	Z, r18
     872:	ce 01       	movw	r24, r28
     874:	89 5b       	subi	r24, 0xB9	; 185
     876:	9f 4f       	sbci	r25, 0xFF	; 255
     878:	fc 01       	movw	r30, r24
     87a:	80 81       	ld	r24, Z
     87c:	91 81       	ldd	r25, Z+1	; 0x01
     87e:	01 97       	sbiw	r24, 0x01	; 1
     880:	f1 f7       	brne	.-4      	; 0x87e <__stack+0x41f>
     882:	9e 01       	movw	r18, r28
     884:	29 5b       	subi	r18, 0xB9	; 185
     886:	3f 4f       	sbci	r19, 0xFF	; 255
     888:	f9 01       	movw	r30, r18
     88a:	91 83       	std	Z+1, r25	; 0x01
     88c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     88e:	ce 01       	movw	r24, r28
     890:	8b 5b       	subi	r24, 0xBB	; 187
     892:	9f 4f       	sbci	r25, 0xFF	; 255
     894:	9e 01       	movw	r18, r28
     896:	2b 5b       	subi	r18, 0xBB	; 187
     898:	3f 4f       	sbci	r19, 0xFF	; 255
     89a:	f9 01       	movw	r30, r18
     89c:	20 81       	ld	r18, Z
     89e:	31 81       	ldd	r19, Z+1	; 0x01
     8a0:	21 50       	subi	r18, 0x01	; 1
     8a2:	31 09       	sbc	r19, r1
     8a4:	fc 01       	movw	r30, r24
     8a6:	31 83       	std	Z+1, r19	; 0x01
     8a8:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8aa:	ce 01       	movw	r24, r28
     8ac:	8b 5b       	subi	r24, 0xBB	; 187
     8ae:	9f 4f       	sbci	r25, 0xFF	; 255
     8b0:	fc 01       	movw	r30, r24
     8b2:	80 81       	ld	r24, Z
     8b4:	91 81       	ldd	r25, Z+1	; 0x01
     8b6:	89 2b       	or	r24, r25
     8b8:	a1 f6       	brne	.-88     	; 0x862 <__stack+0x403>
     8ba:	2c c0       	rjmp	.+88     	; 0x914 <__stack+0x4b5>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8bc:	8e 01       	movw	r16, r28
     8be:	0b 5b       	subi	r16, 0xBB	; 187
     8c0:	1f 4f       	sbci	r17, 0xFF	; 255
     8c2:	ce 01       	movw	r24, r28
     8c4:	8f 5b       	subi	r24, 0xBF	; 191
     8c6:	9f 4f       	sbci	r25, 0xFF	; 255
     8c8:	fc 01       	movw	r30, r24
     8ca:	60 81       	ld	r22, Z
     8cc:	71 81       	ldd	r23, Z+1	; 0x01
     8ce:	82 81       	ldd	r24, Z+2	; 0x02
     8d0:	93 81       	ldd	r25, Z+3	; 0x03
     8d2:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     8d6:	dc 01       	movw	r26, r24
     8d8:	cb 01       	movw	r24, r22
     8da:	f8 01       	movw	r30, r16
     8dc:	91 83       	std	Z+1, r25	; 0x01
     8de:	80 83       	st	Z, r24
     8e0:	ce 01       	movw	r24, r28
     8e2:	87 5b       	subi	r24, 0xB7	; 183
     8e4:	9f 4f       	sbci	r25, 0xFF	; 255
     8e6:	9e 01       	movw	r18, r28
     8e8:	2b 5b       	subi	r18, 0xBB	; 187
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	f9 01       	movw	r30, r18
     8ee:	20 81       	ld	r18, Z
     8f0:	31 81       	ldd	r19, Z+1	; 0x01
     8f2:	fc 01       	movw	r30, r24
     8f4:	31 83       	std	Z+1, r19	; 0x01
     8f6:	20 83       	st	Z, r18
     8f8:	ce 01       	movw	r24, r28
     8fa:	87 5b       	subi	r24, 0xB7	; 183
     8fc:	9f 4f       	sbci	r25, 0xFF	; 255
     8fe:	fc 01       	movw	r30, r24
     900:	80 81       	ld	r24, Z
     902:	91 81       	ldd	r25, Z+1	; 0x01
     904:	01 97       	sbiw	r24, 0x01	; 1
     906:	f1 f7       	brne	.-4      	; 0x904 <__stack+0x4a5>
     908:	9e 01       	movw	r18, r28
     90a:	27 5b       	subi	r18, 0xB7	; 183
     90c:	3f 4f       	sbci	r19, 0xFF	; 255
     90e:	f9 01       	movw	r30, r18
     910:	91 83       	std	Z+1, r25	; 0x01
     912:	80 83       	st	Z, r24
    	_delay_ms(10);
    	EEPROM_writeByte(0X0011,0xAA); /* write in password_stored_flag address in EEPROM */
     914:	6a ea       	ldi	r22, 0xAA	; 170
     916:	81 e1       	ldi	r24, 0x11	; 17
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	0e 94 8a 05 	call	0xb14	; 0xb14 <EEPROM_writeByte>
    	password_stored_flag=0xAA;/*change password_stored_flag  in data segment in ram */
     91e:	8a ea       	ldi	r24, 0xAA	; 170
     920:	80 93 ee 00 	sts	0x00EE, r24	; 0x8000ee <password_stored_flag>
    	set_password_now_flag=0xAA;  /* prevent the program from requesting from user reenter or reset password */
     924:	8a ea       	ldi	r24, 0xAA	; 170
     926:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <set_password_now_flag>
    	if(UART_receiveByte()=='o') /* give user option to open the door */
     92a:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <UART_receiveByte>
     92e:	8f 36       	cpi	r24, 0x6F	; 111
     930:	09 f0       	breq	.+2      	; 0x934 <__stack+0x4d5>
     932:	2d cc       	rjmp	.-1958   	; 0x18e <main+0x7a>
    		 motor_run();
     934:	0e 94 bb 04 	call	0x976	; 0x976 <motor_run>

    	}

    }
     938:	2a cc       	rjmp	.-1964   	; 0x18e <main+0x7a>

0000093a <timer_set>:
 *      Author: hesham
 */
#include"actuators.h"

void timer_set(void)
{
     93a:	cf 93       	push	r28
     93c:	df 93       	push	r29
     93e:	cd b7       	in	r28, 0x3d	; 61
     940:	de b7       	in	r29, 0x3e	; 62
timer_config.timerNumber=1;
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <timer_config>
		strcpy(timer_config.mode,"compare");
     948:	88 e0       	ldi	r24, 0x08	; 8
     94a:	ed e6       	ldi	r30, 0x6D	; 109
     94c:	f0 e0       	ldi	r31, 0x00	; 0
     94e:	ad e0       	ldi	r26, 0x0D	; 13
     950:	b1 e0       	ldi	r27, 0x01	; 1
     952:	01 90       	ld	r0, Z+
     954:	0d 92       	st	X+, r0
     956:	8a 95       	dec	r24
     958:	e1 f7       	brne	.-8      	; 0x952 <timer_set+0x18>
		timer_config.prescaler=1024;
     95a:	80 e0       	ldi	r24, 0x00	; 0
     95c:	94 e0       	ldi	r25, 0x04	; 4
     95e:	90 93 22 01 	sts	0x0122, r25	; 0x800122 <timer_config+0x16>
     962:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <timer_config+0x15>
		TIMER_init(&timer_config);
     966:	8c e0       	ldi	r24, 0x0C	; 12
     968:	91 e0       	ldi	r25, 0x01	; 1
     96a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <TIMER_init>
}
     96e:	00 00       	nop
     970:	df 91       	pop	r29
     972:	cf 91       	pop	r28
     974:	08 95       	ret

00000976 <motor_run>:


void motor_run(void)
{
     976:	cf 93       	push	r28
     978:	df 93       	push	r29
     97a:	cd b7       	in	r28, 0x3d	; 61
     97c:	de b7       	in	r29, 0x3e	; 62

TIMER_setCompare(8000);
     97e:	80 e4       	ldi	r24, 0x40	; 64
     980:	9f e1       	ldi	r25, 0x1F	; 31
     982:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <TIMER_setCompare>
TIMER_setCallBackPtr(change_motor_dirction);
     986:	8b ec       	ldi	r24, 0xCB	; 203
     988:	94 e0       	ldi	r25, 0x04	; 4
     98a:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <TIMER_setCallBackPtr>


}
     98e:	00 00       	nop
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	08 95       	ret

00000996 <change_motor_dirction>:
void change_motor_dirction(void)
{
     996:	cf 93       	push	r28
     998:	df 93       	push	r29
     99a:	cd b7       	in	r28, 0x3d	; 61
     99c:	de b7       	in	r29, 0x3e	; 62

	static uint8 count=0;
	if(count==0)
     99e:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     9a2:	88 23       	and	r24, r24
     9a4:	29 f5       	brne	.+74     	; 0x9f0 <change_motor_dirction+0x5a>
	{
		DDRB|=(1<<0)|(1<<1);
     9a6:	87 e3       	ldi	r24, 0x37	; 55
     9a8:	90 e0       	ldi	r25, 0x00	; 0
     9aa:	27 e3       	ldi	r18, 0x37	; 55
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	f9 01       	movw	r30, r18
     9b0:	20 81       	ld	r18, Z
     9b2:	23 60       	ori	r18, 0x03	; 3
     9b4:	fc 01       	movw	r30, r24
     9b6:	20 83       	st	Z, r18
		PORTB&=~(1<<0)&~(1<<1);
     9b8:	88 e3       	ldi	r24, 0x38	; 56
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	28 e3       	ldi	r18, 0x38	; 56
     9be:	30 e0       	ldi	r19, 0x00	; 0
     9c0:	f9 01       	movw	r30, r18
     9c2:	20 81       	ld	r18, Z
     9c4:	2c 7f       	andi	r18, 0xFC	; 252
     9c6:	fc 01       	movw	r30, r24
     9c8:	20 83       	st	Z, r18
		CLEAR_BIT(PORTB,1);
     9ca:	88 e3       	ldi	r24, 0x38	; 56
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	28 e3       	ldi	r18, 0x38	; 56
     9d0:	30 e0       	ldi	r19, 0x00	; 0
     9d2:	f9 01       	movw	r30, r18
     9d4:	20 81       	ld	r18, Z
     9d6:	2d 7f       	andi	r18, 0xFD	; 253
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
		SET_BIT(PORTB,0);
     9dc:	88 e3       	ldi	r24, 0x38	; 56
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	28 e3       	ldi	r18, 0x38	; 56
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	f9 01       	movw	r30, r18
     9e6:	20 81       	ld	r18, Z
     9e8:	21 60       	ori	r18, 0x01	; 1
     9ea:	fc 01       	movw	r30, r24
     9ec:	20 83       	st	Z, r18
     9ee:	24 c0       	rjmp	.+72     	; 0xa38 <change_motor_dirction+0xa2>
	}
	else if(count>=2)
     9f0:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     9f4:	82 30       	cpi	r24, 0x02	; 2
     9f6:	60 f0       	brcs	.+24     	; 0xa10 <change_motor_dirction+0x7a>
{
	PORTB&=~(1<<0)&~(1<<1);
     9f8:	88 e3       	ldi	r24, 0x38	; 56
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	28 e3       	ldi	r18, 0x38	; 56
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	f9 01       	movw	r30, r18
     a02:	20 81       	ld	r18, Z
     a04:	2c 7f       	andi	r18, 0xFC	; 252
     a06:	fc 01       	movw	r30, r24
     a08:	20 83       	st	Z, r18

	TIMER_stop();
     a0a:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <TIMER_stop>
     a0e:	14 c0       	rjmp	.+40     	; 0xa38 <change_motor_dirction+0xa2>
}
else
{
	TOGGLE_BIT(PORTB,1);
     a10:	88 e3       	ldi	r24, 0x38	; 56
     a12:	90 e0       	ldi	r25, 0x00	; 0
     a14:	28 e3       	ldi	r18, 0x38	; 56
     a16:	30 e0       	ldi	r19, 0x00	; 0
     a18:	f9 01       	movw	r30, r18
     a1a:	30 81       	ld	r19, Z
     a1c:	22 e0       	ldi	r18, 0x02	; 2
     a1e:	23 27       	eor	r18, r19
     a20:	fc 01       	movw	r30, r24
     a22:	20 83       	st	Z, r18
	TOGGLE_BIT(PORTB,0);
     a24:	88 e3       	ldi	r24, 0x38	; 56
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	28 e3       	ldi	r18, 0x38	; 56
     a2a:	30 e0       	ldi	r19, 0x00	; 0
     a2c:	f9 01       	movw	r30, r18
     a2e:	30 81       	ld	r19, Z
     a30:	21 e0       	ldi	r18, 0x01	; 1
     a32:	23 27       	eor	r18, r19
     a34:	fc 01       	movw	r30, r24
     a36:	20 83       	st	Z, r18
}
	count++;
     a38:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <count.1911>
     a3c:	8f 5f       	subi	r24, 0xFF	; 255
     a3e:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <count.1911>

}
     a42:	00 00       	nop
     a44:	df 91       	pop	r29
     a46:	cf 91       	pop	r28
     a48:	08 95       	ret

00000a4a <buzzer>:
void buzzer(void)
{
     a4a:	cf 93       	push	r28
     a4c:	df 93       	push	r29
     a4e:	cd b7       	in	r28, 0x3d	; 61
     a50:	de b7       	in	r29, 0x3e	; 62

	TIMER_setCompare(60000);
     a52:	80 e6       	ldi	r24, 0x60	; 96
     a54:	9a ee       	ldi	r25, 0xEA	; 234
     a56:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <TIMER_setCompare>
	TIMER_setCallBackPtr(buzzer_call);
     a5a:	85 e3       	ldi	r24, 0x35	; 53
     a5c:	95 e0       	ldi	r25, 0x05	; 5
     a5e:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <TIMER_setCallBackPtr>
}
     a62:	00 00       	nop
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <buzzer_call>:
void buzzer_call(void)
{	static uint8 count=0;
     a6a:	cf 93       	push	r28
     a6c:	df 93       	push	r29
     a6e:	cd b7       	in	r28, 0x3d	; 61
     a70:	de b7       	in	r29, 0x3e	; 62
if(count==0)
     a72:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     a76:	88 23       	and	r24, r24
     a78:	99 f4       	brne	.+38     	; 0xaa0 <buzzer_call+0x36>
{
	SET_BIT(DDRC,5);
     a7a:	84 e3       	ldi	r24, 0x34	; 52
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	24 e3       	ldi	r18, 0x34	; 52
     a80:	30 e0       	ldi	r19, 0x00	; 0
     a82:	f9 01       	movw	r30, r18
     a84:	20 81       	ld	r18, Z
     a86:	20 62       	ori	r18, 0x20	; 32
     a88:	fc 01       	movw	r30, r24
     a8a:	20 83       	st	Z, r18
		SET_BIT(PORTC,5);
     a8c:	85 e3       	ldi	r24, 0x35	; 53
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	25 e3       	ldi	r18, 0x35	; 53
     a92:	30 e0       	ldi	r19, 0x00	; 0
     a94:	f9 01       	movw	r30, r18
     a96:	20 81       	ld	r18, Z
     a98:	20 62       	ori	r18, 0x20	; 32
     a9a:	fc 01       	movw	r30, r24
     a9c:	20 83       	st	Z, r18
     a9e:	14 c0       	rjmp	.+40     	; 0xac8 <buzzer_call+0x5e>
}


else if(count==8)
     aa0:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     aa4:	88 30       	cpi	r24, 0x08	; 8
     aa6:	81 f4       	brne	.+32     	; 0xac8 <buzzer_call+0x5e>
{
	CLEAR_BIT(PORTC,5);
     aa8:	85 e3       	ldi	r24, 0x35	; 53
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	25 e3       	ldi	r18, 0x35	; 53
     aae:	30 e0       	ldi	r19, 0x00	; 0
     ab0:	f9 01       	movw	r30, r18
     ab2:	20 81       	ld	r18, Z
     ab4:	2f 7d       	andi	r18, 0xDF	; 223
     ab6:	fc 01       	movw	r30, r24
     ab8:	20 83       	st	Z, r18
	buzzer_flag=1;
     aba:	81 e0       	ldi	r24, 0x01	; 1
     abc:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <buzzer_flag>
	block_buzzer_scope=0;
     ac0:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <block_buzzer_scope>
	TIMER_stop();
     ac4:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <TIMER_stop>
}
count++;
     ac8:	80 91 f3 00 	lds	r24, 0x00F3	; 0x8000f3 <count.1918>
     acc:	8f 5f       	subi	r24, 0xFF	; 255
     ace:	80 93 f3 00 	sts	0x00F3, r24	; 0x8000f3 <count.1918>


}
     ad2:	00 00       	nop
     ad4:	df 91       	pop	r29
     ad6:	cf 91       	pop	r28
     ad8:	08 95       	ret

00000ada <EEPROM_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void EEPROM_init(void)
{ /* determine the parameter which will pass to I2C driver to communicate with EEPROM */
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
	TWI_config.baudRate=400000; /* baud rate which EEPROM work on */
     ae2:	80 e8       	ldi	r24, 0x80	; 128
     ae4:	9a e1       	ldi	r25, 0x1A	; 26
     ae6:	a6 e0       	ldi	r26, 0x06	; 6
     ae8:	b0 e0       	ldi	r27, 0x00	; 0
     aea:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <TWI_config>
     aee:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <TWI_config+0x1>
     af2:	a0 93 50 01 	sts	0x0150, r26	; 0x800150 <TWI_config+0x2>
     af6:	b0 93 51 01 	sts	0x0151, r27	; 0x800151 <TWI_config+0x3>
	TWI_config.prescasler=0;
     afa:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <TWI_config+0x4>
	TWI_config.slave_address=0b00001011; /* the address of master when receive data from (as slave) form other slaves */
     afe:	8b e0       	ldi	r24, 0x0B	; 11
     b00:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <TWI_config+0x5>

	/* passing I2C configuration structure by reference to I2C initialization function */
TWI_init(&TWI_config);
     b04:	8e e4       	ldi	r24, 0x4E	; 78
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	0e 94 29 07 	call	0xe52	; 0xe52 <TWI_init>
}
     b0c:	00 00       	nop
     b0e:	df 91       	pop	r29
     b10:	cf 91       	pop	r28
     b12:	08 95       	ret

00000b14 <EEPROM_writeByte>:

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
     b14:	cf 93       	push	r28
     b16:	df 93       	push	r29
     b18:	00 d0       	rcall	.+0      	; 0xb1a <EEPROM_writeByte+0x6>
     b1a:	1f 92       	push	r1
     b1c:	cd b7       	in	r28, 0x3d	; 61
     b1e:	de b7       	in	r29, 0x3e	; 62
     b20:	9a 83       	std	Y+2, r25	; 0x02
     b22:	89 83       	std	Y+1, r24	; 0x01
     b24:	6b 83       	std	Y+3, r22	; 0x03
/* send start bit */
	TWI_start();
     b26:	0e 94 b1 07 	call	0xf62	; 0xf62 <TWI_start>
	if(TWI_getStatus()!=TW_START) /* check the start done */
     b2a:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     b2e:	88 30       	cpi	r24, 0x08	; 8
     b30:	11 f0       	breq	.+4      	; 0xb36 <EEPROM_writeByte+0x22>
	return ERROR; /* return error if doenst send start bit */
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	27 c0       	rjmp	.+78     	; 0xb84 <EEPROM_writeByte+0x70>

	/* to avoid sending 3 bytes 1  byte for EEPROM address  and 2 bytes  for memory location address
	 * combine address of EEPROM address (in our case 24c16 EEPROM----->>0XA0 ) and last 3 bits of memory location address
	 * memory location address for 24c16 EEPROM is 11 bits as memory size 2kByte and the memory width is 1 K byte
	 */
	TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     b36:	89 81       	ldd	r24, Y+1	; 0x01
     b38:	9a 81       	ldd	r25, Y+2	; 0x02
     b3a:	88 27       	eor	r24, r24
     b3c:	97 70       	andi	r25, 0x07	; 7
     b3e:	88 0f       	add	r24, r24
     b40:	89 2f       	mov	r24, r25
     b42:	88 1f       	adc	r24, r24
     b44:	99 0b       	sbc	r25, r25
     b46:	91 95       	neg	r25
     b48:	80 6a       	ori	r24, 0xA0	; 160
     b4a:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
	if(TWI_getStatus()!=TW_MT_SLA_W_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b4e:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     b52:	88 31       	cpi	r24, 0x18	; 24
     b54:	11 f0       	breq	.+4      	; 0xb5a <EEPROM_writeByte+0x46>
		return ERROR;
     b56:	80 e0       	ldi	r24, 0x00	; 0
     b58:	15 c0       	rjmp	.+42     	; 0xb84 <EEPROM_writeByte+0x70>

/* send the remaining of memory location address =11-3=8 bits */
	TWI_write((uint8)u16addr);
     b5a:	89 81       	ldd	r24, Y+1	; 0x01
     b5c:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) DATA (DATA) acknowledge (ACK) */
     b60:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     b64:	88 32       	cpi	r24, 0x28	; 40
     b66:	11 f0       	breq	.+4      	; 0xb6c <EEPROM_writeByte+0x58>
			return ERROR;
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	0c c0       	rjmp	.+24     	; 0xb84 <EEPROM_writeByte+0x70>


	TWI_write(u8data);
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
	if(TWI_getStatus()!=TW_MT_DATA_ACK) /* check the master (MT) receive form slave (SLA) write (w) acknowledge (ACK) */
     b72:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     b76:	88 32       	cpi	r24, 0x28	; 40
     b78:	11 f0       	breq	.+4      	; 0xb7e <EEPROM_writeByte+0x6a>
			return ERROR;
     b7a:	80 e0       	ldi	r24, 0x00	; 0
     b7c:	03 c0       	rjmp	.+6      	; 0xb84 <EEPROM_writeByte+0x70>

	TWI_stop(); /* end the frame */
     b7e:	0e 94 c5 07 	call	0xf8a	; 0xf8a <TWI_stop>
	return SUCCESS; /* send success if the frame is completed by reach this line */
     b82:	81 e0       	ldi	r24, 0x01	; 1
}
     b84:	0f 90       	pop	r0
     b86:	0f 90       	pop	r0
     b88:	0f 90       	pop	r0
     b8a:	df 91       	pop	r29
     b8c:	cf 91       	pop	r28
     b8e:	08 95       	ret

00000b90 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
     b90:	cf 93       	push	r28
     b92:	df 93       	push	r29
     b94:	00 d0       	rcall	.+0      	; 0xb96 <EEPROM_readByte+0x6>
     b96:	00 d0       	rcall	.+0      	; 0xb98 <EEPROM_readByte+0x8>
     b98:	cd b7       	in	r28, 0x3d	; 61
     b9a:	de b7       	in	r29, 0x3e	; 62
     b9c:	9a 83       	std	Y+2, r25	; 0x02
     b9e:	89 83       	std	Y+1, r24	; 0x01
     ba0:	7c 83       	std	Y+4, r23	; 0x04
     ba2:	6b 83       	std	Y+3, r22	; 0x03
	TWI_start();
     ba4:	0e 94 b1 07 	call	0xf62	; 0xf62 <TWI_start>
		if(TWI_getStatus()!=TW_START)
     ba8:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     bac:	88 30       	cpi	r24, 0x08	; 8
     bae:	11 f0       	breq	.+4      	; 0xbb4 <EEPROM_readByte+0x24>
		return ERROR;
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	45 c0       	rjmp	.+138    	; 0xc3e <EEPROM_readByte+0xae>

		TWI_write((uint8)(0xA0|((u16addr&0X0700)>>7)));
     bb4:	89 81       	ldd	r24, Y+1	; 0x01
     bb6:	9a 81       	ldd	r25, Y+2	; 0x02
     bb8:	88 27       	eor	r24, r24
     bba:	97 70       	andi	r25, 0x07	; 7
     bbc:	88 0f       	add	r24, r24
     bbe:	89 2f       	mov	r24, r25
     bc0:	88 1f       	adc	r24, r24
     bc2:	99 0b       	sbc	r25, r25
     bc4:	91 95       	neg	r25
     bc6:	80 6a       	ori	r24, 0xA0	; 160
     bc8:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_W_ACK)
     bcc:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     bd0:	88 31       	cpi	r24, 0x18	; 24
     bd2:	11 f0       	breq	.+4      	; 0xbd8 <EEPROM_readByte+0x48>
			return ERROR;
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	33 c0       	rjmp	.+102    	; 0xc3e <EEPROM_readByte+0xae>


		TWI_write((uint8)u16addr);
     bd8:	89 81       	ldd	r24, Y+1	; 0x01
     bda:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
		if(TWI_getStatus()!=TW_MT_DATA_ACK)
     bde:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     be2:	88 32       	cpi	r24, 0x28	; 40
     be4:	11 f0       	breq	.+4      	; 0xbea <EEPROM_readByte+0x5a>
				return ERROR;
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	2a c0       	rjmp	.+84     	; 0xc3e <EEPROM_readByte+0xae>

/* repeat start the frame as in this case master will read from the slave */
				TWI_start();
     bea:	0e 94 b1 07 	call	0xf62	; 0xf62 <TWI_start>
		if(TWI_getStatus()!=TW_REP_START) /* check the repeated start done */
     bee:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     bf2:	80 31       	cpi	r24, 0x10	; 16
     bf4:	11 f0       	breq	.+4      	; 0xbfa <EEPROM_readByte+0x6a>
						return ERROR;
     bf6:	80 e0       	ldi	r24, 0x00	; 0
     bf8:	22 c0       	rjmp	.+68     	; 0xc3e <EEPROM_readByte+0xae>
/* send the address of EEPROM as slave and set the less significant bit to make master read from the slave */
		TWI_write((uint8)((0xA0)|((u16addr&0X0700)>>7)|1));
     bfa:	89 81       	ldd	r24, Y+1	; 0x01
     bfc:	9a 81       	ldd	r25, Y+2	; 0x02
     bfe:	88 27       	eor	r24, r24
     c00:	97 70       	andi	r25, 0x07	; 7
     c02:	88 0f       	add	r24, r24
     c04:	89 2f       	mov	r24, r25
     c06:	88 1f       	adc	r24, r24
     c08:	99 0b       	sbc	r25, r25
     c0a:	91 95       	neg	r25
     c0c:	81 6a       	ori	r24, 0xA1	; 161
     c0e:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <TWI_write>
		if(TWI_getStatus()!=TW_MT_SLA_R_ACK)  /* check the master (MT) send  to slave (SLA) read (R) acknowledge (ACK) */
     c12:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     c16:	80 34       	cpi	r24, 0x40	; 64
     c18:	11 f0       	breq	.+4      	; 0xc1e <EEPROM_readByte+0x8e>
						return ERROR;
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	10 c0       	rjmp	.+32     	; 0xc3e <EEPROM_readByte+0xae>


			*u8data=TWI_read_with_NACK(); /* read the byte */
     c1e:	0e 94 05 08 	call	0x100a	; 0x100a <TWI_read_with_NACK>
     c22:	28 2f       	mov	r18, r24
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	fc 01       	movw	r30, r24
     c2a:	20 83       	st	Z, r18
			if(TWI_getStatus()!=TW_MR_DATA_NACK) /* check the master (MT) read the byte  from slave (SLA) read (DATA) acknowledge (ACK) */
     c2c:	0e 94 1c 08 	call	0x1038	; 0x1038 <TWI_getStatus>
     c30:	88 35       	cpi	r24, 0x58	; 88
     c32:	11 f0       	breq	.+4      	; 0xc38 <EEPROM_readByte+0xa8>
					return ERROR;
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	03 c0       	rjmp	.+6      	; 0xc3e <EEPROM_readByte+0xae>

			TWI_stop();
     c38:	0e 94 c5 07 	call	0xf8a	; 0xf8a <TWI_stop>
			return SUCCESS;
     c3c:	81 e0       	ldi	r24, 0x01	; 1

}
     c3e:	0f 90       	pop	r0
     c40:	0f 90       	pop	r0
     c42:	0f 90       	pop	r0
     c44:	0f 90       	pop	r0
     c46:	df 91       	pop	r29
     c48:	cf 91       	pop	r28
     c4a:	08 95       	ret

00000c4c <EEPROM_writeString>:
uint8 EEPROM_writeString(uint16 u16addr, uint8* str)
{
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	cd b7       	in	r28, 0x3d	; 61
     c52:	de b7       	in	r29, 0x3e	; 62
     c54:	63 97       	sbiw	r28, 0x13	; 19
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	de bf       	out	0x3e, r29	; 62
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	99 8b       	std	Y+17, r25	; 0x11
     c62:	88 8b       	std	Y+16, r24	; 0x10
     c64:	7b 8b       	std	Y+19, r23	; 0x13
     c66:	6a 8b       	std	Y+18, r22	; 0x12
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
     c68:	19 82       	std	Y+1, r1	; 0x01
	for( i=0;str[i]!='\0';i++)
     c6a:	19 82       	std	Y+1, r1	; 0x01
     c6c:	88 c0       	rjmp	.+272    	; 0xd7e <EEPROM_writeString+0x132>
{

/* increase the address by base +i */
	EEPROM_writeByte(u16addr+i,str[i]);
     c6e:	89 81       	ldd	r24, Y+1	; 0x01
     c70:	88 2f       	mov	r24, r24
     c72:	90 e0       	ldi	r25, 0x00	; 0
     c74:	2a 89       	ldd	r18, Y+18	; 0x12
     c76:	3b 89       	ldd	r19, Y+19	; 0x13
     c78:	82 0f       	add	r24, r18
     c7a:	93 1f       	adc	r25, r19
     c7c:	fc 01       	movw	r30, r24
     c7e:	40 81       	ld	r20, Z
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	28 2f       	mov	r18, r24
     c84:	30 e0       	ldi	r19, 0x00	; 0
     c86:	88 89       	ldd	r24, Y+16	; 0x10
     c88:	99 89       	ldd	r25, Y+17	; 0x11
     c8a:	82 0f       	add	r24, r18
     c8c:	93 1f       	adc	r25, r19
     c8e:	64 2f       	mov	r22, r20
     c90:	0e 94 8a 05 	call	0xb14	; 0xb14 <EEPROM_writeByte>
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	a0 e2       	ldi	r26, 0x20	; 32
     c9a:	b1 e4       	ldi	r27, 0x41	; 65
     c9c:	8a 83       	std	Y+2, r24	; 0x02
     c9e:	9b 83       	std	Y+3, r25	; 0x03
     ca0:	ac 83       	std	Y+4, r26	; 0x04
     ca2:	bd 83       	std	Y+5, r27	; 0x05

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     ca4:	20 e0       	ldi	r18, 0x00	; 0
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	4a ef       	ldi	r20, 0xFA	; 250
     caa:	54 e4       	ldi	r21, 0x44	; 68
     cac:	6a 81       	ldd	r22, Y+2	; 0x02
     cae:	7b 81       	ldd	r23, Y+3	; 0x03
     cb0:	8c 81       	ldd	r24, Y+4	; 0x04
     cb2:	9d 81       	ldd	r25, Y+5	; 0x05
     cb4:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     cb8:	dc 01       	movw	r26, r24
     cba:	cb 01       	movw	r24, r22
     cbc:	8e 83       	std	Y+6, r24	; 0x06
     cbe:	9f 83       	std	Y+7, r25	; 0x07
     cc0:	a8 87       	std	Y+8, r26	; 0x08
     cc2:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
     cc4:	20 e0       	ldi	r18, 0x00	; 0
     cc6:	30 e0       	ldi	r19, 0x00	; 0
     cc8:	40 e8       	ldi	r20, 0x80	; 128
     cca:	5f e3       	ldi	r21, 0x3F	; 63
     ccc:	6e 81       	ldd	r22, Y+6	; 0x06
     cce:	7f 81       	ldd	r23, Y+7	; 0x07
     cd0:	88 85       	ldd	r24, Y+8	; 0x08
     cd2:	99 85       	ldd	r25, Y+9	; 0x09
     cd4:	0e 94 cf 10 	call	0x219e	; 0x219e <__cmpsf2>
     cd8:	88 23       	and	r24, r24
     cda:	2c f4       	brge	.+10     	; 0xce6 <EEPROM_writeString+0x9a>
		__ticks = 1;
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	9b 87       	std	Y+11, r25	; 0x0b
     ce2:	8a 87       	std	Y+10, r24	; 0x0a
     ce4:	3f c0       	rjmp	.+126    	; 0xd64 <EEPROM_writeString+0x118>
	else if (__tmp > 65535)
     ce6:	20 e0       	ldi	r18, 0x00	; 0
     ce8:	3f ef       	ldi	r19, 0xFF	; 255
     cea:	4f e7       	ldi	r20, 0x7F	; 127
     cec:	57 e4       	ldi	r21, 0x47	; 71
     cee:	6e 81       	ldd	r22, Y+6	; 0x06
     cf0:	7f 81       	ldd	r23, Y+7	; 0x07
     cf2:	88 85       	ldd	r24, Y+8	; 0x08
     cf4:	99 85       	ldd	r25, Y+9	; 0x09
     cf6:	0e 94 27 12 	call	0x244e	; 0x244e <__gesf2>
     cfa:	18 16       	cp	r1, r24
     cfc:	4c f5       	brge	.+82     	; 0xd50 <EEPROM_writeString+0x104>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	40 e2       	ldi	r20, 0x20	; 32
     d04:	51 e4       	ldi	r21, 0x41	; 65
     d06:	6a 81       	ldd	r22, Y+2	; 0x02
     d08:	7b 81       	ldd	r23, Y+3	; 0x03
     d0a:	8c 81       	ldd	r24, Y+4	; 0x04
     d0c:	9d 81       	ldd	r25, Y+5	; 0x05
     d0e:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
     d12:	dc 01       	movw	r26, r24
     d14:	cb 01       	movw	r24, r22
     d16:	bc 01       	movw	r22, r24
     d18:	cd 01       	movw	r24, r26
     d1a:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     d1e:	dc 01       	movw	r26, r24
     d20:	cb 01       	movw	r24, r22
     d22:	9b 87       	std	Y+11, r25	; 0x0b
     d24:	8a 87       	std	Y+10, r24	; 0x0a
     d26:	0f c0       	rjmp	.+30     	; 0xd46 <EEPROM_writeString+0xfa>
     d28:	88 ec       	ldi	r24, 0xC8	; 200
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	9d 87       	std	Y+13, r25	; 0x0d
     d2e:	8c 87       	std	Y+12, r24	; 0x0c
     d30:	8c 85       	ldd	r24, Y+12	; 0x0c
     d32:	9d 85       	ldd	r25, Y+13	; 0x0d
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	f1 f7       	brne	.-4      	; 0xd34 <EEPROM_writeString+0xe8>
     d38:	9d 87       	std	Y+13, r25	; 0x0d
     d3a:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d3c:	8a 85       	ldd	r24, Y+10	; 0x0a
     d3e:	9b 85       	ldd	r25, Y+11	; 0x0b
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	9b 87       	std	Y+11, r25	; 0x0b
     d44:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d46:	8a 85       	ldd	r24, Y+10	; 0x0a
     d48:	9b 85       	ldd	r25, Y+11	; 0x0b
     d4a:	89 2b       	or	r24, r25
     d4c:	69 f7       	brne	.-38     	; 0xd28 <EEPROM_writeString+0xdc>
     d4e:	14 c0       	rjmp	.+40     	; 0xd78 <EEPROM_writeString+0x12c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d50:	6e 81       	ldd	r22, Y+6	; 0x06
     d52:	7f 81       	ldd	r23, Y+7	; 0x07
     d54:	88 85       	ldd	r24, Y+8	; 0x08
     d56:	99 85       	ldd	r25, Y+9	; 0x09
     d58:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     d5c:	dc 01       	movw	r26, r24
     d5e:	cb 01       	movw	r24, r22
     d60:	9b 87       	std	Y+11, r25	; 0x0b
     d62:	8a 87       	std	Y+10, r24	; 0x0a
     d64:	8a 85       	ldd	r24, Y+10	; 0x0a
     d66:	9b 85       	ldd	r25, Y+11	; 0x0b
     d68:	9f 87       	std	Y+15, r25	; 0x0f
     d6a:	8e 87       	std	Y+14, r24	; 0x0e
     d6c:	8e 85       	ldd	r24, Y+14	; 0x0e
     d6e:	9f 85       	ldd	r25, Y+15	; 0x0f
     d70:	01 97       	sbiw	r24, 0x01	; 1
     d72:	f1 f7       	brne	.-4      	; 0xd70 <EEPROM_writeString+0x124>
     d74:	9f 87       	std	Y+15, r25	; 0x0f
     d76:	8e 87       	std	Y+14, r24	; 0x0e
{
	/* send byte by byte until end of string (\0)
		 * and at the end of string send (\0)
		 */
	uint8 i=0;
	for( i=0;str[i]!='\0';i++)
     d78:	89 81       	ldd	r24, Y+1	; 0x01
     d7a:	8f 5f       	subi	r24, 0xFF	; 255
     d7c:	89 83       	std	Y+1, r24	; 0x01
     d7e:	89 81       	ldd	r24, Y+1	; 0x01
     d80:	88 2f       	mov	r24, r24
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	2a 89       	ldd	r18, Y+18	; 0x12
     d86:	3b 89       	ldd	r19, Y+19	; 0x13
     d88:	82 0f       	add	r24, r18
     d8a:	93 1f       	adc	r25, r19
     d8c:	fc 01       	movw	r30, r24
     d8e:	80 81       	ld	r24, Z
     d90:	88 23       	and	r24, r24
     d92:	09 f0       	breq	.+2      	; 0xd96 <EEPROM_writeString+0x14a>
     d94:	6c cf       	rjmp	.-296    	; 0xc6e <EEPROM_writeString+0x22>
	EEPROM_writeByte(u16addr+i,str[i]);
	_delay_ms(10);

}

	EEPROM_writeByte(u16addr+i,'\0');
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	28 2f       	mov	r18, r24
     d9a:	30 e0       	ldi	r19, 0x00	; 0
     d9c:	88 89       	ldd	r24, Y+16	; 0x10
     d9e:	99 89       	ldd	r25, Y+17	; 0x11
     da0:	82 0f       	add	r24, r18
     da2:	93 1f       	adc	r25, r19
     da4:	60 e0       	ldi	r22, 0x00	; 0
     da6:	0e 94 8a 05 	call	0xb14	; 0xb14 <EEPROM_writeByte>


}
     daa:	00 00       	nop
     dac:	63 96       	adiw	r28, 0x13	; 19
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	de bf       	out	0x3e, r29	; 62
     db4:	0f be       	out	0x3f, r0	; 63
     db6:	cd bf       	out	0x3d, r28	; 61
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <EEPROM_readString>:
uint8 EEPROM_readString(uint16 u16addr, uint8 *str)
{
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	00 d0       	rcall	.+0      	; 0xdc4 <EEPROM_readString+0x6>
     dc4:	00 d0       	rcall	.+0      	; 0xdc6 <EEPROM_readString+0x8>
     dc6:	1f 92       	push	r1
     dc8:	cd b7       	in	r28, 0x3d	; 61
     dca:	de b7       	in	r29, 0x3e	; 62
     dcc:	9b 83       	std	Y+3, r25	; 0x03
     dce:	8a 83       	std	Y+2, r24	; 0x02
     dd0:	7d 83       	std	Y+5, r23	; 0x05
     dd2:	6c 83       	std	Y+4, r22	; 0x04
	then enter the while loop  and receive byte by byte  until reach null
	put null '\0' at the end of string
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
     dd4:	19 82       	std	Y+1, r1	; 0x01
		EEPROM_readByte(u16addr, &str[i]);
     dd6:	89 81       	ldd	r24, Y+1	; 0x01
     dd8:	88 2f       	mov	r24, r24
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	2c 81       	ldd	r18, Y+4	; 0x04
     dde:	3d 81       	ldd	r19, Y+5	; 0x05
     de0:	28 0f       	add	r18, r24
     de2:	39 1f       	adc	r19, r25
     de4:	8a 81       	ldd	r24, Y+2	; 0x02
     de6:	9b 81       	ldd	r25, Y+3	; 0x03
     de8:	b9 01       	movw	r22, r18
     dea:	0e 94 c8 05 	call	0xb90	; 0xb90 <EEPROM_readByte>
		while(str[i]!='\0')
     dee:	14 c0       	rjmp	.+40     	; 0xe18 <EEPROM_readString+0x5a>
		{u16addr++;
     df0:	8a 81       	ldd	r24, Y+2	; 0x02
     df2:	9b 81       	ldd	r25, Y+3	; 0x03
     df4:	01 96       	adiw	r24, 0x01	; 1
     df6:	9b 83       	std	Y+3, r25	; 0x03
     df8:	8a 83       	std	Y+2, r24	; 0x02
			i++;
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	8f 5f       	subi	r24, 0xFF	; 255
     dfe:	89 83       	std	Y+1, r24	; 0x01
			EEPROM_readByte(u16addr, &str[i]);
     e00:	89 81       	ldd	r24, Y+1	; 0x01
     e02:	88 2f       	mov	r24, r24
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	2c 81       	ldd	r18, Y+4	; 0x04
     e08:	3d 81       	ldd	r19, Y+5	; 0x05
     e0a:	28 0f       	add	r18, r24
     e0c:	39 1f       	adc	r19, r25
     e0e:	8a 81       	ldd	r24, Y+2	; 0x02
     e10:	9b 81       	ldd	r25, Y+3	; 0x03
     e12:	b9 01       	movw	r22, r18
     e14:	0e 94 c8 05 	call	0xb90	; 0xb90 <EEPROM_readByte>
	increment the address in EEPROM and string buffer index
	 */

	uint8 i = 0;
		EEPROM_readByte(u16addr, &str[i]);
		while(str[i]!='\0')
     e18:	89 81       	ldd	r24, Y+1	; 0x01
     e1a:	88 2f       	mov	r24, r24
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	2c 81       	ldd	r18, Y+4	; 0x04
     e20:	3d 81       	ldd	r19, Y+5	; 0x05
     e22:	82 0f       	add	r24, r18
     e24:	93 1f       	adc	r25, r19
     e26:	fc 01       	movw	r30, r24
     e28:	80 81       	ld	r24, Z
     e2a:	88 23       	and	r24, r24
     e2c:	09 f7       	brne	.-62     	; 0xdf0 <EEPROM_readString+0x32>
		{u16addr++;
			i++;
			EEPROM_readByte(u16addr, &str[i]);
		}
		str[i]='\0';
     e2e:	89 81       	ldd	r24, Y+1	; 0x01
     e30:	88 2f       	mov	r24, r24
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	2c 81       	ldd	r18, Y+4	; 0x04
     e36:	3d 81       	ldd	r19, Y+5	; 0x05
     e38:	82 0f       	add	r24, r18
     e3a:	93 1f       	adc	r25, r19
     e3c:	fc 01       	movw	r30, r24
     e3e:	10 82       	st	Z, r1

}
     e40:	00 00       	nop
     e42:	0f 90       	pop	r0
     e44:	0f 90       	pop	r0
     e46:	0f 90       	pop	r0
     e48:	0f 90       	pop	r0
     e4a:	0f 90       	pop	r0
     e4c:	df 91       	pop	r29
     e4e:	cf 91       	pop	r28
     e50:	08 95       	ret

00000e52 <TWI_init>:
 * 					functions definition 			*
 * *************************************************************
 */

void TWI_init(const TWI_configurationType *config)
{
     e52:	cf 92       	push	r12
     e54:	df 92       	push	r13
     e56:	ef 92       	push	r14
     e58:	ff 92       	push	r15
     e5a:	0f 93       	push	r16
     e5c:	1f 93       	push	r17
     e5e:	cf 93       	push	r28
     e60:	df 93       	push	r29
     e62:	00 d0       	rcall	.+0      	; 0xe64 <TWI_init+0x12>
     e64:	cd b7       	in	r28, 0x3d	; 61
     e66:	de b7       	in	r29, 0x3e	; 62
     e68:	9a 83       	std	Y+2, r25	; 0x02
     e6a:	89 83       	std	Y+1, r24	; 0x01
	/* the equation is SCL frequency = CPU clock frequency /(16+2(TWBR)*4^prescaler */
	TWBR=((float)F_CPU/config->baudRate +16)/(2*pow(4,config->prescasler));
     e6c:	00 e2       	ldi	r16, 0x20	; 32
     e6e:	10 e0       	ldi	r17, 0x00	; 0
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	9a 81       	ldd	r25, Y+2	; 0x02
     e74:	fc 01       	movw	r30, r24
     e76:	80 81       	ld	r24, Z
     e78:	91 81       	ldd	r25, Z+1	; 0x01
     e7a:	a2 81       	ldd	r26, Z+2	; 0x02
     e7c:	b3 81       	ldd	r27, Z+3	; 0x03
     e7e:	bc 01       	movw	r22, r24
     e80:	cd 01       	movw	r24, r26
     e82:	0e 94 75 11 	call	0x22ea	; 0x22ea <__floatunsisf>
     e86:	dc 01       	movw	r26, r24
     e88:	cb 01       	movw	r24, r22
     e8a:	9c 01       	movw	r18, r24
     e8c:	ad 01       	movw	r20, r26
     e8e:	60 e0       	ldi	r22, 0x00	; 0
     e90:	74 e2       	ldi	r23, 0x24	; 36
     e92:	84 ef       	ldi	r24, 0xF4	; 244
     e94:	9a e4       	ldi	r25, 0x4A	; 74
     e96:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <__divsf3>
     e9a:	dc 01       	movw	r26, r24
     e9c:	cb 01       	movw	r24, r22
     e9e:	20 e0       	ldi	r18, 0x00	; 0
     ea0:	30 e0       	ldi	r19, 0x00	; 0
     ea2:	40 e8       	ldi	r20, 0x80	; 128
     ea4:	51 e4       	ldi	r21, 0x41	; 65
     ea6:	bc 01       	movw	r22, r24
     ea8:	cd 01       	movw	r24, r26
     eaa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <__addsf3>
     eae:	dc 01       	movw	r26, r24
     eb0:	cb 01       	movw	r24, r22
     eb2:	6c 01       	movw	r12, r24
     eb4:	7d 01       	movw	r14, r26
     eb6:	89 81       	ldd	r24, Y+1	; 0x01
     eb8:	9a 81       	ldd	r25, Y+2	; 0x02
     eba:	fc 01       	movw	r30, r24
     ebc:	84 81       	ldd	r24, Z+4	; 0x04
     ebe:	88 2f       	mov	r24, r24
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	a0 e0       	ldi	r26, 0x00	; 0
     ec4:	b0 e0       	ldi	r27, 0x00	; 0
     ec6:	bc 01       	movw	r22, r24
     ec8:	cd 01       	movw	r24, r26
     eca:	0e 94 75 11 	call	0x22ea	; 0x22ea <__floatunsisf>
     ece:	dc 01       	movw	r26, r24
     ed0:	cb 01       	movw	r24, r22
     ed2:	9c 01       	movw	r18, r24
     ed4:	ad 01       	movw	r20, r26
     ed6:	60 e0       	ldi	r22, 0x00	; 0
     ed8:	70 e0       	ldi	r23, 0x00	; 0
     eda:	80 e8       	ldi	r24, 0x80	; 128
     edc:	90 e4       	ldi	r25, 0x40	; 64
     ede:	0e 94 99 12 	call	0x2532	; 0x2532 <pow>
     ee2:	dc 01       	movw	r26, r24
     ee4:	cb 01       	movw	r24, r22
     ee6:	9c 01       	movw	r18, r24
     ee8:	ad 01       	movw	r20, r26
     eea:	bc 01       	movw	r22, r24
     eec:	cd 01       	movw	r24, r26
     eee:	0e 94 63 10 	call	0x20c6	; 0x20c6 <__addsf3>
     ef2:	dc 01       	movw	r26, r24
     ef4:	cb 01       	movw	r24, r22
     ef6:	9c 01       	movw	r18, r24
     ef8:	ad 01       	movw	r20, r26
     efa:	c7 01       	movw	r24, r14
     efc:	b6 01       	movw	r22, r12
     efe:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <__divsf3>
     f02:	dc 01       	movw	r26, r24
     f04:	cb 01       	movw	r24, r22
     f06:	bc 01       	movw	r22, r24
     f08:	cd 01       	movw	r24, r26
     f0a:	0e 94 46 11 	call	0x228c	; 0x228c <__fixunssfsi>
     f0e:	dc 01       	movw	r26, r24
     f10:	cb 01       	movw	r24, r22
     f12:	f8 01       	movw	r30, r16
     f14:	80 83       	st	Z, r24
	 	TWSR=config->prescasler;/*store prescaler  in first 2 bits (TWPS1 and TWPS0) as other bits read only*/
     f16:	81 e2       	ldi	r24, 0x21	; 33
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	29 81       	ldd	r18, Y+1	; 0x01
     f1c:	3a 81       	ldd	r19, Y+2	; 0x02
     f1e:	f9 01       	movw	r30, r18
     f20:	24 81       	ldd	r18, Z+4	; 0x04
     f22:	fc 01       	movw	r30, r24
     f24:	20 83       	st	Z, r18
	 TWAR=config->slave_address<<1;/* store slave address (7bits) in the most 7 significant bits
     f26:	82 e2       	ldi	r24, 0x22	; 34
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	29 81       	ldd	r18, Y+1	; 0x01
     f2c:	3a 81       	ldd	r19, Y+2	; 0x02
     f2e:	f9 01       	movw	r30, r18
     f30:	25 81       	ldd	r18, Z+5	; 0x05
     f32:	22 0f       	add	r18, r18
     f34:	fc 01       	movw	r30, r24
     f36:	20 83       	st	Z, r18
	  the address of master when receive data from (as slave) form other slaves */
	TWCR|=(1<<TWEN);/* enable TWI module */
     f38:	86 e5       	ldi	r24, 0x56	; 86
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	26 e5       	ldi	r18, 0x56	; 86
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	f9 01       	movw	r30, r18
     f42:	20 81       	ld	r18, Z
     f44:	24 60       	ori	r18, 0x04	; 4
     f46:	fc 01       	movw	r30, r24
     f48:	20 83       	st	Z, r18

}
     f4a:	00 00       	nop
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	df 91       	pop	r29
     f52:	cf 91       	pop	r28
     f54:	1f 91       	pop	r17
     f56:	0f 91       	pop	r16
     f58:	ff 90       	pop	r15
     f5a:	ef 90       	pop	r14
     f5c:	df 90       	pop	r13
     f5e:	cf 90       	pop	r12
     f60:	08 95       	ret

00000f62 <TWI_start>:
void TWI_start(void)
{
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	cd b7       	in	r28, 0x3d	; 61
     f68:	de b7       	in	r29, 0x3e	; 62
	//make enable again to force other bits in the register to be zero
	//start bit TWSTA and clear finish current job flag TWINT by toggle it
TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     f6a:	86 e5       	ldi	r24, 0x56	; 86
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	24 ea       	ldi	r18, 0xA4	; 164
     f70:	fc 01       	movw	r30, r24
     f72:	20 83       	st	Z, r18
while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     f74:	00 00       	nop
     f76:	86 e5       	ldi	r24, 0x56	; 86
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	fc 01       	movw	r30, r24
     f7c:	80 81       	ld	r24, Z
     f7e:	88 23       	and	r24, r24
     f80:	d4 f7       	brge	.-12     	; 0xf76 <TWI_start+0x14>
}
     f82:	00 00       	nop
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <TWI_stop>:
void TWI_stop(void)
{/*make enable again to force other bits in the register to be zero
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	cd b7       	in	r28, 0x3d	; 61
     f90:	de b7       	in	r29, 0x3e	; 62
	stop bit TWST0 and clear finish current job flag TWINT by toggle it */
TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
     f92:	86 e5       	ldi	r24, 0x56	; 86
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	24 e9       	ldi	r18, 0x94	; 148
     f98:	fc 01       	movw	r30, r24
     f9a:	20 83       	st	Z, r18

//NO NEED TO WAIT TWINT flag as it  is the end of frame
}
     f9c:	00 00       	nop
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret

00000fa4 <TWI_write>:
void TWI_write(uint8 data)
{
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	1f 92       	push	r1
     faa:	cd b7       	in	r28, 0x3d	; 61
     fac:	de b7       	in	r29, 0x3e	; 62
     fae:	89 83       	std	Y+1, r24	; 0x01
/* store data in TWDR */
	TWDR=data;
     fb0:	83 e2       	ldi	r24, 0x23	; 35
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	29 81       	ldd	r18, Y+1	; 0x01
     fb6:	fc 01       	movw	r30, r24
     fb8:	20 83       	st	Z, r18
	/*make enable again to force other bits in the register to be zero
		 clear finish current job flag TWINT by toggle it */
	TWCR=(1<<TWINT)|(1<<TWEN);
     fba:	86 e5       	ldi	r24, 0x56	; 86
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	24 e8       	ldi	r18, 0x84	; 132
     fc0:	fc 01       	movw	r30, r24
     fc2:	20 83       	st	Z, r18

	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
     fc4:	00 00       	nop
     fc6:	86 e5       	ldi	r24, 0x56	; 86
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	fc 01       	movw	r30, r24
     fcc:	80 81       	ld	r24, Z
     fce:	88 23       	and	r24, r24
     fd0:	d4 f7       	brge	.-12     	; 0xfc6 <TWI_write+0x22>

}
     fd2:	00 00       	nop
     fd4:	0f 90       	pop	r0
     fd6:	df 91       	pop	r29
     fd8:	cf 91       	pop	r28
     fda:	08 95       	ret

00000fdc <TWI_read_with_ACK>:
uint8 TWI_read_with_ACK(void)
{/*make enable again to force other bits in the register to be zero
     fdc:	cf 93       	push	r28
     fde:	df 93       	push	r29
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it
		 enable acknowledge bit TWEA */

	TWCR=(1<<TWINT)|(1<<TWEA)|(1<<TWEN);
     fe4:	86 e5       	ldi	r24, 0x56	; 86
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	24 ec       	ldi	r18, 0xC4	; 196
     fea:	fc 01       	movw	r30, r24
     fec:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));
     fee:	00 00       	nop
     ff0:	86 e5       	ldi	r24, 0x56	; 86
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	fc 01       	movw	r30, r24
     ff6:	80 81       	ld	r24, Z
     ff8:	88 23       	and	r24, r24
     ffa:	d4 f7       	brge	.-12     	; 0xff0 <TWI_read_with_ACK+0x14>
	//CLEAR flag before or after
	return TWDR;
     ffc:	83 e2       	ldi	r24, 0x23	; 35
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	fc 01       	movw	r30, r24
    1002:	80 81       	ld	r24, Z
}
    1004:	df 91       	pop	r29
    1006:	cf 91       	pop	r28
    1008:	08 95       	ret

0000100a <TWI_read_with_NACK>:

uint8 TWI_read_with_NACK(void)
{/*make enable again to force other bits in the register to be zero
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
		 clear finish current job flag TWINT by toggle it*/
	TWCR=(1<<TWINT)|(1<<TWEN);
    1012:	86 e5       	ldi	r24, 0x56	; 86
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	24 e8       	ldi	r18, 0x84	; 132
    1018:	fc 01       	movw	r30, r24
    101a:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(TWCR,TWINT));// WAIT finish current job  flag TWINT =1
    101c:	00 00       	nop
    101e:	86 e5       	ldi	r24, 0x56	; 86
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	fc 01       	movw	r30, r24
    1024:	80 81       	ld	r24, Z
    1026:	88 23       	and	r24, r24
    1028:	d4 f7       	brge	.-12     	; 0x101e <TWI_read_with_NACK+0x14>

	return TWDR;
    102a:	83 e2       	ldi	r24, 0x23	; 35
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	fc 01       	movw	r30, r24
    1030:	80 81       	ld	r24, Z
}
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	08 95       	ret

00001038 <TWI_getStatus>:
uint8 TWI_getStatus()
{	/*return bits 7:3 in status register TWSR */
    1038:	cf 93       	push	r28
    103a:	df 93       	push	r29
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
	return TWSR&0XF8;
    1040:	81 e2       	ldi	r24, 0x21	; 33
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	fc 01       	movw	r30, r24
    1046:	80 81       	ld	r24, Z
    1048:	88 7f       	andi	r24, 0xF8	; 248
}
    104a:	df 91       	pop	r29
    104c:	cf 91       	pop	r28
    104e:	08 95       	ret

00001050 <__vector_19>:
/***************************************************************
 * 		Interrupt Service Routine functions definition 						*
 * *************************************************************
 */
/*ISR function work with timer 0 compare match mode */
ISR(TIMER0_COMP_vect) {
    1050:	1f 92       	push	r1
    1052:	0f 92       	push	r0
    1054:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1058:	0f 92       	push	r0
    105a:	11 24       	eor	r1, r1
    105c:	2f 93       	push	r18
    105e:	3f 93       	push	r19
    1060:	4f 93       	push	r20
    1062:	5f 93       	push	r21
    1064:	6f 93       	push	r22
    1066:	7f 93       	push	r23
    1068:	8f 93       	push	r24
    106a:	9f 93       	push	r25
    106c:	af 93       	push	r26
    106e:	bf 93       	push	r27
    1070:	ef 93       	push	r30
    1072:	ff 93       	push	r31
    1074:	cf 93       	push	r28
    1076:	df 93       	push	r29
    1078:	cd b7       	in	r28, 0x3d	; 61
    107a:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) /* check that callback function address is passed */
    107c:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1080:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1084:	89 2b       	or	r24, r25
    1086:	31 f0       	breq	.+12     	; 0x1094 <__vector_19+0x44>
		g_callBackPtr();/* point to callBack function */
    1088:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    108c:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1090:	fc 01       	movw	r30, r24
    1092:	09 95       	icall

}
    1094:	00 00       	nop
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	ff 91       	pop	r31
    109c:	ef 91       	pop	r30
    109e:	bf 91       	pop	r27
    10a0:	af 91       	pop	r26
    10a2:	9f 91       	pop	r25
    10a4:	8f 91       	pop	r24
    10a6:	7f 91       	pop	r23
    10a8:	6f 91       	pop	r22
    10aa:	5f 91       	pop	r21
    10ac:	4f 91       	pop	r20
    10ae:	3f 91       	pop	r19
    10b0:	2f 91       	pop	r18
    10b2:	0f 90       	pop	r0
    10b4:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10b8:	0f 90       	pop	r0
    10ba:	1f 90       	pop	r1
    10bc:	18 95       	reti

000010be <__vector_9>:
/*ISR function work with timer 0 normal mode */
ISR(TIMER0_OVF_vect) {
    10be:	1f 92       	push	r1
    10c0:	0f 92       	push	r0
    10c2:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    10c6:	0f 92       	push	r0
    10c8:	11 24       	eor	r1, r1
    10ca:	2f 93       	push	r18
    10cc:	3f 93       	push	r19
    10ce:	4f 93       	push	r20
    10d0:	5f 93       	push	r21
    10d2:	6f 93       	push	r22
    10d4:	7f 93       	push	r23
    10d6:	8f 93       	push	r24
    10d8:	9f 93       	push	r25
    10da:	af 93       	push	r26
    10dc:	bf 93       	push	r27
    10de:	ef 93       	push	r30
    10e0:	ff 93       	push	r31
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
    10e6:	cd b7       	in	r28, 0x3d	; 61
    10e8:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    10ea:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    10ee:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    10f2:	89 2b       	or	r24, r25
    10f4:	31 f0       	breq	.+12     	; 0x1102 <__vector_9+0x44>
		g_callBackPtr();
    10f6:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    10fa:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    10fe:	fc 01       	movw	r30, r24
    1100:	09 95       	icall

}
    1102:	00 00       	nop
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	ff 91       	pop	r31
    110a:	ef 91       	pop	r30
    110c:	bf 91       	pop	r27
    110e:	af 91       	pop	r26
    1110:	9f 91       	pop	r25
    1112:	8f 91       	pop	r24
    1114:	7f 91       	pop	r23
    1116:	6f 91       	pop	r22
    1118:	5f 91       	pop	r21
    111a:	4f 91       	pop	r20
    111c:	3f 91       	pop	r19
    111e:	2f 91       	pop	r18
    1120:	0f 90       	pop	r0
    1122:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1126:	0f 90       	pop	r0
    1128:	1f 90       	pop	r1
    112a:	18 95       	reti

0000112c <__vector_8>:
/*ISR function work with timer 1 normal mode */
ISR(TIMER1_OVF_vect) {
    112c:	1f 92       	push	r1
    112e:	0f 92       	push	r0
    1130:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1134:	0f 92       	push	r0
    1136:	11 24       	eor	r1, r1
    1138:	2f 93       	push	r18
    113a:	3f 93       	push	r19
    113c:	4f 93       	push	r20
    113e:	5f 93       	push	r21
    1140:	6f 93       	push	r22
    1142:	7f 93       	push	r23
    1144:	8f 93       	push	r24
    1146:	9f 93       	push	r25
    1148:	af 93       	push	r26
    114a:	bf 93       	push	r27
    114c:	ef 93       	push	r30
    114e:	ff 93       	push	r31
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    1158:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    115c:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1160:	89 2b       	or	r24, r25
    1162:	31 f0       	breq	.+12     	; 0x1170 <__vector_8+0x44>
		g_callBackPtr();
    1164:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1168:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    116c:	fc 01       	movw	r30, r24
    116e:	09 95       	icall

}
    1170:	00 00       	nop
    1172:	df 91       	pop	r29
    1174:	cf 91       	pop	r28
    1176:	ff 91       	pop	r31
    1178:	ef 91       	pop	r30
    117a:	bf 91       	pop	r27
    117c:	af 91       	pop	r26
    117e:	9f 91       	pop	r25
    1180:	8f 91       	pop	r24
    1182:	7f 91       	pop	r23
    1184:	6f 91       	pop	r22
    1186:	5f 91       	pop	r21
    1188:	4f 91       	pop	r20
    118a:	3f 91       	pop	r19
    118c:	2f 91       	pop	r18
    118e:	0f 90       	pop	r0
    1190:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1194:	0f 90       	pop	r0
    1196:	1f 90       	pop	r1
    1198:	18 95       	reti

0000119a <__vector_6>:
/*ISR function work with timer 1A compare match mode */
ISR(TIMER1_COMPA_vect) {
    119a:	1f 92       	push	r1
    119c:	0f 92       	push	r0
    119e:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    11a2:	0f 92       	push	r0
    11a4:	11 24       	eor	r1, r1
    11a6:	2f 93       	push	r18
    11a8:	3f 93       	push	r19
    11aa:	4f 93       	push	r20
    11ac:	5f 93       	push	r21
    11ae:	6f 93       	push	r22
    11b0:	7f 93       	push	r23
    11b2:	8f 93       	push	r24
    11b4:	9f 93       	push	r25
    11b6:	af 93       	push	r26
    11b8:	bf 93       	push	r27
    11ba:	ef 93       	push	r30
    11bc:	ff 93       	push	r31
    11be:	cf 93       	push	r28
    11c0:	df 93       	push	r29
    11c2:	cd b7       	in	r28, 0x3d	; 61
    11c4:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    11c6:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    11ca:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    11ce:	89 2b       	or	r24, r25
    11d0:	31 f0       	breq	.+12     	; 0x11de <__vector_6+0x44>
		g_callBackPtr();
    11d2:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    11d6:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    11da:	fc 01       	movw	r30, r24
    11dc:	09 95       	icall
}
    11de:	00 00       	nop
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	ff 91       	pop	r31
    11e6:	ef 91       	pop	r30
    11e8:	bf 91       	pop	r27
    11ea:	af 91       	pop	r26
    11ec:	9f 91       	pop	r25
    11ee:	8f 91       	pop	r24
    11f0:	7f 91       	pop	r23
    11f2:	6f 91       	pop	r22
    11f4:	5f 91       	pop	r21
    11f6:	4f 91       	pop	r20
    11f8:	3f 91       	pop	r19
    11fa:	2f 91       	pop	r18
    11fc:	0f 90       	pop	r0
    11fe:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1202:	0f 90       	pop	r0
    1204:	1f 90       	pop	r1
    1206:	18 95       	reti

00001208 <__vector_3>:
/*ISR function work with timer 2 compare match mode */
ISR(TIMER2_COMP_vect) {
    1208:	1f 92       	push	r1
    120a:	0f 92       	push	r0
    120c:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1210:	0f 92       	push	r0
    1212:	11 24       	eor	r1, r1
    1214:	2f 93       	push	r18
    1216:	3f 93       	push	r19
    1218:	4f 93       	push	r20
    121a:	5f 93       	push	r21
    121c:	6f 93       	push	r22
    121e:	7f 93       	push	r23
    1220:	8f 93       	push	r24
    1222:	9f 93       	push	r25
    1224:	af 93       	push	r26
    1226:	bf 93       	push	r27
    1228:	ef 93       	push	r30
    122a:	ff 93       	push	r31
    122c:	cf 93       	push	r28
    122e:	df 93       	push	r29
    1230:	cd b7       	in	r28, 0x3d	; 61
    1232:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    1234:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1238:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    123c:	89 2b       	or	r24, r25
    123e:	31 f0       	breq	.+12     	; 0x124c <__vector_3+0x44>
		g_callBackPtr();
    1240:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    1244:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    1248:	fc 01       	movw	r30, r24
    124a:	09 95       	icall

}
    124c:	00 00       	nop
    124e:	df 91       	pop	r29
    1250:	cf 91       	pop	r28
    1252:	ff 91       	pop	r31
    1254:	ef 91       	pop	r30
    1256:	bf 91       	pop	r27
    1258:	af 91       	pop	r26
    125a:	9f 91       	pop	r25
    125c:	8f 91       	pop	r24
    125e:	7f 91       	pop	r23
    1260:	6f 91       	pop	r22
    1262:	5f 91       	pop	r21
    1264:	4f 91       	pop	r20
    1266:	3f 91       	pop	r19
    1268:	2f 91       	pop	r18
    126a:	0f 90       	pop	r0
    126c:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    1270:	0f 90       	pop	r0
    1272:	1f 90       	pop	r1
    1274:	18 95       	reti

00001276 <__vector_4>:
/*ISR function work with timer 2 normal mode */
ISR(TIMER2_OVF_vect) {
    1276:	1f 92       	push	r1
    1278:	0f 92       	push	r0
    127a:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    127e:	0f 92       	push	r0
    1280:	11 24       	eor	r1, r1
    1282:	2f 93       	push	r18
    1284:	3f 93       	push	r19
    1286:	4f 93       	push	r20
    1288:	5f 93       	push	r21
    128a:	6f 93       	push	r22
    128c:	7f 93       	push	r23
    128e:	8f 93       	push	r24
    1290:	9f 93       	push	r25
    1292:	af 93       	push	r26
    1294:	bf 93       	push	r27
    1296:	ef 93       	push	r30
    1298:	ff 93       	push	r31
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
    129e:	cd b7       	in	r28, 0x3d	; 61
    12a0:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR)
    12a2:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    12a6:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    12aa:	89 2b       	or	r24, r25
    12ac:	31 f0       	breq	.+12     	; 0x12ba <__vector_4+0x44>
		g_callBackPtr();
    12ae:	80 91 f4 00 	lds	r24, 0x00F4	; 0x8000f4 <g_callBackPtr>
    12b2:	90 91 f5 00 	lds	r25, 0x00F5	; 0x8000f5 <g_callBackPtr+0x1>
    12b6:	fc 01       	movw	r30, r24
    12b8:	09 95       	icall
}
    12ba:	00 00       	nop
    12bc:	df 91       	pop	r29
    12be:	cf 91       	pop	r28
    12c0:	ff 91       	pop	r31
    12c2:	ef 91       	pop	r30
    12c4:	bf 91       	pop	r27
    12c6:	af 91       	pop	r26
    12c8:	9f 91       	pop	r25
    12ca:	8f 91       	pop	r24
    12cc:	7f 91       	pop	r23
    12ce:	6f 91       	pop	r22
    12d0:	5f 91       	pop	r21
    12d2:	4f 91       	pop	r20
    12d4:	3f 91       	pop	r19
    12d6:	2f 91       	pop	r18
    12d8:	0f 90       	pop	r0
    12da:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    12de:	0f 90       	pop	r0
    12e0:	1f 90       	pop	r1
    12e2:	18 95       	reti

000012e4 <TIMER_init>:




/* configurate by passing timer  configuration structure */
void TIMER_init(TIMER_configurationType *config) {
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	00 d0       	rcall	.+0      	; 0x12ea <TIMER_init+0x6>
    12ea:	cd b7       	in	r28, 0x3d	; 61
    12ec:	de b7       	in	r29, 0x3e	; 62
    12ee:	9a 83       	std	Y+2, r25	; 0x02
    12f0:	89 83       	std	Y+1, r24	; 0x01
	configPtr = config; /* make passed configuration global */
    12f2:	89 81       	ldd	r24, Y+1	; 0x01
    12f4:	9a 81       	ldd	r25, Y+2	; 0x02
    12f6:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <configPtr+0x1>
    12fa:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <configPtr>


/***************************************************************
* 						0	TIMER0		*
* *************************************************************/
	if (config->timerNumber == 0) {
    12fe:	89 81       	ldd	r24, Y+1	; 0x01
    1300:	9a 81       	ldd	r25, Y+2	; 0x02
    1302:	fc 01       	movw	r30, r24
    1304:	80 81       	ld	r24, Z
    1306:	88 23       	and	r24, r24
    1308:	09 f0       	breq	.+2      	; 0x130c <TIMER_init+0x28>
    130a:	22 c1       	rjmp	.+580    	; 0x1550 <TIMER_init+0x26c>
		TCCR0 = 0; /* put zeros into all bits in the register */
    130c:	83 e5       	ldi	r24, 0x53	; 83
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	fc 01       	movw	r30, r24
    1312:	10 82       	st	Z, r1
		switch (config->prescaler) {
    1314:	89 81       	ldd	r24, Y+1	; 0x01
    1316:	9a 81       	ldd	r25, Y+2	; 0x02
    1318:	fc 01       	movw	r30, r24
    131a:	85 89       	ldd	r24, Z+21	; 0x15
    131c:	96 89       	ldd	r25, Z+22	; 0x16
    131e:	80 34       	cpi	r24, 0x40	; 64
    1320:	91 05       	cpc	r25, r1
    1322:	c1 f0       	breq	.+48     	; 0x1354 <TIMER_init+0x70>
    1324:	81 34       	cpi	r24, 0x41	; 65
    1326:	91 05       	cpc	r25, r1
    1328:	18 f4       	brcc	.+6      	; 0x1330 <TIMER_init+0x4c>
    132a:	08 97       	sbiw	r24, 0x08	; 8
    132c:	49 f0       	breq	.+18     	; 0x1340 <TIMER_init+0x5c>
    132e:	30 c0       	rjmp	.+96     	; 0x1390 <TIMER_init+0xac>
    1330:	81 15       	cp	r24, r1
    1332:	f1 e0       	ldi	r31, 0x01	; 1
    1334:	9f 07       	cpc	r25, r31
    1336:	c1 f0       	breq	.+48     	; 0x1368 <TIMER_init+0x84>
    1338:	81 15       	cp	r24, r1
    133a:	94 40       	sbci	r25, 0x04	; 4
    133c:	f9 f0       	breq	.+62     	; 0x137c <TIMER_init+0x98>
    133e:	28 c0       	rjmp	.+80     	; 0x1390 <TIMER_init+0xac>
		case 8:
			TCCR0 |= (1 << CS01); /*CS00=0  CS01=1 CS02=0  */
    1340:	83 e5       	ldi	r24, 0x53	; 83
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	23 e5       	ldi	r18, 0x53	; 83
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	f9 01       	movw	r30, r18
    134a:	20 81       	ld	r18, Z
    134c:	22 60       	ori	r18, 0x02	; 2
    134e:	fc 01       	movw	r30, r24
    1350:	20 83       	st	Z, r18
			break;
    1352:	27 c0       	rjmp	.+78     	; 0x13a2 <TIMER_init+0xbe>
		case 64:
			TCCR0 |= (1 << CS00) | (1 << CS01); /*CS00=1  CS01=1 CS02=0  */
    1354:	83 e5       	ldi	r24, 0x53	; 83
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	23 e5       	ldi	r18, 0x53	; 83
    135a:	30 e0       	ldi	r19, 0x00	; 0
    135c:	f9 01       	movw	r30, r18
    135e:	20 81       	ld	r18, Z
    1360:	23 60       	ori	r18, 0x03	; 3
    1362:	fc 01       	movw	r30, r24
    1364:	20 83       	st	Z, r18
			break;
    1366:	1d c0       	rjmp	.+58     	; 0x13a2 <TIMER_init+0xbe>
		case 256:
			TCCR0 |= (1 << CS02); /*CS00=0  CS01=0 CS02=02  */
    1368:	83 e5       	ldi	r24, 0x53	; 83
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	23 e5       	ldi	r18, 0x53	; 83
    136e:	30 e0       	ldi	r19, 0x00	; 0
    1370:	f9 01       	movw	r30, r18
    1372:	20 81       	ld	r18, Z
    1374:	24 60       	ori	r18, 0x04	; 4
    1376:	fc 01       	movw	r30, r24
    1378:	20 83       	st	Z, r18
			break;
    137a:	13 c0       	rjmp	.+38     	; 0x13a2 <TIMER_init+0xbe>
		case 1024:
			TCCR0 |= (1 << CS00) | (1 << CS02); /*CS00=1  CS01=0 CS02=1  */
    137c:	83 e5       	ldi	r24, 0x53	; 83
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	23 e5       	ldi	r18, 0x53	; 83
    1382:	30 e0       	ldi	r19, 0x00	; 0
    1384:	f9 01       	movw	r30, r18
    1386:	20 81       	ld	r18, Z
    1388:	25 60       	ori	r18, 0x05	; 5
    138a:	fc 01       	movw	r30, r24
    138c:	20 83       	st	Z, r18
			break;
    138e:	09 c0       	rjmp	.+18     	; 0x13a2 <TIMER_init+0xbe>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR0 |= (1 << CS00); /*CS00=1  CS01=0 CS02=0  */
    1390:	83 e5       	ldi	r24, 0x53	; 83
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	23 e5       	ldi	r18, 0x53	; 83
    1396:	30 e0       	ldi	r19, 0x00	; 0
    1398:	f9 01       	movw	r30, r18
    139a:	20 81       	ld	r18, Z
    139c:	21 60       	ori	r18, 0x01	; 1
    139e:	fc 01       	movw	r30, r24
    13a0:	20 83       	st	Z, r18
		}
/***************************************************************
 * 					0-0 select the mode for TIMER0	*
* *************************************************************
*/
		if (!strcmp(config->mode, "compare"))
    13a2:	89 81       	ldd	r24, Y+1	; 0x01
    13a4:	9a 81       	ldd	r25, Y+2	; 0x02
    13a6:	01 96       	adiw	r24, 0x01	; 1
    13a8:	65 e7       	ldi	r22, 0x75	; 117
    13aa:	70 e0       	ldi	r23, 0x00	; 0
    13ac:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    13b0:	89 2b       	or	r24, r25
    13b2:	09 f0       	breq	.+2      	; 0x13b6 <TIMER_init+0xd2>
    13b4:	62 c0       	rjmp	.+196    	; 0x147a <TIMER_init+0x196>
		{
			TCCR0 |= (1 << FOC0) | (1 << WGM01);
    13b6:	83 e5       	ldi	r24, 0x53	; 83
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	23 e5       	ldi	r18, 0x53	; 83
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	f9 01       	movw	r30, r18
    13c0:	20 81       	ld	r18, Z
    13c2:	28 68       	ori	r18, 0x88	; 136
    13c4:	fc 01       	movw	r30, r24
    13c6:	20 83       	st	Z, r18
 * 		0-1 compare match output mode for TIMER0	*
 * ***************************************************
 */


				if (!strcmp(config->compareMatchMode, "toggle")) {
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
    13cc:	47 96       	adiw	r24, 0x17	; 23
    13ce:	6d e7       	ldi	r22, 0x7D	; 125
    13d0:	70 e0       	ldi	r23, 0x00	; 0
    13d2:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    13d6:	89 2b       	or	r24, r25
    13d8:	99 f4       	brne	.+38     	; 0x1400 <TIMER_init+0x11c>
					TCCR0 |= (1 << COM00); /*COM00=1 AND COM01=0 */
    13da:	83 e5       	ldi	r24, 0x53	; 83
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	23 e5       	ldi	r18, 0x53	; 83
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	f9 01       	movw	r30, r18
    13e4:	20 81       	ld	r18, Z
    13e6:	20 61       	ori	r18, 0x10	; 16
    13e8:	fc 01       	movw	r30, r24
    13ea:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3); /*make OCO AS OUTPUT BIT */
    13ec:	87 e3       	ldi	r24, 0x37	; 55
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	27 e3       	ldi	r18, 0x37	; 55
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	f9 01       	movw	r30, r18
    13f6:	20 81       	ld	r18, Z
    13f8:	28 60       	ori	r18, 0x08	; 8
    13fa:	fc 01       	movw	r30, r24
    13fc:	20 83       	st	Z, r18
    13fe:	37 c0       	rjmp	.+110    	; 0x146e <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    1400:	89 81       	ldd	r24, Y+1	; 0x01
    1402:	9a 81       	ldd	r25, Y+2	; 0x02
    1404:	47 96       	adiw	r24, 0x17	; 23
    1406:	64 e8       	ldi	r22, 0x84	; 132
    1408:	70 e0       	ldi	r23, 0x00	; 0
    140a:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    140e:	89 2b       	or	r24, r25
    1410:	99 f4       	brne	.+38     	; 0x1438 <TIMER_init+0x154>
					TCCR0 |= (1 << COM01); /*COM00=0 AND COM01=1 */
    1412:	83 e5       	ldi	r24, 0x53	; 83
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	23 e5       	ldi	r18, 0x53	; 83
    1418:	30 e0       	ldi	r19, 0x00	; 0
    141a:	f9 01       	movw	r30, r18
    141c:	20 81       	ld	r18, Z
    141e:	20 62       	ori	r18, 0x20	; 32
    1420:	fc 01       	movw	r30, r24
    1422:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    1424:	87 e3       	ldi	r24, 0x37	; 55
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	27 e3       	ldi	r18, 0x37	; 55
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	f9 01       	movw	r30, r18
    142e:	20 81       	ld	r18, Z
    1430:	28 60       	ori	r18, 0x08	; 8
    1432:	fc 01       	movw	r30, r24
    1434:	20 83       	st	Z, r18
    1436:	1b c0       	rjmp	.+54     	; 0x146e <TIMER_init+0x18a>
				} else if (!strcmp(config->compareMatchMode, "set")) {
    1438:	89 81       	ldd	r24, Y+1	; 0x01
    143a:	9a 81       	ldd	r25, Y+2	; 0x02
    143c:	47 96       	adiw	r24, 0x17	; 23
    143e:	6a e8       	ldi	r22, 0x8A	; 138
    1440:	70 e0       	ldi	r23, 0x00	; 0
    1442:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1446:	89 2b       	or	r24, r25
    1448:	91 f4       	brne	.+36     	; 0x146e <TIMER_init+0x18a>
					TCCR0 |= (1 << COM01) | (1 << COM00); /*COM00=1 AND COM01=1 */
    144a:	83 e5       	ldi	r24, 0x53	; 83
    144c:	90 e0       	ldi	r25, 0x00	; 0
    144e:	23 e5       	ldi	r18, 0x53	; 83
    1450:	30 e0       	ldi	r19, 0x00	; 0
    1452:	f9 01       	movw	r30, r18
    1454:	20 81       	ld	r18, Z
    1456:	20 63       	ori	r18, 0x30	; 48
    1458:	fc 01       	movw	r30, r24
    145a:	20 83       	st	Z, r18
					SET_BIT(DDRB, 3);
    145c:	87 e3       	ldi	r24, 0x37	; 55
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	27 e3       	ldi	r18, 0x37	; 55
    1462:	30 e0       	ldi	r19, 0x00	; 0
    1464:	f9 01       	movw	r30, r18
    1466:	20 81       	ld	r18, Z
    1468:	28 60       	ori	r18, 0x08	; 8
    146a:	fc 01       	movw	r30, r24
    146c:	20 83       	st	Z, r18
				}
				/* the default case will be normal port operation OCO disconnected
				enable interrupt for compare mode */
				TIMSK = (1 << OCIE0);
    146e:	89 e5       	ldi	r24, 0x59	; 89
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	22 e0       	ldi	r18, 0x02	; 2
    1474:	fc 01       	movw	r30, r24
    1476:	20 83       	st	Z, r18
    1478:	6b c0       	rjmp	.+214    	; 0x1550 <TIMER_init+0x26c>
/****************************************************
 * 		0-2 normal  mode for TIMER0		    *
 * ***************************************************
 */

		else if (!strcmp(config->mode, "normal"))
    147a:	89 81       	ldd	r24, Y+1	; 0x01
    147c:	9a 81       	ldd	r25, Y+2	; 0x02
    147e:	01 96       	adiw	r24, 0x01	; 1
    1480:	6e e8       	ldi	r22, 0x8E	; 142
    1482:	70 e0       	ldi	r23, 0x00	; 0
    1484:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1488:	89 2b       	or	r24, r25
    148a:	79 f4       	brne	.+30     	; 0x14aa <TIMER_init+0x1c6>
			{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM01=0 and WGM00=0
			 */
			TCCR0 |= (1 << FOC0);
    148c:	83 e5       	ldi	r24, 0x53	; 83
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	23 e5       	ldi	r18, 0x53	; 83
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	f9 01       	movw	r30, r18
    1496:	20 81       	ld	r18, Z
    1498:	20 68       	ori	r18, 0x80	; 128
    149a:	fc 01       	movw	r30, r24
    149c:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE0);
    149e:	89 e5       	ldi	r24, 0x59	; 89
    14a0:	90 e0       	ldi	r25, 0x00	; 0
    14a2:	21 e0       	ldi	r18, 0x01	; 1
    14a4:	fc 01       	movw	r30, r24
    14a6:	20 83       	st	Z, r18
    14a8:	53 c0       	rjmp	.+166    	; 0x1550 <TIMER_init+0x26c>
			}
/****************************************************
 * 			0-3 PWM  mode for TIMER0	   *
 * ***************************************************
								 */
		else if (!strcmp(config->mode, "pwm")) {
    14aa:	89 81       	ldd	r24, Y+1	; 0x01
    14ac:	9a 81       	ldd	r25, Y+2	; 0x02
    14ae:	01 96       	adiw	r24, 0x01	; 1
    14b0:	65 e9       	ldi	r22, 0x95	; 149
    14b2:	70 e0       	ldi	r23, 0x00	; 0
    14b4:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    14b8:	89 2b       	or	r24, r25
    14ba:	09 f0       	breq	.+2      	; 0x14be <TIMER_init+0x1da>
    14bc:	49 c0       	rjmp	.+146    	; 0x1550 <TIMER_init+0x26c>
			/*
			 * FOC0=0 for  PWM mode
			 * select PWM mode --->> WGM01=1 and WGM00=1
			 */
			TCCR0 |= (1 << WGM00) | (1 << WGM01);
    14be:	83 e5       	ldi	r24, 0x53	; 83
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	23 e5       	ldi	r18, 0x53	; 83
    14c4:	30 e0       	ldi	r19, 0x00	; 0
    14c6:	f9 01       	movw	r30, r18
    14c8:	20 81       	ld	r18, Z
    14ca:	28 64       	ori	r18, 0x48	; 72
    14cc:	fc 01       	movw	r30, r24
    14ce:	20 83       	st	Z, r18


			if (!strcmp(config->pwmMode, "inverting")) {
    14d0:	89 81       	ldd	r24, Y+1	; 0x01
    14d2:	9a 81       	ldd	r25, Y+2	; 0x02
    14d4:	8b 96       	adiw	r24, 0x2b	; 43
    14d6:	69 e9       	ldi	r22, 0x99	; 153
    14d8:	70 e0       	ldi	r23, 0x00	; 0
    14da:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    14de:	89 2b       	or	r24, r25
    14e0:	e1 f4       	brne	.+56     	; 0x151a <TIMER_init+0x236>
				/* COM00=1 and COM01=1 */
				TCCR0 |= (1 << COM00);
    14e2:	83 e5       	ldi	r24, 0x53	; 83
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	23 e5       	ldi	r18, 0x53	; 83
    14e8:	30 e0       	ldi	r19, 0x00	; 0
    14ea:	f9 01       	movw	r30, r18
    14ec:	20 81       	ld	r18, Z
    14ee:	20 61       	ori	r18, 0x10	; 16
    14f0:	fc 01       	movw	r30, r24
    14f2:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM01);
    14f4:	83 e5       	ldi	r24, 0x53	; 83
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	23 e5       	ldi	r18, 0x53	; 83
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	f9 01       	movw	r30, r18
    14fe:	20 81       	ld	r18, Z
    1500:	20 62       	ori	r18, 0x20	; 32
    1502:	fc 01       	movw	r30, r24
    1504:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    1506:	87 e3       	ldi	r24, 0x37	; 55
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	27 e3       	ldi	r18, 0x37	; 55
    150c:	30 e0       	ldi	r19, 0x00	; 0
    150e:	f9 01       	movw	r30, r18
    1510:	20 81       	ld	r18, Z
    1512:	28 60       	ori	r18, 0x08	; 8
    1514:	fc 01       	movw	r30, r24
    1516:	20 83       	st	Z, r18
    1518:	1b c0       	rjmp	.+54     	; 0x1550 <TIMER_init+0x26c>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    151a:	89 81       	ldd	r24, Y+1	; 0x01
    151c:	9a 81       	ldd	r25, Y+2	; 0x02
    151e:	8b 96       	adiw	r24, 0x2b	; 43
    1520:	63 ea       	ldi	r22, 0xA3	; 163
    1522:	70 e0       	ldi	r23, 0x00	; 0
    1524:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1528:	89 2b       	or	r24, r25
    152a:	91 f4       	brne	.+36     	; 0x1550 <TIMER_init+0x26c>
				/* COM00=0 and COM01=1 */
				TCCR0 |= (1 << COM01);
    152c:	83 e5       	ldi	r24, 0x53	; 83
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	23 e5       	ldi	r18, 0x53	; 83
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	f9 01       	movw	r30, r18
    1536:	20 81       	ld	r18, Z
    1538:	20 62       	ori	r18, 0x20	; 32
    153a:	fc 01       	movw	r30, r24
    153c:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    153e:	87 e3       	ldi	r24, 0x37	; 55
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	27 e3       	ldi	r18, 0x37	; 55
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	f9 01       	movw	r30, r18
    1548:	20 81       	ld	r18, Z
    154a:	28 60       	ori	r18, 0x08	; 8
    154c:	fc 01       	movw	r30, r24
    154e:	20 83       	st	Z, r18
*/

	if (config->timerNumber == 1) {
		/* put zeros into all bits in the registers */
	}
		TCCR1A = 0;
    1550:	8f e4       	ldi	r24, 0x4F	; 79
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	fc 01       	movw	r30, r24
    1556:	10 82       	st	Z, r1
		TCCR1B = 0;
    1558:	8e e4       	ldi	r24, 0x4E	; 78
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	fc 01       	movw	r30, r24
    155e:	10 82       	st	Z, r1

		switch (config->prescaler) {
    1560:	89 81       	ldd	r24, Y+1	; 0x01
    1562:	9a 81       	ldd	r25, Y+2	; 0x02
    1564:	fc 01       	movw	r30, r24
    1566:	85 89       	ldd	r24, Z+21	; 0x15
    1568:	96 89       	ldd	r25, Z+22	; 0x16
    156a:	80 34       	cpi	r24, 0x40	; 64
    156c:	91 05       	cpc	r25, r1
    156e:	c1 f0       	breq	.+48     	; 0x15a0 <TIMER_init+0x2bc>
    1570:	81 34       	cpi	r24, 0x41	; 65
    1572:	91 05       	cpc	r25, r1
    1574:	18 f4       	brcc	.+6      	; 0x157c <TIMER_init+0x298>
    1576:	08 97       	sbiw	r24, 0x08	; 8
    1578:	49 f0       	breq	.+18     	; 0x158c <TIMER_init+0x2a8>
    157a:	30 c0       	rjmp	.+96     	; 0x15dc <TIMER_init+0x2f8>
    157c:	81 15       	cp	r24, r1
    157e:	f1 e0       	ldi	r31, 0x01	; 1
    1580:	9f 07       	cpc	r25, r31
    1582:	c1 f0       	breq	.+48     	; 0x15b4 <TIMER_init+0x2d0>
    1584:	81 15       	cp	r24, r1
    1586:	94 40       	sbci	r25, 0x04	; 4
    1588:	f9 f0       	breq	.+62     	; 0x15c8 <TIMER_init+0x2e4>
    158a:	28 c0       	rjmp	.+80     	; 0x15dc <TIMER_init+0x2f8>
		case 8:
			TCCR1B |= (1 << CS11);/*CS10=0  CS11=1 CS12=0  */
    158c:	8e e4       	ldi	r24, 0x4E	; 78
    158e:	90 e0       	ldi	r25, 0x00	; 0
    1590:	2e e4       	ldi	r18, 0x4E	; 78
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	f9 01       	movw	r30, r18
    1596:	20 81       	ld	r18, Z
    1598:	22 60       	ori	r18, 0x02	; 2
    159a:	fc 01       	movw	r30, r24
    159c:	20 83       	st	Z, r18
			break;
    159e:	27 c0       	rjmp	.+78     	; 0x15ee <TIMER_init+0x30a>
		case 64:
			TCCR1B |= (1 << CS10) | (1 << CS11); /*CS10=1  CS11=1 CS12=0  */
    15a0:	8e e4       	ldi	r24, 0x4E	; 78
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	2e e4       	ldi	r18, 0x4E	; 78
    15a6:	30 e0       	ldi	r19, 0x00	; 0
    15a8:	f9 01       	movw	r30, r18
    15aa:	20 81       	ld	r18, Z
    15ac:	23 60       	ori	r18, 0x03	; 3
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
			break;
    15b2:	1d c0       	rjmp	.+58     	; 0x15ee <TIMER_init+0x30a>
		case 256:
			TCCR1B |= (1 << CS12);/*CS10=0  CS11=0 CS12=1  */
    15b4:	8e e4       	ldi	r24, 0x4E	; 78
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	2e e4       	ldi	r18, 0x4E	; 78
    15ba:	30 e0       	ldi	r19, 0x00	; 0
    15bc:	f9 01       	movw	r30, r18
    15be:	20 81       	ld	r18, Z
    15c0:	24 60       	ori	r18, 0x04	; 4
    15c2:	fc 01       	movw	r30, r24
    15c4:	20 83       	st	Z, r18
			break;
    15c6:	13 c0       	rjmp	.+38     	; 0x15ee <TIMER_init+0x30a>
		case 1024:
			TCCR1B |= (1 << CS10) | (1 << CS12);/*CS10=1  CS11=1 CS12=1  */
    15c8:	8e e4       	ldi	r24, 0x4E	; 78
    15ca:	90 e0       	ldi	r25, 0x00	; 0
    15cc:	2e e4       	ldi	r18, 0x4E	; 78
    15ce:	30 e0       	ldi	r19, 0x00	; 0
    15d0:	f9 01       	movw	r30, r18
    15d2:	20 81       	ld	r18, Z
    15d4:	25 60       	ori	r18, 0x05	; 5
    15d6:	fc 01       	movw	r30, r24
    15d8:	20 83       	st	Z, r18
			break;
    15da:	09 c0       	rjmp	.+18     	; 0x15ee <TIMER_init+0x30a>
		default:/* the default case work scale 1:1 even the prescaler member not determine */
			TCCR1B |= (1 << CS10); /*CS10=1  CS11=0 CS12=0  */
    15dc:	8e e4       	ldi	r24, 0x4E	; 78
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	2e e4       	ldi	r18, 0x4E	; 78
    15e2:	30 e0       	ldi	r19, 0x00	; 0
    15e4:	f9 01       	movw	r30, r18
    15e6:	20 81       	ld	r18, Z
    15e8:	21 60       	ori	r18, 0x01	; 1
    15ea:	fc 01       	movw	r30, r24
    15ec:	20 83       	st	Z, r18

/****************************************************
* 		1-1 compare match output mode for TIMER1 A	*
* ***************************************************
*/
		if (!strcmp(config->mode, "compare")) {
    15ee:	89 81       	ldd	r24, Y+1	; 0x01
    15f0:	9a 81       	ldd	r25, Y+2	; 0x02
    15f2:	01 96       	adiw	r24, 0x01	; 1
    15f4:	65 e7       	ldi	r22, 0x75	; 117
    15f6:	70 e0       	ldi	r23, 0x00	; 0
    15f8:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    15fc:	89 2b       	or	r24, r25
    15fe:	09 f0       	breq	.+2      	; 0x1602 <TIMER_init+0x31e>
    1600:	6b c0       	rjmp	.+214    	; 0x16d8 <TIMER_init+0x3f4>
			/*
			 * FOC1=1 for non PWM mode
			 * select compare mode --->> /* WGM10=0 ,  WGM11=0 , WGM12=1 and WGM13=0 */
			TCCR1A |= (1 << FOC1A);
    1602:	8f e4       	ldi	r24, 0x4F	; 79
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	2f e4       	ldi	r18, 0x4F	; 79
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	f9 01       	movw	r30, r18
    160c:	20 81       	ld	r18, Z
    160e:	28 60       	ori	r18, 0x08	; 8
    1610:	fc 01       	movw	r30, r24
    1612:	20 83       	st	Z, r18
			TCCR1B |= (1 << WGM12);
    1614:	8e e4       	ldi	r24, 0x4E	; 78
    1616:	90 e0       	ldi	r25, 0x00	; 0
    1618:	2e e4       	ldi	r18, 0x4E	; 78
    161a:	30 e0       	ldi	r19, 0x00	; 0
    161c:	f9 01       	movw	r30, r18
    161e:	20 81       	ld	r18, Z
    1620:	28 60       	ori	r18, 0x08	; 8
    1622:	fc 01       	movw	r30, r24
    1624:	20 83       	st	Z, r18
			if (!strcmp(config->compareMatchMode, "toggle")) {
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	9a 81       	ldd	r25, Y+2	; 0x02
    162a:	47 96       	adiw	r24, 0x17	; 23
    162c:	6d e7       	ldi	r22, 0x7D	; 125
    162e:	70 e0       	ldi	r23, 0x00	; 0
    1630:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1634:	89 2b       	or	r24, r25
    1636:	99 f4       	brne	.+38     	; 0x165e <TIMER_init+0x37a>
				TCCR1A |= (1 << COM1A0); /*COM1A0=1 AND COM1A1=0 */
    1638:	8f e4       	ldi	r24, 0x4F	; 79
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	2f e4       	ldi	r18, 0x4F	; 79
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	f9 01       	movw	r30, r18
    1642:	20 81       	ld	r18, Z
    1644:	20 64       	ori	r18, 0x40	; 64
    1646:	fc 01       	movw	r30, r24
    1648:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);/*make OCO AS OUTPUT BIT */
    164a:	81 e3       	ldi	r24, 0x31	; 49
    164c:	90 e0       	ldi	r25, 0x00	; 0
    164e:	21 e3       	ldi	r18, 0x31	; 49
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	f9 01       	movw	r30, r18
    1654:	20 81       	ld	r18, Z
    1656:	20 62       	ori	r18, 0x20	; 32
    1658:	fc 01       	movw	r30, r24
    165a:	20 83       	st	Z, r18
    165c:	37 c0       	rjmp	.+110    	; 0x16cc <TIMER_init+0x3e8>
			} else if (!strcmp(config->compareMatchMode, "clear")) {
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	9a 81       	ldd	r25, Y+2	; 0x02
    1662:	47 96       	adiw	r24, 0x17	; 23
    1664:	64 e8       	ldi	r22, 0x84	; 132
    1666:	70 e0       	ldi	r23, 0x00	; 0
    1668:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    166c:	89 2b       	or	r24, r25
    166e:	99 f4       	brne	.+38     	; 0x1696 <TIMER_init+0x3b2>
				TCCR1A |= (1 << COM1A1);/*COM1A0=0 AND COM1A1=1 */
    1670:	8f e4       	ldi	r24, 0x4F	; 79
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	2f e4       	ldi	r18, 0x4F	; 79
    1676:	30 e0       	ldi	r19, 0x00	; 0
    1678:	f9 01       	movw	r30, r18
    167a:	20 81       	ld	r18, Z
    167c:	20 68       	ori	r18, 0x80	; 128
    167e:	fc 01       	movw	r30, r24
    1680:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    1682:	81 e3       	ldi	r24, 0x31	; 49
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	21 e3       	ldi	r18, 0x31	; 49
    1688:	30 e0       	ldi	r19, 0x00	; 0
    168a:	f9 01       	movw	r30, r18
    168c:	20 81       	ld	r18, Z
    168e:	20 62       	ori	r18, 0x20	; 32
    1690:	fc 01       	movw	r30, r24
    1692:	20 83       	st	Z, r18
    1694:	1b c0       	rjmp	.+54     	; 0x16cc <TIMER_init+0x3e8>

			} else if (!strcmp(config->compareMatchMode, "set")) {
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	9a 81       	ldd	r25, Y+2	; 0x02
    169a:	47 96       	adiw	r24, 0x17	; 23
    169c:	6a e8       	ldi	r22, 0x8A	; 138
    169e:	70 e0       	ldi	r23, 0x00	; 0
    16a0:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    16a4:	89 2b       	or	r24, r25
    16a6:	91 f4       	brne	.+36     	; 0x16cc <TIMER_init+0x3e8>
				TCCR1A |= (1 << COM1A1) | (1 << COM1A0);/*COM1A0=1 AND COM1A1=1 */
    16a8:	8f e4       	ldi	r24, 0x4F	; 79
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	2f e4       	ldi	r18, 0x4F	; 79
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	f9 01       	movw	r30, r18
    16b2:	20 81       	ld	r18, Z
    16b4:	20 6c       	ori	r18, 0xC0	; 192
    16b6:	fc 01       	movw	r30, r24
    16b8:	20 83       	st	Z, r18
				SET_BIT(DDRD, 5);
    16ba:	81 e3       	ldi	r24, 0x31	; 49
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	21 e3       	ldi	r18, 0x31	; 49
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	f9 01       	movw	r30, r18
    16c4:	20 81       	ld	r18, Z
    16c6:	20 62       	ori	r18, 0x20	; 32
    16c8:	fc 01       	movw	r30, r24
    16ca:	20 83       	st	Z, r18

			}
			/* the default case will be normal port operation OCO disconnected
							enable interrupt for compare mode */
			TIMSK = (1 << OCIE1A);
    16cc:	89 e5       	ldi	r24, 0x59	; 89
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	20 e1       	ldi	r18, 0x10	; 16
    16d2:	fc 01       	movw	r30, r24
    16d4:	20 83       	st	Z, r18
    16d6:	6b c0       	rjmp	.+214    	; 0x17ae <TIMER_init+0x4ca>
/****************************************************
* 		1-2 normal  mode for TIMER1		      *
* ***************************************************
*/
		} else if (!strcmp(config->mode, "normal"))
    16d8:	89 81       	ldd	r24, Y+1	; 0x01
    16da:	9a 81       	ldd	r25, Y+2	; 0x02
    16dc:	01 96       	adiw	r24, 0x01	; 1
    16de:	6e e8       	ldi	r22, 0x8E	; 142
    16e0:	70 e0       	ldi	r23, 0x00	; 0
    16e2:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    16e6:	89 2b       	or	r24, r25
    16e8:	79 f4       	brne	.+30     	; 0x1708 <TIMER_init+0x424>
		{
			/*
			 * FOC0=1 for non PWM mode
			 * select normal mode --->> WGM11=0 and WGM10=0
						 */
			TCCR1A |= (1 << FOC1A);
    16ea:	8f e4       	ldi	r24, 0x4F	; 79
    16ec:	90 e0       	ldi	r25, 0x00	; 0
    16ee:	2f e4       	ldi	r18, 0x4F	; 79
    16f0:	30 e0       	ldi	r19, 0x00	; 0
    16f2:	f9 01       	movw	r30, r18
    16f4:	20 81       	ld	r18, Z
    16f6:	28 60       	ori	r18, 0x08	; 8
    16f8:	fc 01       	movw	r30, r24
    16fa:	20 83       	st	Z, r18
			TIMSK = (1 << TOIE1);
    16fc:	89 e5       	ldi	r24, 0x59	; 89
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	24 e0       	ldi	r18, 0x04	; 4
    1702:	fc 01       	movw	r30, r24
    1704:	20 83       	st	Z, r18
    1706:	53 c0       	rjmp	.+166    	; 0x17ae <TIMER_init+0x4ca>


/****************************************************
 * 			1-3 PWM  mode for TIMER1 A		  *
 * ***************************************************/
		} else if (!strcmp(config->mode, "pwm")) {
    1708:	89 81       	ldd	r24, Y+1	; 0x01
    170a:	9a 81       	ldd	r25, Y+2	; 0x02
    170c:	01 96       	adiw	r24, 0x01	; 1
    170e:	65 e9       	ldi	r22, 0x95	; 149
    1710:	70 e0       	ldi	r23, 0x00	; 0
    1712:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1716:	89 2b       	or	r24, r25
    1718:	09 f0       	breq	.+2      	; 0x171c <TIMER_init+0x438>
    171a:	49 c0       	rjmp	.+146    	; 0x17ae <TIMER_init+0x4ca>
			/* WGM10=1 ,  WGM11=1 , WGM12=1 and WGM13=1 */
			TCCR0 |= (1 << WGM10) | (1 << WGM11)| (1 << WGM12)| (1 << WGM13);
    171c:	83 e5       	ldi	r24, 0x53	; 83
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	23 e5       	ldi	r18, 0x53	; 83
    1722:	30 e0       	ldi	r19, 0x00	; 0
    1724:	f9 01       	movw	r30, r18
    1726:	20 81       	ld	r18, Z
    1728:	2b 61       	ori	r18, 0x1B	; 27
    172a:	fc 01       	movw	r30, r24
    172c:	20 83       	st	Z, r18
			if (!strcmp(config->pwmMode, "inverting")) {
    172e:	89 81       	ldd	r24, Y+1	; 0x01
    1730:	9a 81       	ldd	r25, Y+2	; 0x02
    1732:	8b 96       	adiw	r24, 0x2b	; 43
    1734:	69 e9       	ldi	r22, 0x99	; 153
    1736:	70 e0       	ldi	r23, 0x00	; 0
    1738:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    173c:	89 2b       	or	r24, r25
    173e:	e1 f4       	brne	.+56     	; 0x1778 <TIMER_init+0x494>
				TCCR0 |= (1 << COM1A0);/* COM1A0=1 and COM1A1=1 */
    1740:	83 e5       	ldi	r24, 0x53	; 83
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	23 e5       	ldi	r18, 0x53	; 83
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	f9 01       	movw	r30, r18
    174a:	20 81       	ld	r18, Z
    174c:	20 64       	ori	r18, 0x40	; 64
    174e:	fc 01       	movw	r30, r24
    1750:	20 83       	st	Z, r18
				TCCR0 |= (1 << COM1A1);
    1752:	83 e5       	ldi	r24, 0x53	; 83
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	23 e5       	ldi	r18, 0x53	; 83
    1758:	30 e0       	ldi	r19, 0x00	; 0
    175a:	f9 01       	movw	r30, r18
    175c:	20 81       	ld	r18, Z
    175e:	20 68       	ori	r18, 0x80	; 128
    1760:	fc 01       	movw	r30, r24
    1762:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);
    1764:	87 e3       	ldi	r24, 0x37	; 55
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	27 e3       	ldi	r18, 0x37	; 55
    176a:	30 e0       	ldi	r19, 0x00	; 0
    176c:	f9 01       	movw	r30, r18
    176e:	20 81       	ld	r18, Z
    1770:	28 60       	ori	r18, 0x08	; 8
    1772:	fc 01       	movw	r30, r24
    1774:	20 83       	st	Z, r18
    1776:	1b c0       	rjmp	.+54     	; 0x17ae <TIMER_init+0x4ca>
			} else if (!strcmp(config->pwmMode, "non-inverting")) {
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	9a 81       	ldd	r25, Y+2	; 0x02
    177c:	8b 96       	adiw	r24, 0x2b	; 43
    177e:	63 ea       	ldi	r22, 0xA3	; 163
    1780:	70 e0       	ldi	r23, 0x00	; 0
    1782:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1786:	89 2b       	or	r24, r25
    1788:	91 f4       	brne	.+36     	; 0x17ae <TIMER_init+0x4ca>
				TCCR0 |= (1 << COM1A1);/* COM1A0=0 and COM1A1=1 */
    178a:	83 e5       	ldi	r24, 0x53	; 83
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	23 e5       	ldi	r18, 0x53	; 83
    1790:	30 e0       	ldi	r19, 0x00	; 0
    1792:	f9 01       	movw	r30, r18
    1794:	20 81       	ld	r18, Z
    1796:	20 68       	ori	r18, 0x80	; 128
    1798:	fc 01       	movw	r30, r24
    179a:	20 83       	st	Z, r18
				SET_BIT(DDRB, 3);/*make OCO AS OUTPUT BIT */
    179c:	87 e3       	ldi	r24, 0x37	; 55
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	27 e3       	ldi	r18, 0x37	; 55
    17a2:	30 e0       	ldi	r19, 0x00	; 0
    17a4:	f9 01       	movw	r30, r18
    17a6:	20 81       	ld	r18, Z
    17a8:	28 60       	ori	r18, 0x08	; 8
    17aa:	fc 01       	movw	r30, r24
    17ac:	20 83       	st	Z, r18

		}
/***************************************************************
* 						2	TIMER2						*
 * *************************************************************/
		if (config->timerNumber == 2) {
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	9a 81       	ldd	r25, Y+2	; 0x02
    17b2:	fc 01       	movw	r30, r24
    17b4:	80 81       	ld	r24, Z
    17b6:	82 30       	cpi	r24, 0x02	; 2
    17b8:	09 f0       	breq	.+2      	; 0x17bc <TIMER_init+0x4d8>
    17ba:	3d c1       	rjmp	.+634    	; 0x1a36 <TIMER_init+0x752>
			TCCR2 = 0;/* put zeros into all bits in the register */
    17bc:	85 e4       	ldi	r24, 0x45	; 69
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	fc 01       	movw	r30, r24
    17c2:	10 82       	st	Z, r1
			switch (config->prescaler) {
    17c4:	89 81       	ldd	r24, Y+1	; 0x01
    17c6:	9a 81       	ldd	r25, Y+2	; 0x02
    17c8:	fc 01       	movw	r30, r24
    17ca:	85 89       	ldd	r24, Z+21	; 0x15
    17cc:	96 89       	ldd	r25, Z+22	; 0x16
    17ce:	80 34       	cpi	r24, 0x40	; 64
    17d0:	91 05       	cpc	r25, r1
    17d2:	49 f1       	breq	.+82     	; 0x1826 <TIMER_init+0x542>
    17d4:	81 34       	cpi	r24, 0x41	; 65
    17d6:	91 05       	cpc	r25, r1
    17d8:	30 f4       	brcc	.+12     	; 0x17e6 <TIMER_init+0x502>
    17da:	88 30       	cpi	r24, 0x08	; 8
    17dc:	91 05       	cpc	r25, r1
    17de:	79 f0       	breq	.+30     	; 0x17fe <TIMER_init+0x51a>
    17e0:	80 97       	sbiw	r24, 0x20	; 32
    17e2:	b9 f0       	breq	.+46     	; 0x1812 <TIMER_init+0x52e>
    17e4:	48 c0       	rjmp	.+144    	; 0x1876 <TIMER_init+0x592>
    17e6:	81 15       	cp	r24, r1
    17e8:	f1 e0       	ldi	r31, 0x01	; 1
    17ea:	9f 07       	cpc	r25, r31
    17ec:	81 f1       	breq	.+96     	; 0x184e <TIMER_init+0x56a>
    17ee:	81 15       	cp	r24, r1
    17f0:	24 e0       	ldi	r18, 0x04	; 4
    17f2:	92 07       	cpc	r25, r18
    17f4:	b1 f1       	breq	.+108    	; 0x1862 <TIMER_init+0x57e>
    17f6:	80 38       	cpi	r24, 0x80	; 128
    17f8:	91 05       	cpc	r25, r1
    17fa:	f9 f0       	breq	.+62     	; 0x183a <TIMER_init+0x556>
    17fc:	3c c0       	rjmp	.+120    	; 0x1876 <TIMER_init+0x592>
			case 8:
				TCCR2 |= (1 << CS21);/*CS20=0  CS21=1 CS22=0  */
    17fe:	85 e4       	ldi	r24, 0x45	; 69
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	25 e4       	ldi	r18, 0x45	; 69
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	f9 01       	movw	r30, r18
    1808:	20 81       	ld	r18, Z
    180a:	22 60       	ori	r18, 0x02	; 2
    180c:	fc 01       	movw	r30, r24
    180e:	20 83       	st	Z, r18
				break;
    1810:	3b c0       	rjmp	.+118    	; 0x1888 <TIMER_init+0x5a4>
			case 32:
				TCCR2 |= (1 << CS20) | (1 << CS21);/*CS20=1  CS21=0 CS22=0  */
    1812:	85 e4       	ldi	r24, 0x45	; 69
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	25 e4       	ldi	r18, 0x45	; 69
    1818:	30 e0       	ldi	r19, 0x00	; 0
    181a:	f9 01       	movw	r30, r18
    181c:	20 81       	ld	r18, Z
    181e:	23 60       	ori	r18, 0x03	; 3
    1820:	fc 01       	movw	r30, r24
    1822:	20 83       	st	Z, r18
				break;
    1824:	31 c0       	rjmp	.+98     	; 0x1888 <TIMER_init+0x5a4>
			case 64:
				TCCR2 |= (1 << CS22);/*CS20=0  CS21=0 CS22=1  */
    1826:	85 e4       	ldi	r24, 0x45	; 69
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	25 e4       	ldi	r18, 0x45	; 69
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	f9 01       	movw	r30, r18
    1830:	20 81       	ld	r18, Z
    1832:	24 60       	ori	r18, 0x04	; 4
    1834:	fc 01       	movw	r30, r24
    1836:	20 83       	st	Z, r18
				break;
    1838:	27 c0       	rjmp	.+78     	; 0x1888 <TIMER_init+0x5a4>
			case 128:
				TCCR2 |= (1 << CS20) | (1 << CS22);/*CS20=1  CS21=0 CS22=1  */
    183a:	85 e4       	ldi	r24, 0x45	; 69
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	25 e4       	ldi	r18, 0x45	; 69
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	f9 01       	movw	r30, r18
    1844:	20 81       	ld	r18, Z
    1846:	25 60       	ori	r18, 0x05	; 5
    1848:	fc 01       	movw	r30, r24
    184a:	20 83       	st	Z, r18
				break;
    184c:	1d c0       	rjmp	.+58     	; 0x1888 <TIMER_init+0x5a4>
			case 256:
				TCCR2 |= (1 << CS21) | (1 << CS22);/*CS20=0  CS21=1 CS22=1  */
    184e:	85 e4       	ldi	r24, 0x45	; 69
    1850:	90 e0       	ldi	r25, 0x00	; 0
    1852:	25 e4       	ldi	r18, 0x45	; 69
    1854:	30 e0       	ldi	r19, 0x00	; 0
    1856:	f9 01       	movw	r30, r18
    1858:	20 81       	ld	r18, Z
    185a:	26 60       	ori	r18, 0x06	; 6
    185c:	fc 01       	movw	r30, r24
    185e:	20 83       	st	Z, r18
				break;
    1860:	13 c0       	rjmp	.+38     	; 0x1888 <TIMER_init+0x5a4>
			case 1024:
				TCCR2 |= (1 << CS20) | (1 << CS21) | (1 << CS22);/*CS20=1  CS21=1 CS22=1  */
    1862:	85 e4       	ldi	r24, 0x45	; 69
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	25 e4       	ldi	r18, 0x45	; 69
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	f9 01       	movw	r30, r18
    186c:	20 81       	ld	r18, Z
    186e:	27 60       	ori	r18, 0x07	; 7
    1870:	fc 01       	movw	r30, r24
    1872:	20 83       	st	Z, r18
				break;
    1874:	09 c0       	rjmp	.+18     	; 0x1888 <TIMER_init+0x5a4>
			default:/* the default case work scale 1:1 even the prescaler member not determine */
				TCCR2 |= (1 << CS20);/*CS20=1  CS21=0 CS22=0  */
    1876:	85 e4       	ldi	r24, 0x45	; 69
    1878:	90 e0       	ldi	r25, 0x00	; 0
    187a:	25 e4       	ldi	r18, 0x45	; 69
    187c:	30 e0       	ldi	r19, 0x00	; 0
    187e:	f9 01       	movw	r30, r18
    1880:	20 81       	ld	r18, Z
    1882:	21 60       	ori	r18, 0x01	; 1
    1884:	fc 01       	movw	r30, r24
    1886:	20 83       	st	Z, r18

/****************************************************
* 		2-1 compare match output mode for TIMER2	*
 * ***************************************************
					 */
			if (!strcmp(config->mode, "compare")) {
    1888:	89 81       	ldd	r24, Y+1	; 0x01
    188a:	9a 81       	ldd	r25, Y+2	; 0x02
    188c:	01 96       	adiw	r24, 0x01	; 1
    188e:	65 e7       	ldi	r22, 0x75	; 117
    1890:	70 e0       	ldi	r23, 0x00	; 0
    1892:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1896:	89 2b       	or	r24, r25
    1898:	09 f0       	breq	.+2      	; 0x189c <TIMER_init+0x5b8>
    189a:	62 c0       	rjmp	.+196    	; 0x1960 <TIMER_init+0x67c>
				/*
				 * FOC2=1 for non PWM mode
				 * select compare mode --->> WGM21=1 and WGM20=0
				 */
				TCCR2 |= (1 << FOC2) | (1 << WGM21);
    189c:	85 e4       	ldi	r24, 0x45	; 69
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	25 e4       	ldi	r18, 0x45	; 69
    18a2:	30 e0       	ldi	r19, 0x00	; 0
    18a4:	f9 01       	movw	r30, r18
    18a6:	20 81       	ld	r18, Z
    18a8:	28 68       	ori	r18, 0x88	; 136
    18aa:	fc 01       	movw	r30, r24
    18ac:	20 83       	st	Z, r18

				if (!strcmp(config->compareMatchMode, "toggle")) {
    18ae:	89 81       	ldd	r24, Y+1	; 0x01
    18b0:	9a 81       	ldd	r25, Y+2	; 0x02
    18b2:	47 96       	adiw	r24, 0x17	; 23
    18b4:	6d e7       	ldi	r22, 0x7D	; 125
    18b6:	70 e0       	ldi	r23, 0x00	; 0
    18b8:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    18bc:	89 2b       	or	r24, r25
    18be:	99 f4       	brne	.+38     	; 0x18e6 <TIMER_init+0x602>
					TCCR2 |= (1 << COM20);/*COM20=1 AND COM21=0 */
    18c0:	85 e4       	ldi	r24, 0x45	; 69
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	25 e4       	ldi	r18, 0x45	; 69
    18c6:	30 e0       	ldi	r19, 0x00	; 0
    18c8:	f9 01       	movw	r30, r18
    18ca:	20 81       	ld	r18, Z
    18cc:	20 61       	ori	r18, 0x10	; 16
    18ce:	fc 01       	movw	r30, r24
    18d0:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    18d2:	81 e3       	ldi	r24, 0x31	; 49
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	21 e3       	ldi	r18, 0x31	; 49
    18d8:	30 e0       	ldi	r19, 0x00	; 0
    18da:	f9 01       	movw	r30, r18
    18dc:	20 81       	ld	r18, Z
    18de:	20 68       	ori	r18, 0x80	; 128
    18e0:	fc 01       	movw	r30, r24
    18e2:	20 83       	st	Z, r18
    18e4:	37 c0       	rjmp	.+110    	; 0x1954 <TIMER_init+0x670>
				} else if (!strcmp(config->compareMatchMode, "clear")) {
    18e6:	89 81       	ldd	r24, Y+1	; 0x01
    18e8:	9a 81       	ldd	r25, Y+2	; 0x02
    18ea:	47 96       	adiw	r24, 0x17	; 23
    18ec:	64 e8       	ldi	r22, 0x84	; 132
    18ee:	70 e0       	ldi	r23, 0x00	; 0
    18f0:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    18f4:	89 2b       	or	r24, r25
    18f6:	99 f4       	brne	.+38     	; 0x191e <TIMER_init+0x63a>
					TCCR2 |= (1 << COM21);/*COM20=0 AND COM21=1 */
    18f8:	85 e4       	ldi	r24, 0x45	; 69
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	25 e4       	ldi	r18, 0x45	; 69
    18fe:	30 e0       	ldi	r19, 0x00	; 0
    1900:	f9 01       	movw	r30, r18
    1902:	20 81       	ld	r18, Z
    1904:	20 62       	ori	r18, 0x20	; 32
    1906:	fc 01       	movw	r30, r24
    1908:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    190a:	81 e3       	ldi	r24, 0x31	; 49
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	21 e3       	ldi	r18, 0x31	; 49
    1910:	30 e0       	ldi	r19, 0x00	; 0
    1912:	f9 01       	movw	r30, r18
    1914:	20 81       	ld	r18, Z
    1916:	20 68       	ori	r18, 0x80	; 128
    1918:	fc 01       	movw	r30, r24
    191a:	20 83       	st	Z, r18
    191c:	1b c0       	rjmp	.+54     	; 0x1954 <TIMER_init+0x670>

				} else if (!strcmp(config->compareMatchMode, "set")) {
    191e:	89 81       	ldd	r24, Y+1	; 0x01
    1920:	9a 81       	ldd	r25, Y+2	; 0x02
    1922:	47 96       	adiw	r24, 0x17	; 23
    1924:	6a e8       	ldi	r22, 0x8A	; 138
    1926:	70 e0       	ldi	r23, 0x00	; 0
    1928:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    192c:	89 2b       	or	r24, r25
    192e:	91 f4       	brne	.+36     	; 0x1954 <TIMER_init+0x670>
					TCCR2 |= (1 << COM21) | (1 << COM20);/*COM20=1 AND COM21=1 */
    1930:	85 e4       	ldi	r24, 0x45	; 69
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	25 e4       	ldi	r18, 0x45	; 69
    1936:	30 e0       	ldi	r19, 0x00	; 0
    1938:	f9 01       	movw	r30, r18
    193a:	20 81       	ld	r18, Z
    193c:	20 63       	ori	r18, 0x30	; 48
    193e:	fc 01       	movw	r30, r24
    1940:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    1942:	81 e3       	ldi	r24, 0x31	; 49
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	21 e3       	ldi	r18, 0x31	; 49
    1948:	30 e0       	ldi	r19, 0x00	; 0
    194a:	f9 01       	movw	r30, r18
    194c:	20 81       	ld	r18, Z
    194e:	20 68       	ori	r18, 0x80	; 128
    1950:	fc 01       	movw	r30, r24
    1952:	20 83       	st	Z, r18

				}
				/* the default case will be normal port operation OCO disconnected
											enable interrupt for compare mode */
				TIMSK = (1 << OCIE2);
    1954:	89 e5       	ldi	r24, 0x59	; 89
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	20 e8       	ldi	r18, 0x80	; 128
    195a:	fc 01       	movw	r30, r24
    195c:	20 83       	st	Z, r18
    195e:	6b c0       	rjmp	.+214    	; 0x1a36 <TIMER_init+0x752>

/****************************************************
* 		2-2 normal  mode for TIMER2		     *
 * ***************************************************
					 */
			else if (!strcmp(config->mode, "normal")) {
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	9a 81       	ldd	r25, Y+2	; 0x02
    1964:	01 96       	adiw	r24, 0x01	; 1
    1966:	6e e8       	ldi	r22, 0x8E	; 142
    1968:	70 e0       	ldi	r23, 0x00	; 0
    196a:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    196e:	89 2b       	or	r24, r25
    1970:	79 f4       	brne	.+30     	; 0x1990 <TIMER_init+0x6ac>
				/*
				 * FOC2=1 for non PWM mode
				 * select normal mode --->> WGM21=0 and WGM20=0
				*/
				TCCR2 |= (1 << FOC2);
    1972:	85 e4       	ldi	r24, 0x45	; 69
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	25 e4       	ldi	r18, 0x45	; 69
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	f9 01       	movw	r30, r18
    197c:	20 81       	ld	r18, Z
    197e:	20 68       	ori	r18, 0x80	; 128
    1980:	fc 01       	movw	r30, r24
    1982:	20 83       	st	Z, r18
				TIMSK = (1 << TOIE2); /*enable interrupt for normal mode */
    1984:	89 e5       	ldi	r24, 0x59	; 89
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	20 e4       	ldi	r18, 0x40	; 64
    198a:	fc 01       	movw	r30, r24
    198c:	20 83       	st	Z, r18
    198e:	53 c0       	rjmp	.+166    	; 0x1a36 <TIMER_init+0x752>

/****************************************************
 * 			2-3 PWM  mode for TIMER2	     *
 * ***************************************************/

			} else if (!strcmp(config->mode, "pwm")) {
    1990:	89 81       	ldd	r24, Y+1	; 0x01
    1992:	9a 81       	ldd	r25, Y+2	; 0x02
    1994:	01 96       	adiw	r24, 0x01	; 1
    1996:	65 e9       	ldi	r22, 0x95	; 149
    1998:	70 e0       	ldi	r23, 0x00	; 0
    199a:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    199e:	89 2b       	or	r24, r25
    19a0:	09 f0       	breq	.+2      	; 0x19a4 <TIMER_init+0x6c0>
    19a2:	49 c0       	rjmp	.+146    	; 0x1a36 <TIMER_init+0x752>
				/*
				 * FOC2=0 for  PWM mode
				 * select PWM mode --->> WGM21=1 and WGM20=1
				 */

				TCCR2 |= (1 << WGM20) | (1 << WGM21);
    19a4:	85 e4       	ldi	r24, 0x45	; 69
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	25 e4       	ldi	r18, 0x45	; 69
    19aa:	30 e0       	ldi	r19, 0x00	; 0
    19ac:	f9 01       	movw	r30, r18
    19ae:	20 81       	ld	r18, Z
    19b0:	28 64       	ori	r18, 0x48	; 72
    19b2:	fc 01       	movw	r30, r24
    19b4:	20 83       	st	Z, r18
				if (!strcmp(config->pwmMode, "inverting")) {
    19b6:	89 81       	ldd	r24, Y+1	; 0x01
    19b8:	9a 81       	ldd	r25, Y+2	; 0x02
    19ba:	8b 96       	adiw	r24, 0x2b	; 43
    19bc:	69 e9       	ldi	r22, 0x99	; 153
    19be:	70 e0       	ldi	r23, 0x00	; 0
    19c0:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    19c4:	89 2b       	or	r24, r25
    19c6:	e1 f4       	brne	.+56     	; 0x1a00 <TIMER_init+0x71c>
					/* COM20=1 and COM21=1 */
					TCCR2 |= (1 << COM20);
    19c8:	85 e4       	ldi	r24, 0x45	; 69
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	25 e4       	ldi	r18, 0x45	; 69
    19ce:	30 e0       	ldi	r19, 0x00	; 0
    19d0:	f9 01       	movw	r30, r18
    19d2:	20 81       	ld	r18, Z
    19d4:	20 61       	ori	r18, 0x10	; 16
    19d6:	fc 01       	movw	r30, r24
    19d8:	20 83       	st	Z, r18
					TCCR2 |= (1 << COM21);
    19da:	85 e4       	ldi	r24, 0x45	; 69
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	25 e4       	ldi	r18, 0x45	; 69
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	f9 01       	movw	r30, r18
    19e4:	20 81       	ld	r18, Z
    19e6:	20 62       	ori	r18, 0x20	; 32
    19e8:	fc 01       	movw	r30, r24
    19ea:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);
    19ec:	81 e3       	ldi	r24, 0x31	; 49
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	21 e3       	ldi	r18, 0x31	; 49
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	f9 01       	movw	r30, r18
    19f6:	20 81       	ld	r18, Z
    19f8:	20 68       	ori	r18, 0x80	; 128
    19fa:	fc 01       	movw	r30, r24
    19fc:	20 83       	st	Z, r18
    19fe:	1b c0       	rjmp	.+54     	; 0x1a36 <TIMER_init+0x752>
				} else if (!strcmp(config->pwmMode, "non-inverting")) {
    1a00:	89 81       	ldd	r24, Y+1	; 0x01
    1a02:	9a 81       	ldd	r25, Y+2	; 0x02
    1a04:	8b 96       	adiw	r24, 0x2b	; 43
    1a06:	63 ea       	ldi	r22, 0xA3	; 163
    1a08:	70 e0       	ldi	r23, 0x00	; 0
    1a0a:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1a0e:	89 2b       	or	r24, r25
    1a10:	91 f4       	brne	.+36     	; 0x1a36 <TIMER_init+0x752>
					/* COM20=0 and COM21=1 */
					TCCR2 |= (1 << COM21);
    1a12:	85 e4       	ldi	r24, 0x45	; 69
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	25 e4       	ldi	r18, 0x45	; 69
    1a18:	30 e0       	ldi	r19, 0x00	; 0
    1a1a:	f9 01       	movw	r30, r18
    1a1c:	20 81       	ld	r18, Z
    1a1e:	20 62       	ori	r18, 0x20	; 32
    1a20:	fc 01       	movw	r30, r24
    1a22:	20 83       	st	Z, r18
					SET_BIT(DDRD, 7);/*make OCO AS OUTPUT BIT */
    1a24:	81 e3       	ldi	r24, 0x31	; 49
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	21 e3       	ldi	r18, 0x31	; 49
    1a2a:	30 e0       	ldi	r19, 0x00	; 0
    1a2c:	f9 01       	movw	r30, r18
    1a2e:	20 81       	ld	r18, Z
    1a30:	20 68       	ori	r18, 0x80	; 128
    1a32:	fc 01       	movw	r30, r24
    1a34:	20 83       	st	Z, r18

			}

		}
		/* global interrupt enable */
		sei();
    1a36:	78 94       	sei
	}
    1a38:	00 00       	nop
    1a3a:	0f 90       	pop	r0
    1a3c:	0f 90       	pop	r0
    1a3e:	df 91       	pop	r29
    1a40:	cf 91       	pop	r28
    1a42:	08 95       	ret

00001a44 <TIMER_setCompare>:
 * 			 setting functions definition 			*
 * *******************************************************
 */

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
    1a44:	cf 93       	push	r28
    1a46:	df 93       	push	r29
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <TIMER_setCompare+0x6>
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	9a 83       	std	Y+2, r25	; 0x02
    1a50:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1a52:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1a56:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	80 81       	ld	r24, Z
    1a5e:	88 2f       	mov	r24, r24
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	81 30       	cpi	r24, 0x01	; 1
    1a64:	91 05       	cpc	r25, r1
    1a66:	81 f0       	breq	.+32     	; 0x1a88 <TIMER_setCompare+0x44>
    1a68:	82 30       	cpi	r24, 0x02	; 2
    1a6a:	91 05       	cpc	r25, r1
    1a6c:	d1 f0       	breq	.+52     	; 0x1aa2 <TIMER_setCompare+0x5e>
    1a6e:	89 2b       	or	r24, r25
    1a70:	09 f0       	breq	.+2      	; 0x1a74 <TIMER_setCompare+0x30>
	case 2:
		TCNT2 = 0;
		OCR2 = compareValue;
		break;
	}
}
    1a72:	21 c0       	rjmp	.+66     	; 0x1ab6 <TIMER_setCompare+0x72>

/* function to set compare value for compare mode */
void TIMER_setCompare(uint16 compareValue) {
	switch (configPtr->timerNumber) {
	case 0:/* timer number*/
		TCNT0 = 0;/* initial value */
    1a74:	82 e5       	ldi	r24, 0x52	; 82
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	fc 01       	movw	r30, r24
    1a7a:	10 82       	st	Z, r1
		OCR0 = compareValue; /*compare value */
    1a7c:	8c e5       	ldi	r24, 0x5C	; 92
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	29 81       	ldd	r18, Y+1	; 0x01
    1a82:	fc 01       	movw	r30, r24
    1a84:	20 83       	st	Z, r18
		break;
    1a86:	17 c0       	rjmp	.+46     	; 0x1ab6 <TIMER_setCompare+0x72>
	case 1:
		TCNT1 = 0;
    1a88:	8c e4       	ldi	r24, 0x4C	; 76
    1a8a:	90 e0       	ldi	r25, 0x00	; 0
    1a8c:	fc 01       	movw	r30, r24
    1a8e:	11 82       	std	Z+1, r1	; 0x01
    1a90:	10 82       	st	Z, r1
		OCR1A = compareValue;
    1a92:	8a e4       	ldi	r24, 0x4A	; 74
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	29 81       	ldd	r18, Y+1	; 0x01
    1a98:	3a 81       	ldd	r19, Y+2	; 0x02
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	31 83       	std	Z+1, r19	; 0x01
    1a9e:	20 83       	st	Z, r18
		break;
    1aa0:	0a c0       	rjmp	.+20     	; 0x1ab6 <TIMER_setCompare+0x72>
	case 2:
		TCNT2 = 0;
    1aa2:	84 e4       	ldi	r24, 0x44	; 68
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	10 82       	st	Z, r1
		OCR2 = compareValue;
    1aaa:	83 e4       	ldi	r24, 0x43	; 67
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	29 81       	ldd	r18, Y+1	; 0x01
    1ab0:	fc 01       	movw	r30, r24
    1ab2:	20 83       	st	Z, r18
		break;
    1ab4:	00 00       	nop
	}
}
    1ab6:	00 00       	nop
    1ab8:	0f 90       	pop	r0
    1aba:	0f 90       	pop	r0
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	08 95       	ret

00001ac2 <TIMER_setNormal>:
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	1f 92       	push	r1
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1ace:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1ad2:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	80 81       	ld	r24, Z
    1ada:	88 2f       	mov	r24, r24
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	81 30       	cpi	r24, 0x01	; 1
    1ae0:	91 05       	cpc	r25, r1
    1ae2:	61 f0       	breq	.+24     	; 0x1afc <TIMER_setNormal+0x3a>
    1ae4:	82 30       	cpi	r24, 0x02	; 2
    1ae6:	91 05       	cpc	r25, r1
    1ae8:	91 f0       	breq	.+36     	; 0x1b0e <TIMER_setNormal+0x4c>
    1aea:	89 2b       	or	r24, r25
    1aec:	09 f0       	breq	.+2      	; 0x1af0 <TIMER_setNormal+0x2e>
		TCNT2 = initValue;
		break;

	}
	/* function to set duty cycle value in PWM mode */
}
    1aee:	15 c0       	rjmp	.+42     	; 0x1b1a <TIMER_setNormal+0x58>
/* function to set initial value in normal mode */
void TIMER_setNormal(uint8 initValue)
{
	switch (configPtr->timerNumber) {
	case 0:
		TCNT0 = initValue;
    1af0:	82 e5       	ldi	r24, 0x52	; 82
    1af2:	90 e0       	ldi	r25, 0x00	; 0
    1af4:	29 81       	ldd	r18, Y+1	; 0x01
    1af6:	fc 01       	movw	r30, r24
    1af8:	20 83       	st	Z, r18
		break;
    1afa:	0f c0       	rjmp	.+30     	; 0x1b1a <TIMER_setNormal+0x58>
	case 1:
		TCNT1 = initValue;
    1afc:	8c e4       	ldi	r24, 0x4C	; 76
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	29 81       	ldd	r18, Y+1	; 0x01
    1b02:	22 2f       	mov	r18, r18
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	fc 01       	movw	r30, r24
    1b08:	31 83       	std	Z+1, r19	; 0x01
    1b0a:	20 83       	st	Z, r18
		break;
    1b0c:	06 c0       	rjmp	.+12     	; 0x1b1a <TIMER_setNormal+0x58>
	case 2:
		TCNT2 = initValue;
    1b0e:	84 e4       	ldi	r24, 0x44	; 68
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	29 81       	ldd	r18, Y+1	; 0x01
    1b14:	fc 01       	movw	r30, r24
    1b16:	20 83       	st	Z, r18
		break;
    1b18:	00 00       	nop

	}
	/* function to set duty cycle value in PWM mode */
}
    1b1a:	00 00       	nop
    1b1c:	0f 90       	pop	r0
    1b1e:	df 91       	pop	r29
    1b20:	cf 91       	pop	r28
    1b22:	08 95       	ret

00001b24 <TIMER_setpwm>:
void TIMER_setpwm(uint8 dutyCycle) {
    1b24:	cf 93       	push	r28
    1b26:	df 93       	push	r29
    1b28:	1f 92       	push	r1
    1b2a:	cd b7       	in	r28, 0x3d	; 61
    1b2c:	de b7       	in	r29, 0x3e	; 62
    1b2e:	89 83       	std	Y+1, r24	; 0x01
	switch (configPtr->timerNumber) {
    1b30:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1b34:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1b38:	fc 01       	movw	r30, r24
    1b3a:	80 81       	ld	r24, Z
    1b3c:	88 2f       	mov	r24, r24
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	81 30       	cpi	r24, 0x01	; 1
    1b42:	91 05       	cpc	r25, r1
    1b44:	81 f0       	breq	.+32     	; 0x1b66 <TIMER_setpwm+0x42>
    1b46:	82 30       	cpi	r24, 0x02	; 2
    1b48:	91 05       	cpc	r25, r1
    1b4a:	d9 f0       	breq	.+54     	; 0x1b82 <TIMER_setpwm+0x5e>
    1b4c:	89 2b       	or	r24, r25
    1b4e:	09 f0       	breq	.+2      	; 0x1b52 <TIMER_setpwm+0x2e>
	case 2:
		TCNT2 = 0;
		OCR2 = dutyCycle;
		break;
	}
}
    1b50:	22 c0       	rjmp	.+68     	; 0x1b96 <TIMER_setpwm+0x72>
}
void TIMER_setpwm(uint8 dutyCycle) {
	switch (configPtr->timerNumber) {

	case 0:
		TCNT0 = 0;
    1b52:	82 e5       	ldi	r24, 0x52	; 82
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	fc 01       	movw	r30, r24
    1b58:	10 82       	st	Z, r1
		OCR0 = dutyCycle;
    1b5a:	8c e5       	ldi	r24, 0x5C	; 92
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	29 81       	ldd	r18, Y+1	; 0x01
    1b60:	fc 01       	movw	r30, r24
    1b62:	20 83       	st	Z, r18
		break;
    1b64:	18 c0       	rjmp	.+48     	; 0x1b96 <TIMER_setpwm+0x72>
	case 1:
		TCNT1 = 0;
    1b66:	8c e4       	ldi	r24, 0x4C	; 76
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	11 82       	std	Z+1, r1	; 0x01
    1b6e:	10 82       	st	Z, r1
		OCR1A = dutyCycle;
    1b70:	8a e4       	ldi	r24, 0x4A	; 74
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	29 81       	ldd	r18, Y+1	; 0x01
    1b76:	22 2f       	mov	r18, r18
    1b78:	30 e0       	ldi	r19, 0x00	; 0
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	31 83       	std	Z+1, r19	; 0x01
    1b7e:	20 83       	st	Z, r18
		break;
    1b80:	0a c0       	rjmp	.+20     	; 0x1b96 <TIMER_setpwm+0x72>
	case 2:
		TCNT2 = 0;
    1b82:	84 e4       	ldi	r24, 0x44	; 68
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	fc 01       	movw	r30, r24
    1b88:	10 82       	st	Z, r1
		OCR2 = dutyCycle;
    1b8a:	83 e4       	ldi	r24, 0x43	; 67
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	29 81       	ldd	r18, Y+1	; 0x01
    1b90:	fc 01       	movw	r30, r24
    1b92:	20 83       	st	Z, r18
		break;
    1b94:	00 00       	nop
	}
}
    1b96:	00 00       	nop
    1b98:	0f 90       	pop	r0
    1b9a:	df 91       	pop	r29
    1b9c:	cf 91       	pop	r28
    1b9e:	08 95       	ret

00001ba0 <TIMER_setCallBackPtr>:
/* function to get adress of call back funtion to passing it for ISR */
void TIMER_setCallBackPtr(void (*a_ptr)(void)) {
    1ba0:	cf 93       	push	r28
    1ba2:	df 93       	push	r29
    1ba4:	00 d0       	rcall	.+0      	; 0x1ba6 <TIMER_setCallBackPtr+0x6>
    1ba6:	cd b7       	in	r28, 0x3d	; 61
    1ba8:	de b7       	in	r29, 0x3e	; 62
    1baa:	9a 83       	std	Y+2, r25	; 0x02
    1bac:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr; /*g_callBackPtr is shared global variable */
    1bae:	89 81       	ldd	r24, Y+1	; 0x01
    1bb0:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb2:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <g_callBackPtr+0x1>
    1bb6:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <g_callBackPtr>
}
    1bba:	00 00       	nop
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	df 91       	pop	r29
    1bc2:	cf 91       	pop	r28
    1bc4:	08 95       	ret

00001bc6 <TIMER_stop>:
/* function to stop the running timer */
void TIMER_stop() {
    1bc6:	cf 93       	push	r28
    1bc8:	df 93       	push	r29
    1bca:	cd b7       	in	r28, 0x3d	; 61
    1bcc:	de b7       	in	r29, 0x3e	; 62
	switch (configPtr->timerNumber)
    1bce:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <configPtr>
    1bd2:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <configPtr+0x1>
    1bd6:	fc 01       	movw	r30, r24
    1bd8:	80 81       	ld	r24, Z
    1bda:	88 2f       	mov	r24, r24
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	81 30       	cpi	r24, 0x01	; 1
    1be0:	91 05       	cpc	r25, r1
    1be2:	81 f0       	breq	.+32     	; 0x1c04 <TIMER_stop+0x3e>
    1be4:	82 30       	cpi	r24, 0x02	; 2
    1be6:	91 05       	cpc	r25, r1
    1be8:	b9 f0       	breq	.+46     	; 0x1c18 <TIMER_stop+0x52>
    1bea:	89 2b       	or	r24, r25
    1bec:	09 f0       	breq	.+2      	; 0x1bf0 <TIMER_stop+0x2a>
		break;
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
		break;
	}
}
    1bee:	1e c0       	rjmp	.+60     	; 0x1c2c <TIMER_stop+0x66>
void TIMER_stop() {
	switch (configPtr->timerNumber)

	{
	case 0:
		TCCR0 &= ~(1 << CS00) & ~(1 << CS01) & ~(1 << CS02);
    1bf0:	83 e5       	ldi	r24, 0x53	; 83
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	23 e5       	ldi	r18, 0x53	; 83
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	f9 01       	movw	r30, r18
    1bfa:	20 81       	ld	r18, Z
    1bfc:	28 7f       	andi	r18, 0xF8	; 248
    1bfe:	fc 01       	movw	r30, r24
    1c00:	20 83       	st	Z, r18
		break;
    1c02:	14 c0       	rjmp	.+40     	; 0x1c2c <TIMER_stop+0x66>
	case 1:
		TCCR1B &= ~(1 << CS10) & ~(1 << CS11) & ~(1 << CS12);
    1c04:	8e e4       	ldi	r24, 0x4E	; 78
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	2e e4       	ldi	r18, 0x4E	; 78
    1c0a:	30 e0       	ldi	r19, 0x00	; 0
    1c0c:	f9 01       	movw	r30, r18
    1c0e:	20 81       	ld	r18, Z
    1c10:	28 7f       	andi	r18, 0xF8	; 248
    1c12:	fc 01       	movw	r30, r24
    1c14:	20 83       	st	Z, r18
		break;
    1c16:	0a c0       	rjmp	.+20     	; 0x1c2c <TIMER_stop+0x66>
	case 2:
		TCCR2 &= ~(1 << CS20) & ~(1 << CS21) & ~(1 << CS22);
    1c18:	85 e4       	ldi	r24, 0x45	; 69
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	25 e4       	ldi	r18, 0x45	; 69
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	f9 01       	movw	r30, r18
    1c22:	20 81       	ld	r18, Z
    1c24:	28 7f       	andi	r18, 0xF8	; 248
    1c26:	fc 01       	movw	r30, r24
    1c28:	20 83       	st	Z, r18
		break;
    1c2a:	00 00       	nop
	}
}
    1c2c:	00 00       	nop
    1c2e:	df 91       	pop	r29
    1c30:	cf 91       	pop	r28
    1c32:	08 95       	ret

00001c34 <UART_init>:
 */

/* configurate by passing UART  configuration structure */

void UART_init(UART_configurationType * config)
{/* put zeros into all bits in the registers */
    1c34:	0f 93       	push	r16
    1c36:	1f 93       	push	r17
    1c38:	cf 93       	push	r28
    1c3a:	df 93       	push	r29
    1c3c:	00 d0       	rcall	.+0      	; 0x1c3e <UART_init+0xa>
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	9a 83       	std	Y+2, r25	; 0x02
    1c44:	89 83       	std	Y+1, r24	; 0x01
UCSRA=0;
    1c46:	8b e2       	ldi	r24, 0x2B	; 43
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	fc 01       	movw	r30, r24
    1c4c:	10 82       	st	Z, r1
UCSRB=0;
    1c4e:	8a e2       	ldi	r24, 0x2A	; 42
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	fc 01       	movw	r30, r24
    1c54:	10 82       	st	Z, r1
UCSRC=0;
    1c56:	80 e4       	ldi	r24, 0x40	; 64
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	10 82       	st	Z, r1
/* enables */
	if(!strcmp(config->mode,"normal"))
    1c5e:	89 81       	ldd	r24, Y+1	; 0x01
    1c60:	9a 81       	ldd	r25, Y+2	; 0x02
    1c62:	05 96       	adiw	r24, 0x05	; 5
    1c64:	61 eb       	ldi	r22, 0xB1	; 177
    1c66:	70 e0       	ldi	r23, 0x00	; 0
    1c68:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1c6c:	89 2b       	or	r24, r25
    1c6e:	09 f0       	breq	.+2      	; 0x1c72 <UART_init+0x3e>
    1c70:	60 c0       	rjmp	.+192    	; 0x1d32 <UART_init+0xfe>
	{
CLEAR_BIT(UCSRA,U2X); /* disable double speed bit */
    1c72:	8b e2       	ldi	r24, 0x2B	; 43
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	2b e2       	ldi	r18, 0x2B	; 43
    1c78:	30 e0       	ldi	r19, 0x00	; 0
    1c7a:	f9 01       	movw	r30, r18
    1c7c:	20 81       	ld	r18, Z
    1c7e:	2d 7f       	andi	r18, 0xFD	; 253
    1c80:	fc 01       	movw	r30, r24
    1c82:	20 83       	st	Z, r18
/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
UBRRL=((F_CPU /(16*config->buadRate))-1);
    1c84:	09 e2       	ldi	r16, 0x29	; 41
    1c86:	10 e0       	ldi	r17, 0x00	; 0
    1c88:	89 81       	ldd	r24, Y+1	; 0x01
    1c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c8c:	fc 01       	movw	r30, r24
    1c8e:	81 81       	ldd	r24, Z+1	; 0x01
    1c90:	92 81       	ldd	r25, Z+2	; 0x02
    1c92:	a3 81       	ldd	r26, Z+3	; 0x03
    1c94:	b4 81       	ldd	r27, Z+4	; 0x04
    1c96:	88 0f       	add	r24, r24
    1c98:	99 1f       	adc	r25, r25
    1c9a:	aa 1f       	adc	r26, r26
    1c9c:	bb 1f       	adc	r27, r27
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	aa 1f       	adc	r26, r26
    1ca4:	bb 1f       	adc	r27, r27
    1ca6:	88 0f       	add	r24, r24
    1ca8:	99 1f       	adc	r25, r25
    1caa:	aa 1f       	adc	r26, r26
    1cac:	bb 1f       	adc	r27, r27
    1cae:	88 0f       	add	r24, r24
    1cb0:	99 1f       	adc	r25, r25
    1cb2:	aa 1f       	adc	r26, r26
    1cb4:	bb 1f       	adc	r27, r27
    1cb6:	9c 01       	movw	r18, r24
    1cb8:	ad 01       	movw	r20, r26
    1cba:	80 e0       	ldi	r24, 0x00	; 0
    1cbc:	92 e1       	ldi	r25, 0x12	; 18
    1cbe:	aa e7       	ldi	r26, 0x7A	; 122
    1cc0:	b0 e0       	ldi	r27, 0x00	; 0
    1cc2:	bc 01       	movw	r22, r24
    1cc4:	cd 01       	movw	r24, r26
    1cc6:	0e 94 40 10 	call	0x2080	; 0x2080 <__udivmodsi4>
    1cca:	da 01       	movw	r26, r20
    1ccc:	c9 01       	movw	r24, r18
    1cce:	81 50       	subi	r24, 0x01	; 1
    1cd0:	f8 01       	movw	r30, r16
    1cd2:	80 83       	st	Z, r24
UBRRH=((F_CPU /(16*config->buadRate))-1)>>8;
    1cd4:	00 e4       	ldi	r16, 0x40	; 64
    1cd6:	10 e0       	ldi	r17, 0x00	; 0
    1cd8:	89 81       	ldd	r24, Y+1	; 0x01
    1cda:	9a 81       	ldd	r25, Y+2	; 0x02
    1cdc:	fc 01       	movw	r30, r24
    1cde:	81 81       	ldd	r24, Z+1	; 0x01
    1ce0:	92 81       	ldd	r25, Z+2	; 0x02
    1ce2:	a3 81       	ldd	r26, Z+3	; 0x03
    1ce4:	b4 81       	ldd	r27, Z+4	; 0x04
    1ce6:	88 0f       	add	r24, r24
    1ce8:	99 1f       	adc	r25, r25
    1cea:	aa 1f       	adc	r26, r26
    1cec:	bb 1f       	adc	r27, r27
    1cee:	88 0f       	add	r24, r24
    1cf0:	99 1f       	adc	r25, r25
    1cf2:	aa 1f       	adc	r26, r26
    1cf4:	bb 1f       	adc	r27, r27
    1cf6:	88 0f       	add	r24, r24
    1cf8:	99 1f       	adc	r25, r25
    1cfa:	aa 1f       	adc	r26, r26
    1cfc:	bb 1f       	adc	r27, r27
    1cfe:	88 0f       	add	r24, r24
    1d00:	99 1f       	adc	r25, r25
    1d02:	aa 1f       	adc	r26, r26
    1d04:	bb 1f       	adc	r27, r27
    1d06:	9c 01       	movw	r18, r24
    1d08:	ad 01       	movw	r20, r26
    1d0a:	80 e0       	ldi	r24, 0x00	; 0
    1d0c:	92 e1       	ldi	r25, 0x12	; 18
    1d0e:	aa e7       	ldi	r26, 0x7A	; 122
    1d10:	b0 e0       	ldi	r27, 0x00	; 0
    1d12:	bc 01       	movw	r22, r24
    1d14:	cd 01       	movw	r24, r26
    1d16:	0e 94 40 10 	call	0x2080	; 0x2080 <__udivmodsi4>
    1d1a:	da 01       	movw	r26, r20
    1d1c:	c9 01       	movw	r24, r18
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	a1 09       	sbc	r26, r1
    1d22:	b1 09       	sbc	r27, r1
    1d24:	89 2f       	mov	r24, r25
    1d26:	9a 2f       	mov	r25, r26
    1d28:	ab 2f       	mov	r26, r27
    1d2a:	bb 27       	eor	r27, r27
    1d2c:	f8 01       	movw	r30, r16
    1d2e:	80 83       	st	Z, r24
    1d30:	61 c0       	rjmp	.+194    	; 0x1df4 <UART_init+0x1c0>


	}
	else if(!strcmp(config->mode,"double speed"))
    1d32:	89 81       	ldd	r24, Y+1	; 0x01
    1d34:	9a 81       	ldd	r25, Y+2	; 0x02
    1d36:	05 96       	adiw	r24, 0x05	; 5
    1d38:	68 eb       	ldi	r22, 0xB8	; 184
    1d3a:	70 e0       	ldi	r23, 0x00	; 0
    1d3c:	0e 94 1e 14 	call	0x283c	; 0x283c <strcmp>
    1d40:	89 2b       	or	r24, r25
    1d42:	09 f0       	breq	.+2      	; 0x1d46 <UART_init+0x112>
    1d44:	57 c0       	rjmp	.+174    	; 0x1df4 <UART_init+0x1c0>
	{
		SET_BIT(UCSRA,U2X);/* enable double speed bit */
    1d46:	8b e2       	ldi	r24, 0x2B	; 43
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	2b e2       	ldi	r18, 0x2B	; 43
    1d4c:	30 e0       	ldi	r19, 0x00	; 0
    1d4e:	f9 01       	movw	r30, r18
    1d50:	20 81       	ld	r18, Z
    1d52:	22 60       	ori	r18, 0x02	; 2
    1d54:	fc 01       	movw	r30, r24
    1d56:	20 83       	st	Z, r18
		/* store buad rate in register UBRR(16bits) ---> left register 8 bits and right 8bits */
		UBRRL=((F_CPU /(8*config->buadRate))-1);
    1d58:	09 e2       	ldi	r16, 0x29	; 41
    1d5a:	10 e0       	ldi	r17, 0x00	; 0
    1d5c:	89 81       	ldd	r24, Y+1	; 0x01
    1d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d60:	fc 01       	movw	r30, r24
    1d62:	81 81       	ldd	r24, Z+1	; 0x01
    1d64:	92 81       	ldd	r25, Z+2	; 0x02
    1d66:	a3 81       	ldd	r26, Z+3	; 0x03
    1d68:	b4 81       	ldd	r27, Z+4	; 0x04
    1d6a:	88 0f       	add	r24, r24
    1d6c:	99 1f       	adc	r25, r25
    1d6e:	aa 1f       	adc	r26, r26
    1d70:	bb 1f       	adc	r27, r27
    1d72:	88 0f       	add	r24, r24
    1d74:	99 1f       	adc	r25, r25
    1d76:	aa 1f       	adc	r26, r26
    1d78:	bb 1f       	adc	r27, r27
    1d7a:	88 0f       	add	r24, r24
    1d7c:	99 1f       	adc	r25, r25
    1d7e:	aa 1f       	adc	r26, r26
    1d80:	bb 1f       	adc	r27, r27
    1d82:	9c 01       	movw	r18, r24
    1d84:	ad 01       	movw	r20, r26
    1d86:	80 e0       	ldi	r24, 0x00	; 0
    1d88:	92 e1       	ldi	r25, 0x12	; 18
    1d8a:	aa e7       	ldi	r26, 0x7A	; 122
    1d8c:	b0 e0       	ldi	r27, 0x00	; 0
    1d8e:	bc 01       	movw	r22, r24
    1d90:	cd 01       	movw	r24, r26
    1d92:	0e 94 40 10 	call	0x2080	; 0x2080 <__udivmodsi4>
    1d96:	da 01       	movw	r26, r20
    1d98:	c9 01       	movw	r24, r18
    1d9a:	81 50       	subi	r24, 0x01	; 1
    1d9c:	f8 01       	movw	r30, r16
    1d9e:	80 83       	st	Z, r24
		UBRRH=((F_CPU /(8*config->buadRate))-1)>>8;
    1da0:	00 e4       	ldi	r16, 0x40	; 64
    1da2:	10 e0       	ldi	r17, 0x00	; 0
    1da4:	89 81       	ldd	r24, Y+1	; 0x01
    1da6:	9a 81       	ldd	r25, Y+2	; 0x02
    1da8:	fc 01       	movw	r30, r24
    1daa:	81 81       	ldd	r24, Z+1	; 0x01
    1dac:	92 81       	ldd	r25, Z+2	; 0x02
    1dae:	a3 81       	ldd	r26, Z+3	; 0x03
    1db0:	b4 81       	ldd	r27, Z+4	; 0x04
    1db2:	88 0f       	add	r24, r24
    1db4:	99 1f       	adc	r25, r25
    1db6:	aa 1f       	adc	r26, r26
    1db8:	bb 1f       	adc	r27, r27
    1dba:	88 0f       	add	r24, r24
    1dbc:	99 1f       	adc	r25, r25
    1dbe:	aa 1f       	adc	r26, r26
    1dc0:	bb 1f       	adc	r27, r27
    1dc2:	88 0f       	add	r24, r24
    1dc4:	99 1f       	adc	r25, r25
    1dc6:	aa 1f       	adc	r26, r26
    1dc8:	bb 1f       	adc	r27, r27
    1dca:	9c 01       	movw	r18, r24
    1dcc:	ad 01       	movw	r20, r26
    1dce:	80 e0       	ldi	r24, 0x00	; 0
    1dd0:	92 e1       	ldi	r25, 0x12	; 18
    1dd2:	aa e7       	ldi	r26, 0x7A	; 122
    1dd4:	b0 e0       	ldi	r27, 0x00	; 0
    1dd6:	bc 01       	movw	r22, r24
    1dd8:	cd 01       	movw	r24, r26
    1dda:	0e 94 40 10 	call	0x2080	; 0x2080 <__udivmodsi4>
    1dde:	da 01       	movw	r26, r20
    1de0:	c9 01       	movw	r24, r18
    1de2:	01 97       	sbiw	r24, 0x01	; 1
    1de4:	a1 09       	sbc	r26, r1
    1de6:	b1 09       	sbc	r27, r1
    1de8:	89 2f       	mov	r24, r25
    1dea:	9a 2f       	mov	r25, r26
    1dec:	ab 2f       	mov	r26, r27
    1dee:	bb 27       	eor	r27, r27
    1df0:	f8 01       	movw	r30, r16
    1df2:	80 83       	st	Z, r24

	}


/* TO enable writing on Register UCSRC (used for define the frame )as it has the same address with UBRR register */
SET_BIT(UCSRC,URSEL);
    1df4:	80 e4       	ldi	r24, 0x40	; 64
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	20 e4       	ldi	r18, 0x40	; 64
    1dfa:	30 e0       	ldi	r19, 0x00	; 0
    1dfc:	f9 01       	movw	r30, r18
    1dfe:	20 81       	ld	r18, Z
    1e00:	20 68       	ori	r18, 0x80	; 128
    1e02:	fc 01       	movw	r30, r24
    1e04:	20 83       	st	Z, r18
/* the UART frame parameters*/
/* character size */

switch(config->character_size)
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
    1e08:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	80 81       	ld	r24, Z
    1e0e:	88 2f       	mov	r24, r24
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	86 30       	cpi	r24, 0x06	; 6
    1e14:	91 05       	cpc	r25, r1
    1e16:	f9 f0       	breq	.+62     	; 0x1e56 <UART_init+0x222>
    1e18:	87 30       	cpi	r24, 0x07	; 7
    1e1a:	91 05       	cpc	r25, r1
    1e1c:	1c f4       	brge	.+6      	; 0x1e24 <UART_init+0x1f0>
    1e1e:	05 97       	sbiw	r24, 0x05	; 5
    1e20:	39 f0       	breq	.+14     	; 0x1e30 <UART_init+0x1fc>
    1e22:	5b c0       	rjmp	.+182    	; 0x1eda <UART_init+0x2a6>
    1e24:	87 30       	cpi	r24, 0x07	; 7
    1e26:	91 05       	cpc	r25, r1
    1e28:	49 f1       	breq	.+82     	; 0x1e7c <UART_init+0x248>
    1e2a:	09 97       	sbiw	r24, 0x09	; 9
    1e2c:	d1 f1       	breq	.+116    	; 0x1ea2 <UART_init+0x26e>
    1e2e:	55 c0       	rjmp	.+170    	; 0x1eda <UART_init+0x2a6>
{
case 5:
	/* UCSZ0 =0, UCSZ1=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e30:	80 e4       	ldi	r24, 0x40	; 64
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	20 e4       	ldi	r18, 0x40	; 64
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	f9 01       	movw	r30, r18
    1e3a:	20 81       	ld	r18, Z
    1e3c:	2d 7f       	andi	r18, 0xFD	; 253
    1e3e:	fc 01       	movw	r30, r24
    1e40:	20 83       	st	Z, r18
	CLEAR_BIT(UCSRC,UCSZ1);
    1e42:	80 e4       	ldi	r24, 0x40	; 64
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	20 e4       	ldi	r18, 0x40	; 64
    1e48:	30 e0       	ldi	r19, 0x00	; 0
    1e4a:	f9 01       	movw	r30, r18
    1e4c:	20 81       	ld	r18, Z
    1e4e:	2b 7f       	andi	r18, 0xFB	; 251
    1e50:	fc 01       	movw	r30, r24
    1e52:	20 83       	st	Z, r18
	break;
    1e54:	54 c0       	rjmp	.+168    	; 0x1efe <UART_init+0x2ca>

case 6:
	/* UCSZ0 =0, UCSZ1=1,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ0);
    1e56:	80 e4       	ldi	r24, 0x40	; 64
    1e58:	90 e0       	ldi	r25, 0x00	; 0
    1e5a:	20 e4       	ldi	r18, 0x40	; 64
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	f9 01       	movw	r30, r18
    1e60:	20 81       	ld	r18, Z
    1e62:	2d 7f       	andi	r18, 0xFD	; 253
    1e64:	fc 01       	movw	r30, r24
    1e66:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1e68:	80 e4       	ldi	r24, 0x40	; 64
    1e6a:	90 e0       	ldi	r25, 0x00	; 0
    1e6c:	20 e4       	ldi	r18, 0x40	; 64
    1e6e:	30 e0       	ldi	r19, 0x00	; 0
    1e70:	f9 01       	movw	r30, r18
    1e72:	20 81       	ld	r18, Z
    1e74:	24 60       	ori	r18, 0x04	; 4
    1e76:	fc 01       	movw	r30, r24
    1e78:	20 83       	st	Z, r18
	break;
    1e7a:	41 c0       	rjmp	.+130    	; 0x1efe <UART_init+0x2ca>
case 7:
	/* UCSZ0 =1, UCSZ=0,UCSZ2=0 */
	CLEAR_BIT(UCSRC,UCSZ1);
    1e7c:	80 e4       	ldi	r24, 0x40	; 64
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	20 e4       	ldi	r18, 0x40	; 64
    1e82:	30 e0       	ldi	r19, 0x00	; 0
    1e84:	f9 01       	movw	r30, r18
    1e86:	20 81       	ld	r18, Z
    1e88:	2b 7f       	andi	r18, 0xFB	; 251
    1e8a:	fc 01       	movw	r30, r24
    1e8c:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ0);
    1e8e:	80 e4       	ldi	r24, 0x40	; 64
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	20 e4       	ldi	r18, 0x40	; 64
    1e94:	30 e0       	ldi	r19, 0x00	; 0
    1e96:	f9 01       	movw	r30, r18
    1e98:	20 81       	ld	r18, Z
    1e9a:	22 60       	ori	r18, 0x02	; 2
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	20 83       	st	Z, r18
		break;
    1ea0:	2e c0       	rjmp	.+92     	; 0x1efe <UART_init+0x2ca>
case 9:
	/* UCSZ0 =1, UCSZ1=0,UCSZ2=1 */
	SET_BIT(UCSRC,UCSZ0);
    1ea2:	80 e4       	ldi	r24, 0x40	; 64
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	20 e4       	ldi	r18, 0x40	; 64
    1ea8:	30 e0       	ldi	r19, 0x00	; 0
    1eaa:	f9 01       	movw	r30, r18
    1eac:	20 81       	ld	r18, Z
    1eae:	22 60       	ori	r18, 0x02	; 2
    1eb0:	fc 01       	movw	r30, r24
    1eb2:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1eb4:	80 e4       	ldi	r24, 0x40	; 64
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	20 e4       	ldi	r18, 0x40	; 64
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	f9 01       	movw	r30, r18
    1ebe:	20 81       	ld	r18, Z
    1ec0:	24 60       	ori	r18, 0x04	; 4
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ2);
    1ec6:	80 e4       	ldi	r24, 0x40	; 64
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	20 e4       	ldi	r18, 0x40	; 64
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	f9 01       	movw	r30, r18
    1ed0:	20 81       	ld	r18, Z
    1ed2:	24 60       	ori	r18, 0x04	; 4
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	20 83       	st	Z, r18


	break;
    1ed8:	12 c0       	rjmp	.+36     	; 0x1efe <UART_init+0x2ca>

default :
	/* the default will be 8bits */
	/* UCSZ0 =1, UCSZ1=1,UCSZ2=0 */
	SET_BIT(UCSRC,UCSZ0);
    1eda:	80 e4       	ldi	r24, 0x40	; 64
    1edc:	90 e0       	ldi	r25, 0x00	; 0
    1ede:	20 e4       	ldi	r18, 0x40	; 64
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	f9 01       	movw	r30, r18
    1ee4:	20 81       	ld	r18, Z
    1ee6:	22 60       	ori	r18, 0x02	; 2
    1ee8:	fc 01       	movw	r30, r24
    1eea:	20 83       	st	Z, r18
	SET_BIT(UCSRC,UCSZ1);
    1eec:	80 e4       	ldi	r24, 0x40	; 64
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	20 e4       	ldi	r18, 0x40	; 64
    1ef2:	30 e0       	ldi	r19, 0x00	; 0
    1ef4:	f9 01       	movw	r30, r18
    1ef6:	20 81       	ld	r18, Z
    1ef8:	24 60       	ori	r18, 0x04	; 4
    1efa:	fc 01       	movw	r30, r24
    1efc:	20 83       	st	Z, r18
}

/* enable uart receive and transmit */
SET_BIT(UCSRB,RXEN);
    1efe:	8a e2       	ldi	r24, 0x2A	; 42
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	2a e2       	ldi	r18, 0x2A	; 42
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	f9 01       	movw	r30, r18
    1f08:	20 81       	ld	r18, Z
    1f0a:	20 61       	ori	r18, 0x10	; 16
    1f0c:	fc 01       	movw	r30, r24
    1f0e:	20 83       	st	Z, r18
SET_BIT(UCSRB,TXEN);
    1f10:	8a e2       	ldi	r24, 0x2A	; 42
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	2a e2       	ldi	r18, 0x2A	; 42
    1f16:	30 e0       	ldi	r19, 0x00	; 0
    1f18:	f9 01       	movw	r30, r18
    1f1a:	20 81       	ld	r18, Z
    1f1c:	28 60       	ori	r18, 0x08	; 8
    1f1e:	fc 01       	movw	r30, r24
    1f20:	20 83       	st	Z, r18
}
    1f22:	00 00       	nop
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	08 95       	ret

00001f32 <UART_receiveByte>:

uint8 UART_receiveByte(void)
{
    1f32:	cf 93       	push	r28
    1f34:	df 93       	push	r29
    1f36:	cd b7       	in	r28, 0x3d	; 61
    1f38:	de b7       	in	r29, 0x3e	; 62
	while(BIT_IS_CLEAR(UCSRA,RXC)); /* wait until RXC  flag be 1 it means that there is data not read */
    1f3a:	00 00       	nop
    1f3c:	8b e2       	ldi	r24, 0x2B	; 43
    1f3e:	90 e0       	ldi	r25, 0x00	; 0
    1f40:	fc 01       	movw	r30, r24
    1f42:	80 81       	ld	r24, Z
    1f44:	88 23       	and	r24, r24
    1f46:	d4 f7       	brge	.-12     	; 0x1f3c <UART_receiveByte+0xa>

	return UDR;/* read and return RXC flag to zero */
    1f48:	8c e2       	ldi	r24, 0x2C	; 44
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	fc 01       	movw	r30, r24
    1f4e:	80 81       	ld	r24, Z
}
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	08 95       	ret

00001f56 <UART_sendByte>:
void UART_sendByte(const uint8 data)
{
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	1f 92       	push	r1
    1f5c:	cd b7       	in	r28, 0x3d	; 61
    1f5e:	de b7       	in	r29, 0x3e	; 62
    1f60:	89 83       	std	Y+1, r24	; 0x01
	UDR=data; /*store data in shift register UDR from less significant bit */
    1f62:	8c e2       	ldi	r24, 0x2C	; 44
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	29 81       	ldd	r18, Y+1	; 0x01
    1f68:	fc 01       	movw	r30, r24
    1f6a:	20 83       	st	Z, r18
	while(BIT_IS_CLEAR(UCSRA,TXC));/*wait until send data txc =1*/
    1f6c:	00 00       	nop
    1f6e:	8b e2       	ldi	r24, 0x2B	; 43
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	fc 01       	movw	r30, r24
    1f74:	80 81       	ld	r24, Z
    1f76:	88 2f       	mov	r24, r24
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	80 74       	andi	r24, 0x40	; 64
    1f7c:	99 27       	eor	r25, r25
    1f7e:	89 2b       	or	r24, r25
    1f80:	b1 f3       	breq	.-20     	; 0x1f6e <UART_sendByte+0x18>
	SET_BIT(UCSRA,TXC); /*clear the flag as it doesnt clear automatically as no interrupt or ISR*/
    1f82:	8b e2       	ldi	r24, 0x2B	; 43
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	2b e2       	ldi	r18, 0x2B	; 43
    1f88:	30 e0       	ldi	r19, 0x00	; 0
    1f8a:	f9 01       	movw	r30, r18
    1f8c:	20 81       	ld	r18, Z
    1f8e:	20 64       	ori	r18, 0x40	; 64
    1f90:	fc 01       	movw	r30, r24
    1f92:	20 83       	st	Z, r18

}
    1f94:	00 00       	nop
    1f96:	0f 90       	pop	r0
    1f98:	df 91       	pop	r29
    1f9a:	cf 91       	pop	r28
    1f9c:	08 95       	ret

00001f9e <UART_sendString>:
void UART_sendString(uint8 *str)
{
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
    1fa2:	00 d0       	rcall	.+0      	; 0x1fa4 <UART_sendString+0x6>
    1fa4:	1f 92       	push	r1
    1fa6:	cd b7       	in	r28, 0x3d	; 61
    1fa8:	de b7       	in	r29, 0x3e	; 62
    1faa:	9b 83       	std	Y+3, r25	; 0x03
    1fac:	8a 83       	std	Y+2, r24	; 0x02
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
    1fae:	19 82       	std	Y+1, r1	; 0x01
		while(str[i] != '\0')
    1fb0:	0e c0       	rjmp	.+28     	; 0x1fce <UART_sendString+0x30>
		{
			UART_sendByte(str[i]);
    1fb2:	89 81       	ldd	r24, Y+1	; 0x01
    1fb4:	88 2f       	mov	r24, r24
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	2a 81       	ldd	r18, Y+2	; 0x02
    1fba:	3b 81       	ldd	r19, Y+3	; 0x03
    1fbc:	82 0f       	add	r24, r18
    1fbe:	93 1f       	adc	r25, r19
    1fc0:	fc 01       	movw	r30, r24
    1fc2:	80 81       	ld	r24, Z
    1fc4:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>
			i++;
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	8f 5f       	subi	r24, 0xFF	; 255
    1fcc:	89 83       	std	Y+1, r24	; 0x01
	/* send byte by byte until end of string (\0)
	 * and at the end of string send # as defined pattern because we cant send null
	 */

	uint8 i = 0;
		while(str[i] != '\0')
    1fce:	89 81       	ldd	r24, Y+1	; 0x01
    1fd0:	88 2f       	mov	r24, r24
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	2a 81       	ldd	r18, Y+2	; 0x02
    1fd6:	3b 81       	ldd	r19, Y+3	; 0x03
    1fd8:	82 0f       	add	r24, r18
    1fda:	93 1f       	adc	r25, r19
    1fdc:	fc 01       	movw	r30, r24
    1fde:	80 81       	ld	r24, Z
    1fe0:	88 23       	and	r24, r24
    1fe2:	39 f7       	brne	.-50     	; 0x1fb2 <UART_sendString+0x14>
		{
			UART_sendByte(str[i]);
			i++;
		}
	UART_sendByte('#');
    1fe4:	83 e2       	ldi	r24, 0x23	; 35
    1fe6:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <UART_sendByte>

}
    1fea:	00 00       	nop
    1fec:	0f 90       	pop	r0
    1fee:	0f 90       	pop	r0
    1ff0:	0f 90       	pop	r0
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	08 95       	ret

00001ff8 <UART_receiveString>:
void UART_receiveString(uint8 *str)
{ /*
    1ff8:	0f 93       	push	r16
    1ffa:	1f 93       	push	r17
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	00 d0       	rcall	.+0      	; 0x2002 <UART_receiveString+0xa>
    2002:	1f 92       	push	r1
    2004:	cd b7       	in	r28, 0x3d	; 61
    2006:	de b7       	in	r29, 0x3e	; 62
    2008:	9b 83       	std	Y+3, r25	; 0x03
    200a:	8a 83       	std	Y+2, r24	; 0x02
at first receive first byte then check the  pre define pattern # may be empty string ""
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
    200c:	19 82       	std	Y+1, r1	; 0x01
		str[i] = UART_receiveByte();
    200e:	89 81       	ldd	r24, Y+1	; 0x01
    2010:	88 2f       	mov	r24, r24
    2012:	90 e0       	ldi	r25, 0x00	; 0
    2014:	2a 81       	ldd	r18, Y+2	; 0x02
    2016:	3b 81       	ldd	r19, Y+3	; 0x03
    2018:	89 01       	movw	r16, r18
    201a:	08 0f       	add	r16, r24
    201c:	19 1f       	adc	r17, r25
    201e:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <UART_receiveByte>
    2022:	f8 01       	movw	r30, r16
    2024:	80 83       	st	Z, r24
		while(str[i] != '#')
    2026:	0f c0       	rjmp	.+30     	; 0x2046 <UART_receiveString+0x4e>
		{
			i++;
    2028:	89 81       	ldd	r24, Y+1	; 0x01
    202a:	8f 5f       	subi	r24, 0xFF	; 255
    202c:	89 83       	std	Y+1, r24	; 0x01
			str[i] = UART_receiveByte();
    202e:	89 81       	ldd	r24, Y+1	; 0x01
    2030:	88 2f       	mov	r24, r24
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	2a 81       	ldd	r18, Y+2	; 0x02
    2036:	3b 81       	ldd	r19, Y+3	; 0x03
    2038:	89 01       	movw	r16, r18
    203a:	08 0f       	add	r16, r24
    203c:	19 1f       	adc	r17, r25
    203e:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <UART_receiveByte>
    2042:	f8 01       	movw	r30, r16
    2044:	80 83       	st	Z, r24
then enter the while loop  and receive byte by byte  until reach pre define pattern #
and replace it with null '\0' to make string */

	uint8 i = 0;
		str[i] = UART_receiveByte();
		while(str[i] != '#')
    2046:	89 81       	ldd	r24, Y+1	; 0x01
    2048:	88 2f       	mov	r24, r24
    204a:	90 e0       	ldi	r25, 0x00	; 0
    204c:	2a 81       	ldd	r18, Y+2	; 0x02
    204e:	3b 81       	ldd	r19, Y+3	; 0x03
    2050:	82 0f       	add	r24, r18
    2052:	93 1f       	adc	r25, r19
    2054:	fc 01       	movw	r30, r24
    2056:	80 81       	ld	r24, Z
    2058:	83 32       	cpi	r24, 0x23	; 35
    205a:	31 f7       	brne	.-52     	; 0x2028 <UART_receiveString+0x30>
		{
			i++;
			str[i] = UART_receiveByte();
		}
		str[i] = '\0';
    205c:	89 81       	ldd	r24, Y+1	; 0x01
    205e:	88 2f       	mov	r24, r24
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	2a 81       	ldd	r18, Y+2	; 0x02
    2064:	3b 81       	ldd	r19, Y+3	; 0x03
    2066:	82 0f       	add	r24, r18
    2068:	93 1f       	adc	r25, r19
    206a:	fc 01       	movw	r30, r24
    206c:	10 82       	st	Z, r1
}
    206e:	00 00       	nop
    2070:	0f 90       	pop	r0
    2072:	0f 90       	pop	r0
    2074:	0f 90       	pop	r0
    2076:	df 91       	pop	r29
    2078:	cf 91       	pop	r28
    207a:	1f 91       	pop	r17
    207c:	0f 91       	pop	r16
    207e:	08 95       	ret

00002080 <__udivmodsi4>:
    2080:	a1 e2       	ldi	r26, 0x21	; 33
    2082:	1a 2e       	mov	r1, r26
    2084:	aa 1b       	sub	r26, r26
    2086:	bb 1b       	sub	r27, r27
    2088:	fd 01       	movw	r30, r26
    208a:	0d c0       	rjmp	.+26     	; 0x20a6 <__udivmodsi4_ep>

0000208c <__udivmodsi4_loop>:
    208c:	aa 1f       	adc	r26, r26
    208e:	bb 1f       	adc	r27, r27
    2090:	ee 1f       	adc	r30, r30
    2092:	ff 1f       	adc	r31, r31
    2094:	a2 17       	cp	r26, r18
    2096:	b3 07       	cpc	r27, r19
    2098:	e4 07       	cpc	r30, r20
    209a:	f5 07       	cpc	r31, r21
    209c:	20 f0       	brcs	.+8      	; 0x20a6 <__udivmodsi4_ep>
    209e:	a2 1b       	sub	r26, r18
    20a0:	b3 0b       	sbc	r27, r19
    20a2:	e4 0b       	sbc	r30, r20
    20a4:	f5 0b       	sbc	r31, r21

000020a6 <__udivmodsi4_ep>:
    20a6:	66 1f       	adc	r22, r22
    20a8:	77 1f       	adc	r23, r23
    20aa:	88 1f       	adc	r24, r24
    20ac:	99 1f       	adc	r25, r25
    20ae:	1a 94       	dec	r1
    20b0:	69 f7       	brne	.-38     	; 0x208c <__udivmodsi4_loop>
    20b2:	60 95       	com	r22
    20b4:	70 95       	com	r23
    20b6:	80 95       	com	r24
    20b8:	90 95       	com	r25
    20ba:	9b 01       	movw	r18, r22
    20bc:	ac 01       	movw	r20, r24
    20be:	bd 01       	movw	r22, r26
    20c0:	cf 01       	movw	r24, r30
    20c2:	08 95       	ret

000020c4 <__subsf3>:
    20c4:	50 58       	subi	r21, 0x80	; 128

000020c6 <__addsf3>:
    20c6:	bb 27       	eor	r27, r27
    20c8:	aa 27       	eor	r26, r26
    20ca:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <__addsf3x>
    20ce:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__fp_round>
    20d2:	0e 94 df 11 	call	0x23be	; 0x23be <__fp_pscA>
    20d6:	38 f0       	brcs	.+14     	; 0x20e6 <__addsf3+0x20>
    20d8:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__fp_pscB>
    20dc:	20 f0       	brcs	.+8      	; 0x20e6 <__addsf3+0x20>
    20de:	39 f4       	brne	.+14     	; 0x20ee <__addsf3+0x28>
    20e0:	9f 3f       	cpi	r25, 0xFF	; 255
    20e2:	19 f4       	brne	.+6      	; 0x20ea <__addsf3+0x24>
    20e4:	26 f4       	brtc	.+8      	; 0x20ee <__addsf3+0x28>
    20e6:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>
    20ea:	0e f4       	brtc	.+2      	; 0x20ee <__addsf3+0x28>
    20ec:	e0 95       	com	r30
    20ee:	e7 fb       	bst	r30, 7
    20f0:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>

000020f4 <__addsf3x>:
    20f4:	e9 2f       	mov	r30, r25
    20f6:	0e 94 fe 11 	call	0x23fc	; 0x23fc <__fp_split3>
    20fa:	58 f3       	brcs	.-42     	; 0x20d2 <__addsf3+0xc>
    20fc:	ba 17       	cp	r27, r26
    20fe:	62 07       	cpc	r22, r18
    2100:	73 07       	cpc	r23, r19
    2102:	84 07       	cpc	r24, r20
    2104:	95 07       	cpc	r25, r21
    2106:	20 f0       	brcs	.+8      	; 0x2110 <__addsf3x+0x1c>
    2108:	79 f4       	brne	.+30     	; 0x2128 <__addsf3x+0x34>
    210a:	a6 f5       	brtc	.+104    	; 0x2174 <__addsf3x+0x80>
    210c:	0c 94 20 12 	jmp	0x2440	; 0x2440 <__fp_zero>
    2110:	0e f4       	brtc	.+2      	; 0x2114 <__addsf3x+0x20>
    2112:	e0 95       	com	r30
    2114:	0b 2e       	mov	r0, r27
    2116:	ba 2f       	mov	r27, r26
    2118:	a0 2d       	mov	r26, r0
    211a:	0b 01       	movw	r0, r22
    211c:	b9 01       	movw	r22, r18
    211e:	90 01       	movw	r18, r0
    2120:	0c 01       	movw	r0, r24
    2122:	ca 01       	movw	r24, r20
    2124:	a0 01       	movw	r20, r0
    2126:	11 24       	eor	r1, r1
    2128:	ff 27       	eor	r31, r31
    212a:	59 1b       	sub	r21, r25
    212c:	99 f0       	breq	.+38     	; 0x2154 <__addsf3x+0x60>
    212e:	59 3f       	cpi	r21, 0xF9	; 249
    2130:	50 f4       	brcc	.+20     	; 0x2146 <__addsf3x+0x52>
    2132:	50 3e       	cpi	r21, 0xE0	; 224
    2134:	68 f1       	brcs	.+90     	; 0x2190 <__addsf3x+0x9c>
    2136:	1a 16       	cp	r1, r26
    2138:	f0 40       	sbci	r31, 0x00	; 0
    213a:	a2 2f       	mov	r26, r18
    213c:	23 2f       	mov	r18, r19
    213e:	34 2f       	mov	r19, r20
    2140:	44 27       	eor	r20, r20
    2142:	58 5f       	subi	r21, 0xF8	; 248
    2144:	f3 cf       	rjmp	.-26     	; 0x212c <__addsf3x+0x38>
    2146:	46 95       	lsr	r20
    2148:	37 95       	ror	r19
    214a:	27 95       	ror	r18
    214c:	a7 95       	ror	r26
    214e:	f0 40       	sbci	r31, 0x00	; 0
    2150:	53 95       	inc	r21
    2152:	c9 f7       	brne	.-14     	; 0x2146 <__addsf3x+0x52>
    2154:	7e f4       	brtc	.+30     	; 0x2174 <__addsf3x+0x80>
    2156:	1f 16       	cp	r1, r31
    2158:	ba 0b       	sbc	r27, r26
    215a:	62 0b       	sbc	r22, r18
    215c:	73 0b       	sbc	r23, r19
    215e:	84 0b       	sbc	r24, r20
    2160:	ba f0       	brmi	.+46     	; 0x2190 <__addsf3x+0x9c>
    2162:	91 50       	subi	r25, 0x01	; 1
    2164:	a1 f0       	breq	.+40     	; 0x218e <__addsf3x+0x9a>
    2166:	ff 0f       	add	r31, r31
    2168:	bb 1f       	adc	r27, r27
    216a:	66 1f       	adc	r22, r22
    216c:	77 1f       	adc	r23, r23
    216e:	88 1f       	adc	r24, r24
    2170:	c2 f7       	brpl	.-16     	; 0x2162 <__addsf3x+0x6e>
    2172:	0e c0       	rjmp	.+28     	; 0x2190 <__addsf3x+0x9c>
    2174:	ba 0f       	add	r27, r26
    2176:	62 1f       	adc	r22, r18
    2178:	73 1f       	adc	r23, r19
    217a:	84 1f       	adc	r24, r20
    217c:	48 f4       	brcc	.+18     	; 0x2190 <__addsf3x+0x9c>
    217e:	87 95       	ror	r24
    2180:	77 95       	ror	r23
    2182:	67 95       	ror	r22
    2184:	b7 95       	ror	r27
    2186:	f7 95       	ror	r31
    2188:	9e 3f       	cpi	r25, 0xFE	; 254
    218a:	08 f0       	brcs	.+2      	; 0x218e <__addsf3x+0x9a>
    218c:	b0 cf       	rjmp	.-160    	; 0x20ee <__addsf3+0x28>
    218e:	93 95       	inc	r25
    2190:	88 0f       	add	r24, r24
    2192:	08 f0       	brcs	.+2      	; 0x2196 <__addsf3x+0xa2>
    2194:	99 27       	eor	r25, r25
    2196:	ee 0f       	add	r30, r30
    2198:	97 95       	ror	r25
    219a:	87 95       	ror	r24
    219c:	08 95       	ret

0000219e <__cmpsf2>:
    219e:	0e 94 b2 11 	call	0x2364	; 0x2364 <__fp_cmp>
    21a2:	08 f4       	brcc	.+2      	; 0x21a6 <__cmpsf2+0x8>
    21a4:	81 e0       	ldi	r24, 0x01	; 1
    21a6:	08 95       	ret

000021a8 <__divsf3>:
    21a8:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <__divsf3x>
    21ac:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__fp_round>
    21b0:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__fp_pscB>
    21b4:	58 f0       	brcs	.+22     	; 0x21cc <__divsf3+0x24>
    21b6:	0e 94 df 11 	call	0x23be	; 0x23be <__fp_pscA>
    21ba:	40 f0       	brcs	.+16     	; 0x21cc <__divsf3+0x24>
    21bc:	29 f4       	brne	.+10     	; 0x21c8 <__divsf3+0x20>
    21be:	5f 3f       	cpi	r21, 0xFF	; 255
    21c0:	29 f0       	breq	.+10     	; 0x21cc <__divsf3+0x24>
    21c2:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    21c6:	51 11       	cpse	r21, r1
    21c8:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__fp_szero>
    21cc:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>

000021d0 <__divsf3x>:
    21d0:	0e 94 fe 11 	call	0x23fc	; 0x23fc <__fp_split3>
    21d4:	68 f3       	brcs	.-38     	; 0x21b0 <__divsf3+0x8>

000021d6 <__divsf3_pse>:
    21d6:	99 23       	and	r25, r25
    21d8:	b1 f3       	breq	.-20     	; 0x21c6 <__divsf3+0x1e>
    21da:	55 23       	and	r21, r21
    21dc:	91 f3       	breq	.-28     	; 0x21c2 <__divsf3+0x1a>
    21de:	95 1b       	sub	r25, r21
    21e0:	55 0b       	sbc	r21, r21
    21e2:	bb 27       	eor	r27, r27
    21e4:	aa 27       	eor	r26, r26
    21e6:	62 17       	cp	r22, r18
    21e8:	73 07       	cpc	r23, r19
    21ea:	84 07       	cpc	r24, r20
    21ec:	38 f0       	brcs	.+14     	; 0x21fc <__divsf3_pse+0x26>
    21ee:	9f 5f       	subi	r25, 0xFF	; 255
    21f0:	5f 4f       	sbci	r21, 0xFF	; 255
    21f2:	22 0f       	add	r18, r18
    21f4:	33 1f       	adc	r19, r19
    21f6:	44 1f       	adc	r20, r20
    21f8:	aa 1f       	adc	r26, r26
    21fa:	a9 f3       	breq	.-22     	; 0x21e6 <__divsf3_pse+0x10>
    21fc:	35 d0       	rcall	.+106    	; 0x2268 <__divsf3_pse+0x92>
    21fe:	0e 2e       	mov	r0, r30
    2200:	3a f0       	brmi	.+14     	; 0x2210 <__divsf3_pse+0x3a>
    2202:	e0 e8       	ldi	r30, 0x80	; 128
    2204:	32 d0       	rcall	.+100    	; 0x226a <__divsf3_pse+0x94>
    2206:	91 50       	subi	r25, 0x01	; 1
    2208:	50 40       	sbci	r21, 0x00	; 0
    220a:	e6 95       	lsr	r30
    220c:	00 1c       	adc	r0, r0
    220e:	ca f7       	brpl	.-14     	; 0x2202 <__divsf3_pse+0x2c>
    2210:	2b d0       	rcall	.+86     	; 0x2268 <__divsf3_pse+0x92>
    2212:	fe 2f       	mov	r31, r30
    2214:	29 d0       	rcall	.+82     	; 0x2268 <__divsf3_pse+0x92>
    2216:	66 0f       	add	r22, r22
    2218:	77 1f       	adc	r23, r23
    221a:	88 1f       	adc	r24, r24
    221c:	bb 1f       	adc	r27, r27
    221e:	26 17       	cp	r18, r22
    2220:	37 07       	cpc	r19, r23
    2222:	48 07       	cpc	r20, r24
    2224:	ab 07       	cpc	r26, r27
    2226:	b0 e8       	ldi	r27, 0x80	; 128
    2228:	09 f0       	breq	.+2      	; 0x222c <__divsf3_pse+0x56>
    222a:	bb 0b       	sbc	r27, r27
    222c:	80 2d       	mov	r24, r0
    222e:	bf 01       	movw	r22, r30
    2230:	ff 27       	eor	r31, r31
    2232:	93 58       	subi	r25, 0x83	; 131
    2234:	5f 4f       	sbci	r21, 0xFF	; 255
    2236:	3a f0       	brmi	.+14     	; 0x2246 <__divsf3_pse+0x70>
    2238:	9e 3f       	cpi	r25, 0xFE	; 254
    223a:	51 05       	cpc	r21, r1
    223c:	78 f0       	brcs	.+30     	; 0x225c <__divsf3_pse+0x86>
    223e:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    2242:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__fp_szero>
    2246:	5f 3f       	cpi	r21, 0xFF	; 255
    2248:	e4 f3       	brlt	.-8      	; 0x2242 <__divsf3_pse+0x6c>
    224a:	98 3e       	cpi	r25, 0xE8	; 232
    224c:	d4 f3       	brlt	.-12     	; 0x2242 <__divsf3_pse+0x6c>
    224e:	86 95       	lsr	r24
    2250:	77 95       	ror	r23
    2252:	67 95       	ror	r22
    2254:	b7 95       	ror	r27
    2256:	f7 95       	ror	r31
    2258:	9f 5f       	subi	r25, 0xFF	; 255
    225a:	c9 f7       	brne	.-14     	; 0x224e <__divsf3_pse+0x78>
    225c:	88 0f       	add	r24, r24
    225e:	91 1d       	adc	r25, r1
    2260:	96 95       	lsr	r25
    2262:	87 95       	ror	r24
    2264:	97 f9       	bld	r25, 7
    2266:	08 95       	ret
    2268:	e1 e0       	ldi	r30, 0x01	; 1
    226a:	66 0f       	add	r22, r22
    226c:	77 1f       	adc	r23, r23
    226e:	88 1f       	adc	r24, r24
    2270:	bb 1f       	adc	r27, r27
    2272:	62 17       	cp	r22, r18
    2274:	73 07       	cpc	r23, r19
    2276:	84 07       	cpc	r24, r20
    2278:	ba 07       	cpc	r27, r26
    227a:	20 f0       	brcs	.+8      	; 0x2284 <__divsf3_pse+0xae>
    227c:	62 1b       	sub	r22, r18
    227e:	73 0b       	sbc	r23, r19
    2280:	84 0b       	sbc	r24, r20
    2282:	ba 0b       	sbc	r27, r26
    2284:	ee 1f       	adc	r30, r30
    2286:	88 f7       	brcc	.-30     	; 0x226a <__divsf3_pse+0x94>
    2288:	e0 95       	com	r30
    228a:	08 95       	ret

0000228c <__fixunssfsi>:
    228c:	0e 94 06 12 	call	0x240c	; 0x240c <__fp_splitA>
    2290:	88 f0       	brcs	.+34     	; 0x22b4 <__fixunssfsi+0x28>
    2292:	9f 57       	subi	r25, 0x7F	; 127
    2294:	98 f0       	brcs	.+38     	; 0x22bc <__fixunssfsi+0x30>
    2296:	b9 2f       	mov	r27, r25
    2298:	99 27       	eor	r25, r25
    229a:	b7 51       	subi	r27, 0x17	; 23
    229c:	b0 f0       	brcs	.+44     	; 0x22ca <__fixunssfsi+0x3e>
    229e:	e1 f0       	breq	.+56     	; 0x22d8 <__fixunssfsi+0x4c>
    22a0:	66 0f       	add	r22, r22
    22a2:	77 1f       	adc	r23, r23
    22a4:	88 1f       	adc	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	1a f0       	brmi	.+6      	; 0x22b0 <__fixunssfsi+0x24>
    22aa:	ba 95       	dec	r27
    22ac:	c9 f7       	brne	.-14     	; 0x22a0 <__fixunssfsi+0x14>
    22ae:	14 c0       	rjmp	.+40     	; 0x22d8 <__fixunssfsi+0x4c>
    22b0:	b1 30       	cpi	r27, 0x01	; 1
    22b2:	91 f0       	breq	.+36     	; 0x22d8 <__fixunssfsi+0x4c>
    22b4:	0e 94 20 12 	call	0x2440	; 0x2440 <__fp_zero>
    22b8:	b1 e0       	ldi	r27, 0x01	; 1
    22ba:	08 95       	ret
    22bc:	0c 94 20 12 	jmp	0x2440	; 0x2440 <__fp_zero>
    22c0:	67 2f       	mov	r22, r23
    22c2:	78 2f       	mov	r23, r24
    22c4:	88 27       	eor	r24, r24
    22c6:	b8 5f       	subi	r27, 0xF8	; 248
    22c8:	39 f0       	breq	.+14     	; 0x22d8 <__fixunssfsi+0x4c>
    22ca:	b9 3f       	cpi	r27, 0xF9	; 249
    22cc:	cc f3       	brlt	.-14     	; 0x22c0 <__fixunssfsi+0x34>
    22ce:	86 95       	lsr	r24
    22d0:	77 95       	ror	r23
    22d2:	67 95       	ror	r22
    22d4:	b3 95       	inc	r27
    22d6:	d9 f7       	brne	.-10     	; 0x22ce <__fixunssfsi+0x42>
    22d8:	3e f4       	brtc	.+14     	; 0x22e8 <__fixunssfsi+0x5c>
    22da:	90 95       	com	r25
    22dc:	80 95       	com	r24
    22de:	70 95       	com	r23
    22e0:	61 95       	neg	r22
    22e2:	7f 4f       	sbci	r23, 0xFF	; 255
    22e4:	8f 4f       	sbci	r24, 0xFF	; 255
    22e6:	9f 4f       	sbci	r25, 0xFF	; 255
    22e8:	08 95       	ret

000022ea <__floatunsisf>:
    22ea:	e8 94       	clt
    22ec:	09 c0       	rjmp	.+18     	; 0x2300 <__floatsisf+0x12>

000022ee <__floatsisf>:
    22ee:	97 fb       	bst	r25, 7
    22f0:	3e f4       	brtc	.+14     	; 0x2300 <__floatsisf+0x12>
    22f2:	90 95       	com	r25
    22f4:	80 95       	com	r24
    22f6:	70 95       	com	r23
    22f8:	61 95       	neg	r22
    22fa:	7f 4f       	sbci	r23, 0xFF	; 255
    22fc:	8f 4f       	sbci	r24, 0xFF	; 255
    22fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2300:	99 23       	and	r25, r25
    2302:	a9 f0       	breq	.+42     	; 0x232e <__floatsisf+0x40>
    2304:	f9 2f       	mov	r31, r25
    2306:	96 e9       	ldi	r25, 0x96	; 150
    2308:	bb 27       	eor	r27, r27
    230a:	93 95       	inc	r25
    230c:	f6 95       	lsr	r31
    230e:	87 95       	ror	r24
    2310:	77 95       	ror	r23
    2312:	67 95       	ror	r22
    2314:	b7 95       	ror	r27
    2316:	f1 11       	cpse	r31, r1
    2318:	f8 cf       	rjmp	.-16     	; 0x230a <__floatsisf+0x1c>
    231a:	fa f4       	brpl	.+62     	; 0x235a <__floatsisf+0x6c>
    231c:	bb 0f       	add	r27, r27
    231e:	11 f4       	brne	.+4      	; 0x2324 <__floatsisf+0x36>
    2320:	60 ff       	sbrs	r22, 0
    2322:	1b c0       	rjmp	.+54     	; 0x235a <__floatsisf+0x6c>
    2324:	6f 5f       	subi	r22, 0xFF	; 255
    2326:	7f 4f       	sbci	r23, 0xFF	; 255
    2328:	8f 4f       	sbci	r24, 0xFF	; 255
    232a:	9f 4f       	sbci	r25, 0xFF	; 255
    232c:	16 c0       	rjmp	.+44     	; 0x235a <__floatsisf+0x6c>
    232e:	88 23       	and	r24, r24
    2330:	11 f0       	breq	.+4      	; 0x2336 <__floatsisf+0x48>
    2332:	96 e9       	ldi	r25, 0x96	; 150
    2334:	11 c0       	rjmp	.+34     	; 0x2358 <__floatsisf+0x6a>
    2336:	77 23       	and	r23, r23
    2338:	21 f0       	breq	.+8      	; 0x2342 <__floatsisf+0x54>
    233a:	9e e8       	ldi	r25, 0x8E	; 142
    233c:	87 2f       	mov	r24, r23
    233e:	76 2f       	mov	r23, r22
    2340:	05 c0       	rjmp	.+10     	; 0x234c <__floatsisf+0x5e>
    2342:	66 23       	and	r22, r22
    2344:	71 f0       	breq	.+28     	; 0x2362 <__floatsisf+0x74>
    2346:	96 e8       	ldi	r25, 0x86	; 134
    2348:	86 2f       	mov	r24, r22
    234a:	70 e0       	ldi	r23, 0x00	; 0
    234c:	60 e0       	ldi	r22, 0x00	; 0
    234e:	2a f0       	brmi	.+10     	; 0x235a <__floatsisf+0x6c>
    2350:	9a 95       	dec	r25
    2352:	66 0f       	add	r22, r22
    2354:	77 1f       	adc	r23, r23
    2356:	88 1f       	adc	r24, r24
    2358:	da f7       	brpl	.-10     	; 0x2350 <__floatsisf+0x62>
    235a:	88 0f       	add	r24, r24
    235c:	96 95       	lsr	r25
    235e:	87 95       	ror	r24
    2360:	97 f9       	bld	r25, 7
    2362:	08 95       	ret

00002364 <__fp_cmp>:
    2364:	99 0f       	add	r25, r25
    2366:	00 08       	sbc	r0, r0
    2368:	55 0f       	add	r21, r21
    236a:	aa 0b       	sbc	r26, r26
    236c:	e0 e8       	ldi	r30, 0x80	; 128
    236e:	fe ef       	ldi	r31, 0xFE	; 254
    2370:	16 16       	cp	r1, r22
    2372:	17 06       	cpc	r1, r23
    2374:	e8 07       	cpc	r30, r24
    2376:	f9 07       	cpc	r31, r25
    2378:	c0 f0       	brcs	.+48     	; 0x23aa <__fp_cmp+0x46>
    237a:	12 16       	cp	r1, r18
    237c:	13 06       	cpc	r1, r19
    237e:	e4 07       	cpc	r30, r20
    2380:	f5 07       	cpc	r31, r21
    2382:	98 f0       	brcs	.+38     	; 0x23aa <__fp_cmp+0x46>
    2384:	62 1b       	sub	r22, r18
    2386:	73 0b       	sbc	r23, r19
    2388:	84 0b       	sbc	r24, r20
    238a:	95 0b       	sbc	r25, r21
    238c:	39 f4       	brne	.+14     	; 0x239c <__fp_cmp+0x38>
    238e:	0a 26       	eor	r0, r26
    2390:	61 f0       	breq	.+24     	; 0x23aa <__fp_cmp+0x46>
    2392:	23 2b       	or	r18, r19
    2394:	24 2b       	or	r18, r20
    2396:	25 2b       	or	r18, r21
    2398:	21 f4       	brne	.+8      	; 0x23a2 <__fp_cmp+0x3e>
    239a:	08 95       	ret
    239c:	0a 26       	eor	r0, r26
    239e:	09 f4       	brne	.+2      	; 0x23a2 <__fp_cmp+0x3e>
    23a0:	a1 40       	sbci	r26, 0x01	; 1
    23a2:	a6 95       	lsr	r26
    23a4:	8f ef       	ldi	r24, 0xFF	; 255
    23a6:	81 1d       	adc	r24, r1
    23a8:	81 1d       	adc	r24, r1
    23aa:	08 95       	ret

000023ac <__fp_inf>:
    23ac:	97 f9       	bld	r25, 7
    23ae:	9f 67       	ori	r25, 0x7F	; 127
    23b0:	80 e8       	ldi	r24, 0x80	; 128
    23b2:	70 e0       	ldi	r23, 0x00	; 0
    23b4:	60 e0       	ldi	r22, 0x00	; 0
    23b6:	08 95       	ret

000023b8 <__fp_nan>:
    23b8:	9f ef       	ldi	r25, 0xFF	; 255
    23ba:	80 ec       	ldi	r24, 0xC0	; 192
    23bc:	08 95       	ret

000023be <__fp_pscA>:
    23be:	00 24       	eor	r0, r0
    23c0:	0a 94       	dec	r0
    23c2:	16 16       	cp	r1, r22
    23c4:	17 06       	cpc	r1, r23
    23c6:	18 06       	cpc	r1, r24
    23c8:	09 06       	cpc	r0, r25
    23ca:	08 95       	ret

000023cc <__fp_pscB>:
    23cc:	00 24       	eor	r0, r0
    23ce:	0a 94       	dec	r0
    23d0:	12 16       	cp	r1, r18
    23d2:	13 06       	cpc	r1, r19
    23d4:	14 06       	cpc	r1, r20
    23d6:	05 06       	cpc	r0, r21
    23d8:	08 95       	ret

000023da <__fp_round>:
    23da:	09 2e       	mov	r0, r25
    23dc:	03 94       	inc	r0
    23de:	00 0c       	add	r0, r0
    23e0:	11 f4       	brne	.+4      	; 0x23e6 <__fp_round+0xc>
    23e2:	88 23       	and	r24, r24
    23e4:	52 f0       	brmi	.+20     	; 0x23fa <__fp_round+0x20>
    23e6:	bb 0f       	add	r27, r27
    23e8:	40 f4       	brcc	.+16     	; 0x23fa <__fp_round+0x20>
    23ea:	bf 2b       	or	r27, r31
    23ec:	11 f4       	brne	.+4      	; 0x23f2 <__fp_round+0x18>
    23ee:	60 ff       	sbrs	r22, 0
    23f0:	04 c0       	rjmp	.+8      	; 0x23fa <__fp_round+0x20>
    23f2:	6f 5f       	subi	r22, 0xFF	; 255
    23f4:	7f 4f       	sbci	r23, 0xFF	; 255
    23f6:	8f 4f       	sbci	r24, 0xFF	; 255
    23f8:	9f 4f       	sbci	r25, 0xFF	; 255
    23fa:	08 95       	ret

000023fc <__fp_split3>:
    23fc:	57 fd       	sbrc	r21, 7
    23fe:	90 58       	subi	r25, 0x80	; 128
    2400:	44 0f       	add	r20, r20
    2402:	55 1f       	adc	r21, r21
    2404:	59 f0       	breq	.+22     	; 0x241c <__fp_splitA+0x10>
    2406:	5f 3f       	cpi	r21, 0xFF	; 255
    2408:	71 f0       	breq	.+28     	; 0x2426 <__fp_splitA+0x1a>
    240a:	47 95       	ror	r20

0000240c <__fp_splitA>:
    240c:	88 0f       	add	r24, r24
    240e:	97 fb       	bst	r25, 7
    2410:	99 1f       	adc	r25, r25
    2412:	61 f0       	breq	.+24     	; 0x242c <__fp_splitA+0x20>
    2414:	9f 3f       	cpi	r25, 0xFF	; 255
    2416:	79 f0       	breq	.+30     	; 0x2436 <__fp_splitA+0x2a>
    2418:	87 95       	ror	r24
    241a:	08 95       	ret
    241c:	12 16       	cp	r1, r18
    241e:	13 06       	cpc	r1, r19
    2420:	14 06       	cpc	r1, r20
    2422:	55 1f       	adc	r21, r21
    2424:	f2 cf       	rjmp	.-28     	; 0x240a <__fp_split3+0xe>
    2426:	46 95       	lsr	r20
    2428:	f1 df       	rcall	.-30     	; 0x240c <__fp_splitA>
    242a:	08 c0       	rjmp	.+16     	; 0x243c <__fp_splitA+0x30>
    242c:	16 16       	cp	r1, r22
    242e:	17 06       	cpc	r1, r23
    2430:	18 06       	cpc	r1, r24
    2432:	99 1f       	adc	r25, r25
    2434:	f1 cf       	rjmp	.-30     	; 0x2418 <__fp_splitA+0xc>
    2436:	86 95       	lsr	r24
    2438:	71 05       	cpc	r23, r1
    243a:	61 05       	cpc	r22, r1
    243c:	08 94       	sec
    243e:	08 95       	ret

00002440 <__fp_zero>:
    2440:	e8 94       	clt

00002442 <__fp_szero>:
    2442:	bb 27       	eor	r27, r27
    2444:	66 27       	eor	r22, r22
    2446:	77 27       	eor	r23, r23
    2448:	cb 01       	movw	r24, r22
    244a:	97 f9       	bld	r25, 7
    244c:	08 95       	ret

0000244e <__gesf2>:
    244e:	0e 94 b2 11 	call	0x2364	; 0x2364 <__fp_cmp>
    2452:	08 f4       	brcc	.+2      	; 0x2456 <__gesf2+0x8>
    2454:	8f ef       	ldi	r24, 0xFF	; 255
    2456:	08 95       	ret

00002458 <__mulsf3>:
    2458:	0e 94 3f 12 	call	0x247e	; 0x247e <__mulsf3x>
    245c:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__fp_round>
    2460:	0e 94 df 11 	call	0x23be	; 0x23be <__fp_pscA>
    2464:	38 f0       	brcs	.+14     	; 0x2474 <__mulsf3+0x1c>
    2466:	0e 94 e6 11 	call	0x23cc	; 0x23cc <__fp_pscB>
    246a:	20 f0       	brcs	.+8      	; 0x2474 <__mulsf3+0x1c>
    246c:	95 23       	and	r25, r21
    246e:	11 f0       	breq	.+4      	; 0x2474 <__mulsf3+0x1c>
    2470:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    2474:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>
    2478:	11 24       	eor	r1, r1
    247a:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__fp_szero>

0000247e <__mulsf3x>:
    247e:	0e 94 fe 11 	call	0x23fc	; 0x23fc <__fp_split3>
    2482:	70 f3       	brcs	.-36     	; 0x2460 <__mulsf3+0x8>

00002484 <__mulsf3_pse>:
    2484:	95 9f       	mul	r25, r21
    2486:	c1 f3       	breq	.-16     	; 0x2478 <__mulsf3+0x20>
    2488:	95 0f       	add	r25, r21
    248a:	50 e0       	ldi	r21, 0x00	; 0
    248c:	55 1f       	adc	r21, r21
    248e:	62 9f       	mul	r22, r18
    2490:	f0 01       	movw	r30, r0
    2492:	72 9f       	mul	r23, r18
    2494:	bb 27       	eor	r27, r27
    2496:	f0 0d       	add	r31, r0
    2498:	b1 1d       	adc	r27, r1
    249a:	63 9f       	mul	r22, r19
    249c:	aa 27       	eor	r26, r26
    249e:	f0 0d       	add	r31, r0
    24a0:	b1 1d       	adc	r27, r1
    24a2:	aa 1f       	adc	r26, r26
    24a4:	64 9f       	mul	r22, r20
    24a6:	66 27       	eor	r22, r22
    24a8:	b0 0d       	add	r27, r0
    24aa:	a1 1d       	adc	r26, r1
    24ac:	66 1f       	adc	r22, r22
    24ae:	82 9f       	mul	r24, r18
    24b0:	22 27       	eor	r18, r18
    24b2:	b0 0d       	add	r27, r0
    24b4:	a1 1d       	adc	r26, r1
    24b6:	62 1f       	adc	r22, r18
    24b8:	73 9f       	mul	r23, r19
    24ba:	b0 0d       	add	r27, r0
    24bc:	a1 1d       	adc	r26, r1
    24be:	62 1f       	adc	r22, r18
    24c0:	83 9f       	mul	r24, r19
    24c2:	a0 0d       	add	r26, r0
    24c4:	61 1d       	adc	r22, r1
    24c6:	22 1f       	adc	r18, r18
    24c8:	74 9f       	mul	r23, r20
    24ca:	33 27       	eor	r19, r19
    24cc:	a0 0d       	add	r26, r0
    24ce:	61 1d       	adc	r22, r1
    24d0:	23 1f       	adc	r18, r19
    24d2:	84 9f       	mul	r24, r20
    24d4:	60 0d       	add	r22, r0
    24d6:	21 1d       	adc	r18, r1
    24d8:	82 2f       	mov	r24, r18
    24da:	76 2f       	mov	r23, r22
    24dc:	6a 2f       	mov	r22, r26
    24de:	11 24       	eor	r1, r1
    24e0:	9f 57       	subi	r25, 0x7F	; 127
    24e2:	50 40       	sbci	r21, 0x00	; 0
    24e4:	9a f0       	brmi	.+38     	; 0x250c <__mulsf3_pse+0x88>
    24e6:	f1 f0       	breq	.+60     	; 0x2524 <__mulsf3_pse+0xa0>
    24e8:	88 23       	and	r24, r24
    24ea:	4a f0       	brmi	.+18     	; 0x24fe <__mulsf3_pse+0x7a>
    24ec:	ee 0f       	add	r30, r30
    24ee:	ff 1f       	adc	r31, r31
    24f0:	bb 1f       	adc	r27, r27
    24f2:	66 1f       	adc	r22, r22
    24f4:	77 1f       	adc	r23, r23
    24f6:	88 1f       	adc	r24, r24
    24f8:	91 50       	subi	r25, 0x01	; 1
    24fa:	50 40       	sbci	r21, 0x00	; 0
    24fc:	a9 f7       	brne	.-22     	; 0x24e8 <__mulsf3_pse+0x64>
    24fe:	9e 3f       	cpi	r25, 0xFE	; 254
    2500:	51 05       	cpc	r21, r1
    2502:	80 f0       	brcs	.+32     	; 0x2524 <__mulsf3_pse+0xa0>
    2504:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    2508:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__fp_szero>
    250c:	5f 3f       	cpi	r21, 0xFF	; 255
    250e:	e4 f3       	brlt	.-8      	; 0x2508 <__mulsf3_pse+0x84>
    2510:	98 3e       	cpi	r25, 0xE8	; 232
    2512:	d4 f3       	brlt	.-12     	; 0x2508 <__mulsf3_pse+0x84>
    2514:	86 95       	lsr	r24
    2516:	77 95       	ror	r23
    2518:	67 95       	ror	r22
    251a:	b7 95       	ror	r27
    251c:	f7 95       	ror	r31
    251e:	e7 95       	ror	r30
    2520:	9f 5f       	subi	r25, 0xFF	; 255
    2522:	c1 f7       	brne	.-16     	; 0x2514 <__mulsf3_pse+0x90>
    2524:	fe 2b       	or	r31, r30
    2526:	88 0f       	add	r24, r24
    2528:	91 1d       	adc	r25, r1
    252a:	96 95       	lsr	r25
    252c:	87 95       	ror	r24
    252e:	97 f9       	bld	r25, 7
    2530:	08 95       	ret

00002532 <pow>:
    2532:	fa 01       	movw	r30, r20
    2534:	ee 0f       	add	r30, r30
    2536:	ff 1f       	adc	r31, r31
    2538:	30 96       	adiw	r30, 0x00	; 0
    253a:	21 05       	cpc	r18, r1
    253c:	31 05       	cpc	r19, r1
    253e:	a1 f1       	breq	.+104    	; 0x25a8 <pow+0x76>
    2540:	61 15       	cp	r22, r1
    2542:	71 05       	cpc	r23, r1
    2544:	61 f4       	brne	.+24     	; 0x255e <pow+0x2c>
    2546:	80 38       	cpi	r24, 0x80	; 128
    2548:	bf e3       	ldi	r27, 0x3F	; 63
    254a:	9b 07       	cpc	r25, r27
    254c:	49 f1       	breq	.+82     	; 0x25a0 <pow+0x6e>
    254e:	68 94       	set
    2550:	90 38       	cpi	r25, 0x80	; 128
    2552:	81 05       	cpc	r24, r1
    2554:	61 f0       	breq	.+24     	; 0x256e <pow+0x3c>
    2556:	80 38       	cpi	r24, 0x80	; 128
    2558:	bf ef       	ldi	r27, 0xFF	; 255
    255a:	9b 07       	cpc	r25, r27
    255c:	41 f0       	breq	.+16     	; 0x256e <pow+0x3c>
    255e:	99 23       	and	r25, r25
    2560:	4a f5       	brpl	.+82     	; 0x25b4 <pow+0x82>
    2562:	ff 3f       	cpi	r31, 0xFF	; 255
    2564:	e1 05       	cpc	r30, r1
    2566:	31 05       	cpc	r19, r1
    2568:	21 05       	cpc	r18, r1
    256a:	19 f1       	breq	.+70     	; 0x25b2 <pow+0x80>
    256c:	e8 94       	clt
    256e:	08 94       	sec
    2570:	e7 95       	ror	r30
    2572:	d9 01       	movw	r26, r18
    2574:	aa 23       	and	r26, r26
    2576:	29 f4       	brne	.+10     	; 0x2582 <pow+0x50>
    2578:	ab 2f       	mov	r26, r27
    257a:	be 2f       	mov	r27, r30
    257c:	f8 5f       	subi	r31, 0xF8	; 248
    257e:	d0 f3       	brcs	.-12     	; 0x2574 <pow+0x42>
    2580:	10 c0       	rjmp	.+32     	; 0x25a2 <pow+0x70>
    2582:	ff 5f       	subi	r31, 0xFF	; 255
    2584:	70 f4       	brcc	.+28     	; 0x25a2 <pow+0x70>
    2586:	a6 95       	lsr	r26
    2588:	e0 f7       	brcc	.-8      	; 0x2582 <pow+0x50>
    258a:	f7 39       	cpi	r31, 0x97	; 151
    258c:	50 f0       	brcs	.+20     	; 0x25a2 <pow+0x70>
    258e:	19 f0       	breq	.+6      	; 0x2596 <pow+0x64>
    2590:	ff 3a       	cpi	r31, 0xAF	; 175
    2592:	38 f4       	brcc	.+14     	; 0x25a2 <pow+0x70>
    2594:	9f 77       	andi	r25, 0x7F	; 127
    2596:	9f 93       	push	r25
    2598:	0d d0       	rcall	.+26     	; 0x25b4 <pow+0x82>
    259a:	0f 90       	pop	r0
    259c:	07 fc       	sbrc	r0, 7
    259e:	90 58       	subi	r25, 0x80	; 128
    25a0:	08 95       	ret
    25a2:	46 f0       	brts	.+16     	; 0x25b4 <pow+0x82>
    25a4:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>
    25a8:	60 e0       	ldi	r22, 0x00	; 0
    25aa:	70 e0       	ldi	r23, 0x00	; 0
    25ac:	80 e8       	ldi	r24, 0x80	; 128
    25ae:	9f e3       	ldi	r25, 0x3F	; 63
    25b0:	08 95       	ret
    25b2:	4f e7       	ldi	r20, 0x7F	; 127
    25b4:	9f 77       	andi	r25, 0x7F	; 127
    25b6:	5f 93       	push	r21
    25b8:	4f 93       	push	r20
    25ba:	3f 93       	push	r19
    25bc:	2f 93       	push	r18
    25be:	0e 94 94 13 	call	0x2728	; 0x2728 <log>
    25c2:	2f 91       	pop	r18
    25c4:	3f 91       	pop	r19
    25c6:	4f 91       	pop	r20
    25c8:	5f 91       	pop	r21
    25ca:	0e 94 2c 12 	call	0x2458	; 0x2458 <__mulsf3>
    25ce:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <exp>
    25d2:	29 f4       	brne	.+10     	; 0x25de <pow+0xac>
    25d4:	16 f0       	brts	.+4      	; 0x25da <pow+0xa8>
    25d6:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    25da:	0c 94 20 12 	jmp	0x2440	; 0x2440 <__fp_zero>
    25de:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>

000025e2 <exp>:
    25e2:	0e 94 06 12 	call	0x240c	; 0x240c <__fp_splitA>
    25e6:	a8 f3       	brcs	.-22     	; 0x25d2 <pow+0xa0>
    25e8:	96 38       	cpi	r25, 0x86	; 134
    25ea:	a0 f7       	brcc	.-24     	; 0x25d4 <pow+0xa2>
    25ec:	07 f8       	bld	r0, 7
    25ee:	0f 92       	push	r0
    25f0:	e8 94       	clt
    25f2:	2b e3       	ldi	r18, 0x3B	; 59
    25f4:	3a ea       	ldi	r19, 0xAA	; 170
    25f6:	48 eb       	ldi	r20, 0xB8	; 184
    25f8:	5f e7       	ldi	r21, 0x7F	; 127
    25fa:	0e 94 42 12 	call	0x2484	; 0x2484 <__mulsf3_pse>
    25fe:	0f 92       	push	r0
    2600:	0f 92       	push	r0
    2602:	0f 92       	push	r0
    2604:	4d b7       	in	r20, 0x3d	; 61
    2606:	5e b7       	in	r21, 0x3e	; 62
    2608:	0f 92       	push	r0
    260a:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <modf>
    260e:	e4 e5       	ldi	r30, 0x54	; 84
    2610:	f0 e0       	ldi	r31, 0x00	; 0
    2612:	0e 94 23 13 	call	0x2646	; 0x2646 <__fp_powser>
    2616:	4f 91       	pop	r20
    2618:	5f 91       	pop	r21
    261a:	ef 91       	pop	r30
    261c:	ff 91       	pop	r31
    261e:	e5 95       	asr	r30
    2620:	ee 1f       	adc	r30, r30
    2622:	ff 1f       	adc	r31, r31
    2624:	49 f0       	breq	.+18     	; 0x2638 <exp+0x56>
    2626:	fe 57       	subi	r31, 0x7E	; 126
    2628:	e0 68       	ori	r30, 0x80	; 128
    262a:	44 27       	eor	r20, r20
    262c:	ee 0f       	add	r30, r30
    262e:	44 1f       	adc	r20, r20
    2630:	fa 95       	dec	r31
    2632:	e1 f7       	brne	.-8      	; 0x262c <exp+0x4a>
    2634:	41 95       	neg	r20
    2636:	55 0b       	sbc	r21, r21
    2638:	0e 94 56 13 	call	0x26ac	; 0x26ac <ldexp>
    263c:	0f 90       	pop	r0
    263e:	07 fe       	sbrs	r0, 7
    2640:	0c 94 4a 13 	jmp	0x2694	; 0x2694 <inverse>
    2644:	08 95       	ret

00002646 <__fp_powser>:
    2646:	df 93       	push	r29
    2648:	cf 93       	push	r28
    264a:	1f 93       	push	r17
    264c:	0f 93       	push	r16
    264e:	ff 92       	push	r15
    2650:	ef 92       	push	r14
    2652:	df 92       	push	r13
    2654:	7b 01       	movw	r14, r22
    2656:	8c 01       	movw	r16, r24
    2658:	68 94       	set
    265a:	06 c0       	rjmp	.+12     	; 0x2668 <__fp_powser+0x22>
    265c:	da 2e       	mov	r13, r26
    265e:	ef 01       	movw	r28, r30
    2660:	0e 94 3f 12 	call	0x247e	; 0x247e <__mulsf3x>
    2664:	fe 01       	movw	r30, r28
    2666:	e8 94       	clt
    2668:	a5 91       	lpm	r26, Z+
    266a:	25 91       	lpm	r18, Z+
    266c:	35 91       	lpm	r19, Z+
    266e:	45 91       	lpm	r20, Z+
    2670:	55 91       	lpm	r21, Z+
    2672:	a6 f3       	brts	.-24     	; 0x265c <__fp_powser+0x16>
    2674:	ef 01       	movw	r28, r30
    2676:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <__addsf3x>
    267a:	fe 01       	movw	r30, r28
    267c:	97 01       	movw	r18, r14
    267e:	a8 01       	movw	r20, r16
    2680:	da 94       	dec	r13
    2682:	69 f7       	brne	.-38     	; 0x265e <__fp_powser+0x18>
    2684:	df 90       	pop	r13
    2686:	ef 90       	pop	r14
    2688:	ff 90       	pop	r15
    268a:	0f 91       	pop	r16
    268c:	1f 91       	pop	r17
    268e:	cf 91       	pop	r28
    2690:	df 91       	pop	r29
    2692:	08 95       	ret

00002694 <inverse>:
    2694:	9b 01       	movw	r18, r22
    2696:	ac 01       	movw	r20, r24
    2698:	60 e0       	ldi	r22, 0x00	; 0
    269a:	70 e0       	ldi	r23, 0x00	; 0
    269c:	80 e8       	ldi	r24, 0x80	; 128
    269e:	9f e3       	ldi	r25, 0x3F	; 63
    26a0:	0c 94 d4 10 	jmp	0x21a8	; 0x21a8 <__divsf3>
    26a4:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>
    26a8:	0c 94 10 14 	jmp	0x2820	; 0x2820 <__fp_mpack>

000026ac <ldexp>:
    26ac:	0e 94 06 12 	call	0x240c	; 0x240c <__fp_splitA>
    26b0:	d8 f3       	brcs	.-10     	; 0x26a8 <inverse+0x14>
    26b2:	99 23       	and	r25, r25
    26b4:	c9 f3       	breq	.-14     	; 0x26a8 <inverse+0x14>
    26b6:	94 0f       	add	r25, r20
    26b8:	51 1d       	adc	r21, r1
    26ba:	a3 f3       	brvs	.-24     	; 0x26a4 <inverse+0x10>
    26bc:	91 50       	subi	r25, 0x01	; 1
    26be:	50 40       	sbci	r21, 0x00	; 0
    26c0:	94 f0       	brlt	.+36     	; 0x26e6 <ldexp+0x3a>
    26c2:	59 f0       	breq	.+22     	; 0x26da <ldexp+0x2e>
    26c4:	88 23       	and	r24, r24
    26c6:	32 f0       	brmi	.+12     	; 0x26d4 <ldexp+0x28>
    26c8:	66 0f       	add	r22, r22
    26ca:	77 1f       	adc	r23, r23
    26cc:	88 1f       	adc	r24, r24
    26ce:	91 50       	subi	r25, 0x01	; 1
    26d0:	50 40       	sbci	r21, 0x00	; 0
    26d2:	c1 f7       	brne	.-16     	; 0x26c4 <ldexp+0x18>
    26d4:	9e 3f       	cpi	r25, 0xFE	; 254
    26d6:	51 05       	cpc	r21, r1
    26d8:	2c f7       	brge	.-54     	; 0x26a4 <inverse+0x10>
    26da:	88 0f       	add	r24, r24
    26dc:	91 1d       	adc	r25, r1
    26de:	96 95       	lsr	r25
    26e0:	87 95       	ror	r24
    26e2:	97 f9       	bld	r25, 7
    26e4:	08 95       	ret
    26e6:	5f 3f       	cpi	r21, 0xFF	; 255
    26e8:	ac f0       	brlt	.+42     	; 0x2714 <ldexp+0x68>
    26ea:	98 3e       	cpi	r25, 0xE8	; 232
    26ec:	9c f0       	brlt	.+38     	; 0x2714 <ldexp+0x68>
    26ee:	bb 27       	eor	r27, r27
    26f0:	86 95       	lsr	r24
    26f2:	77 95       	ror	r23
    26f4:	67 95       	ror	r22
    26f6:	b7 95       	ror	r27
    26f8:	08 f4       	brcc	.+2      	; 0x26fc <ldexp+0x50>
    26fa:	b1 60       	ori	r27, 0x01	; 1
    26fc:	93 95       	inc	r25
    26fe:	c1 f7       	brne	.-16     	; 0x26f0 <ldexp+0x44>
    2700:	bb 0f       	add	r27, r27
    2702:	58 f7       	brcc	.-42     	; 0x26da <ldexp+0x2e>
    2704:	11 f4       	brne	.+4      	; 0x270a <ldexp+0x5e>
    2706:	60 ff       	sbrs	r22, 0
    2708:	e8 cf       	rjmp	.-48     	; 0x26da <ldexp+0x2e>
    270a:	6f 5f       	subi	r22, 0xFF	; 255
    270c:	7f 4f       	sbci	r23, 0xFF	; 255
    270e:	8f 4f       	sbci	r24, 0xFF	; 255
    2710:	9f 4f       	sbci	r25, 0xFF	; 255
    2712:	e3 cf       	rjmp	.-58     	; 0x26da <ldexp+0x2e>
    2714:	0c 94 21 12 	jmp	0x2442	; 0x2442 <__fp_szero>
    2718:	16 f0       	brts	.+4      	; 0x271e <ldexp+0x72>
    271a:	0c 94 10 14 	jmp	0x2820	; 0x2820 <__fp_mpack>
    271e:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <__fp_nan>
    2722:	68 94       	set
    2724:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__fp_inf>

00002728 <log>:
    2728:	0e 94 06 12 	call	0x240c	; 0x240c <__fp_splitA>
    272c:	a8 f3       	brcs	.-22     	; 0x2718 <ldexp+0x6c>
    272e:	99 23       	and	r25, r25
    2730:	c1 f3       	breq	.-16     	; 0x2722 <ldexp+0x76>
    2732:	ae f3       	brts	.-22     	; 0x271e <ldexp+0x72>
    2734:	df 93       	push	r29
    2736:	cf 93       	push	r28
    2738:	1f 93       	push	r17
    273a:	0f 93       	push	r16
    273c:	ff 92       	push	r15
    273e:	c9 2f       	mov	r28, r25
    2740:	dd 27       	eor	r29, r29
    2742:	88 23       	and	r24, r24
    2744:	2a f0       	brmi	.+10     	; 0x2750 <log+0x28>
    2746:	21 97       	sbiw	r28, 0x01	; 1
    2748:	66 0f       	add	r22, r22
    274a:	77 1f       	adc	r23, r23
    274c:	88 1f       	adc	r24, r24
    274e:	da f7       	brpl	.-10     	; 0x2746 <log+0x1e>
    2750:	20 e0       	ldi	r18, 0x00	; 0
    2752:	30 e0       	ldi	r19, 0x00	; 0
    2754:	40 e8       	ldi	r20, 0x80	; 128
    2756:	5f eb       	ldi	r21, 0xBF	; 191
    2758:	9f e3       	ldi	r25, 0x3F	; 63
    275a:	88 39       	cpi	r24, 0x98	; 152
    275c:	20 f0       	brcs	.+8      	; 0x2766 <log+0x3e>
    275e:	80 3e       	cpi	r24, 0xE0	; 224
    2760:	38 f0       	brcs	.+14     	; 0x2770 <log+0x48>
    2762:	21 96       	adiw	r28, 0x01	; 1
    2764:	8f 77       	andi	r24, 0x7F	; 127
    2766:	0e 94 63 10 	call	0x20c6	; 0x20c6 <__addsf3>
    276a:	ec e7       	ldi	r30, 0x7C	; 124
    276c:	f0 e0       	ldi	r31, 0x00	; 0
    276e:	04 c0       	rjmp	.+8      	; 0x2778 <log+0x50>
    2770:	0e 94 63 10 	call	0x20c6	; 0x20c6 <__addsf3>
    2774:	e9 ea       	ldi	r30, 0xA9	; 169
    2776:	f0 e0       	ldi	r31, 0x00	; 0
    2778:	0e 94 23 13 	call	0x2646	; 0x2646 <__fp_powser>
    277c:	8b 01       	movw	r16, r22
    277e:	be 01       	movw	r22, r28
    2780:	ec 01       	movw	r28, r24
    2782:	fb 2e       	mov	r15, r27
    2784:	6f 57       	subi	r22, 0x7F	; 127
    2786:	71 09       	sbc	r23, r1
    2788:	75 95       	asr	r23
    278a:	77 1f       	adc	r23, r23
    278c:	88 0b       	sbc	r24, r24
    278e:	99 0b       	sbc	r25, r25
    2790:	0e 94 77 11 	call	0x22ee	; 0x22ee <__floatsisf>
    2794:	28 e1       	ldi	r18, 0x18	; 24
    2796:	32 e7       	ldi	r19, 0x72	; 114
    2798:	41 e3       	ldi	r20, 0x31	; 49
    279a:	5f e3       	ldi	r21, 0x3F	; 63
    279c:	0e 94 3f 12 	call	0x247e	; 0x247e <__mulsf3x>
    27a0:	af 2d       	mov	r26, r15
    27a2:	98 01       	movw	r18, r16
    27a4:	ae 01       	movw	r20, r28
    27a6:	ff 90       	pop	r15
    27a8:	0f 91       	pop	r16
    27aa:	1f 91       	pop	r17
    27ac:	cf 91       	pop	r28
    27ae:	df 91       	pop	r29
    27b0:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <__addsf3x>
    27b4:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__fp_round>

000027b8 <modf>:
    27b8:	fa 01       	movw	r30, r20
    27ba:	dc 01       	movw	r26, r24
    27bc:	aa 0f       	add	r26, r26
    27be:	bb 1f       	adc	r27, r27
    27c0:	9b 01       	movw	r18, r22
    27c2:	ac 01       	movw	r20, r24
    27c4:	bf 57       	subi	r27, 0x7F	; 127
    27c6:	28 f4       	brcc	.+10     	; 0x27d2 <modf+0x1a>
    27c8:	22 27       	eor	r18, r18
    27ca:	33 27       	eor	r19, r19
    27cc:	44 27       	eor	r20, r20
    27ce:	50 78       	andi	r21, 0x80	; 128
    27d0:	20 c0       	rjmp	.+64     	; 0x2812 <modf+0x5a>
    27d2:	b7 51       	subi	r27, 0x17	; 23
    27d4:	90 f4       	brcc	.+36     	; 0x27fa <modf+0x42>
    27d6:	ab 2f       	mov	r26, r27
    27d8:	00 24       	eor	r0, r0
    27da:	46 95       	lsr	r20
    27dc:	37 95       	ror	r19
    27de:	27 95       	ror	r18
    27e0:	01 1c       	adc	r0, r1
    27e2:	a3 95       	inc	r26
    27e4:	d2 f3       	brmi	.-12     	; 0x27da <modf+0x22>
    27e6:	00 20       	and	r0, r0
    27e8:	71 f0       	breq	.+28     	; 0x2806 <modf+0x4e>
    27ea:	22 0f       	add	r18, r18
    27ec:	33 1f       	adc	r19, r19
    27ee:	44 1f       	adc	r20, r20
    27f0:	b3 95       	inc	r27
    27f2:	da f3       	brmi	.-10     	; 0x27ea <modf+0x32>
    27f4:	0e d0       	rcall	.+28     	; 0x2812 <modf+0x5a>
    27f6:	0c 94 62 10 	jmp	0x20c4	; 0x20c4 <__subsf3>
    27fa:	61 30       	cpi	r22, 0x01	; 1
    27fc:	71 05       	cpc	r23, r1
    27fe:	a0 e8       	ldi	r26, 0x80	; 128
    2800:	8a 07       	cpc	r24, r26
    2802:	b9 46       	sbci	r27, 0x69	; 105
    2804:	30 f4       	brcc	.+12     	; 0x2812 <modf+0x5a>
    2806:	9b 01       	movw	r18, r22
    2808:	ac 01       	movw	r20, r24
    280a:	66 27       	eor	r22, r22
    280c:	77 27       	eor	r23, r23
    280e:	88 27       	eor	r24, r24
    2810:	90 78       	andi	r25, 0x80	; 128
    2812:	30 96       	adiw	r30, 0x00	; 0
    2814:	21 f0       	breq	.+8      	; 0x281e <modf+0x66>
    2816:	20 83       	st	Z, r18
    2818:	31 83       	std	Z+1, r19	; 0x01
    281a:	42 83       	std	Z+2, r20	; 0x02
    281c:	53 83       	std	Z+3, r21	; 0x03
    281e:	08 95       	ret

00002820 <__fp_mpack>:
    2820:	9f 3f       	cpi	r25, 0xFF	; 255
    2822:	31 f0       	breq	.+12     	; 0x2830 <__fp_mpack_finite+0xc>

00002824 <__fp_mpack_finite>:
    2824:	91 50       	subi	r25, 0x01	; 1
    2826:	20 f4       	brcc	.+8      	; 0x2830 <__fp_mpack_finite+0xc>
    2828:	87 95       	ror	r24
    282a:	77 95       	ror	r23
    282c:	67 95       	ror	r22
    282e:	b7 95       	ror	r27
    2830:	88 0f       	add	r24, r24
    2832:	91 1d       	adc	r25, r1
    2834:	96 95       	lsr	r25
    2836:	87 95       	ror	r24
    2838:	97 f9       	bld	r25, 7
    283a:	08 95       	ret

0000283c <strcmp>:
    283c:	fb 01       	movw	r30, r22
    283e:	dc 01       	movw	r26, r24
    2840:	8d 91       	ld	r24, X+
    2842:	01 90       	ld	r0, Z+
    2844:	80 19       	sub	r24, r0
    2846:	01 10       	cpse	r0, r1
    2848:	d9 f3       	breq	.-10     	; 0x2840 <strcmp+0x4>
    284a:	99 0b       	sbc	r25, r25
    284c:	08 95       	ret

0000284e <_exit>:
    284e:	f8 94       	cli

00002850 <__stop_program>:
    2850:	ff cf       	rjmp	.-2      	; 0x2850 <__stop_program>
